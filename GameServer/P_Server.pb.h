// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Server.proto

#ifndef PROTOBUF_P_5fServer_2eproto__INCLUDED
#define PROTOBUF_P_5fServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "P_Asset.pb.h"
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fServer_2eproto();
void protobuf_AssignDesc_P_5fServer_2eproto();
void protobuf_ShutdownFile_P_5fServer_2eproto();

class MsgItem;
class MsgItems;
class FamilyName;
class WomanName;
class ManName;
class SeverConfig;
class SeverConfig_SeverElement;
class WhiteList;
class BlackList;
class MatchStatistics;
class MatchStatistics_MatchingRoom;
class MatchStatistics_MatchingRoom_MatchingElement;

enum MSG_TYPE {
  MSG_TYPE_BEGIN = 1,
  MSG_TYPE_AOI_ENTER = 2,
  MSG_TYPE_AOI_LEAVE = 3,
  MSG_TYPE_AOI_MOVE = 4
};
bool MSG_TYPE_IsValid(int value);
const MSG_TYPE MSG_TYPE_MIN = MSG_TYPE_BEGIN;
const MSG_TYPE MSG_TYPE_MAX = MSG_TYPE_AOI_MOVE;
const int MSG_TYPE_ARRAYSIZE = MSG_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_TYPE_descriptor();
inline const ::std::string& MSG_TYPE_Name(MSG_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_TYPE_descriptor(), value);
}
inline bool MSG_TYPE_Parse(
    const ::std::string& name, MSG_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG_TYPE>(
    MSG_TYPE_descriptor(), name, value);
}
// ===================================================================

class MsgItem : public ::google::protobuf::Message {
 public:
  MsgItem();
  virtual ~MsgItem();

  MsgItem(const MsgItem& from);

  inline MsgItem& operator=(const MsgItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgItem& default_instance();

  void Swap(MsgItem* other);

  // implements Message ----------------------------------------------

  MsgItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgItem& from);
  void MergeFrom(const MsgItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int64 message_id() const;
  inline void set_message_id(::google::protobuf::int64 value);

  // optional int32 type_t = 2;
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 2;
  inline ::google::protobuf::int32 type_t() const;
  inline void set_type_t(::google::protobuf::int32 value);

  // optional int32 priority = 3 [default = 10];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional int64 sender = 4;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 4;
  inline ::google::protobuf::int64 sender() const;
  inline void set_sender(::google::protobuf::int64 value);

  // optional int64 receiver = 5;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 5;
  inline ::google::protobuf::int64 receiver() const;
  inline void set_receiver(::google::protobuf::int64 value);

  // optional int64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional int32 delay = 7;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 7;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);

  // optional bytes content = 8;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 8;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MsgItem)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 message_id_;
  ::google::protobuf::int32 type_t_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::int64 sender_;
  ::google::protobuf::int64 receiver_;
  ::google::protobuf::int64 time_;
  ::std::string* content_;
  ::google::protobuf::int32 delay_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static MsgItem* default_instance_;
};
// -------------------------------------------------------------------

class MsgItems : public ::google::protobuf::Message {
 public:
  MsgItems();
  virtual ~MsgItems();

  MsgItems(const MsgItems& from);

  inline MsgItems& operator=(const MsgItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgItems& default_instance();

  void Swap(MsgItems* other);

  // implements Message ----------------------------------------------

  MsgItems* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgItems& from);
  void MergeFrom(const MsgItems& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.MsgItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Adoter::Asset::MsgItem& items(int index) const;
  inline ::Adoter::Asset::MsgItem* mutable_items(int index);
  inline ::Adoter::Asset::MsgItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MsgItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MsgItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MsgItems)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MsgItem > items_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static MsgItems* default_instance_;
};
// -------------------------------------------------------------------

class FamilyName : public ::google::protobuf::Message {
 public:
  FamilyName();
  virtual ~FamilyName();

  FamilyName(const FamilyName& from);

  inline FamilyName& operator=(const FamilyName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FamilyName& default_instance();

  void Swap(FamilyName* other);

  // implements Message ----------------------------------------------

  FamilyName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FamilyName& from);
  void MergeFrom(const FamilyName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const void* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.FamilyName)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static FamilyName* default_instance_;
};
// -------------------------------------------------------------------

class WomanName : public ::google::protobuf::Message {
 public:
  WomanName();
  virtual ~WomanName();

  WomanName(const WomanName& from);

  inline WomanName& operator=(const WomanName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WomanName& default_instance();

  void Swap(WomanName* other);

  // implements Message ----------------------------------------------

  WomanName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WomanName& from);
  void MergeFrom(const WomanName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const void* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WomanName)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static WomanName* default_instance_;
};
// -------------------------------------------------------------------

class ManName : public ::google::protobuf::Message {
 public:
  ManName();
  virtual ~ManName();

  ManName(const ManName& from);

  inline ManName& operator=(const ManName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManName& default_instance();

  void Swap(ManName* other);

  // implements Message ----------------------------------------------

  ManName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManName& from);
  void MergeFrom(const ManName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const void* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ManName)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static ManName* default_instance_;
};
// -------------------------------------------------------------------

class SeverConfig_SeverElement : public ::google::protobuf::Message {
 public:
  SeverConfig_SeverElement();
  virtual ~SeverConfig_SeverElement();

  SeverConfig_SeverElement(const SeverConfig_SeverElement& from);

  inline SeverConfig_SeverElement& operator=(const SeverConfig_SeverElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SeverConfig_SeverElement& default_instance();

  void Swap(SeverConfig_SeverElement* other);

  // implements Message ----------------------------------------------

  SeverConfig_SeverElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeverConfig_SeverElement& from);
  void MergeFrom(const SeverConfig_SeverElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::int32 server_id() const;
  inline void set_server_id(::google::protobuf::int32 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes ip_address = 3 [default = "0.0.0.0"];
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 3;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const void* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // optional int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 thread_count = 5;
  inline bool has_thread_count() const;
  inline void clear_thread_count();
  static const int kThreadCountFieldNumber = 5;
  inline ::google::protobuf::int32 thread_count() const;
  inline void set_thread_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SeverConfig.SeverElement)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_thread_count();
  inline void clear_has_thread_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 server_id_;
  ::google::protobuf::int32 port_;
  static ::std::string* _default_ip_address_;
  ::std::string* ip_address_;
  ::google::protobuf::int32 thread_count_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static SeverConfig_SeverElement* default_instance_;
};
// -------------------------------------------------------------------

class SeverConfig : public ::google::protobuf::Message {
 public:
  SeverConfig();
  virtual ~SeverConfig();

  SeverConfig(const SeverConfig& from);

  inline SeverConfig& operator=(const SeverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SeverConfig& default_instance();

  void Swap(SeverConfig* other);

  // implements Message ----------------------------------------------

  SeverConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeverConfig& from);
  void MergeFrom(const SeverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SeverConfig_SeverElement SeverElement;

  // accessors -------------------------------------------------------

  // optional int32 zone_id = 1;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 1;
  inline ::google::protobuf::int32 zone_id() const;
  inline void set_zone_id(::google::protobuf::int32 value);

  // optional bytes description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .Adoter.Asset.SeverConfig.SeverElement local_server = 3;
  inline bool has_local_server() const;
  inline void clear_local_server();
  static const int kLocalServerFieldNumber = 3;
  inline const ::Adoter::Asset::SeverConfig_SeverElement& local_server() const;
  inline ::Adoter::Asset::SeverConfig_SeverElement* mutable_local_server();
  inline ::Adoter::Asset::SeverConfig_SeverElement* release_local_server();
  inline void set_allocated_local_server(::Adoter::Asset::SeverConfig_SeverElement* local_server);

  // optional .Adoter.Asset.SeverConfig.SeverElement center_server = 4;
  inline bool has_center_server() const;
  inline void clear_center_server();
  static const int kCenterServerFieldNumber = 4;
  inline const ::Adoter::Asset::SeverConfig_SeverElement& center_server() const;
  inline ::Adoter::Asset::SeverConfig_SeverElement* mutable_center_server();
  inline ::Adoter::Asset::SeverConfig_SeverElement* release_center_server();
  inline void set_allocated_center_server(::Adoter::Asset::SeverConfig_SeverElement* center_server);

  // optional .Adoter.Asset.SeverConfig.SeverElement gmt_server = 5;
  inline bool has_gmt_server() const;
  inline void clear_gmt_server();
  static const int kGmtServerFieldNumber = 5;
  inline const ::Adoter::Asset::SeverConfig_SeverElement& gmt_server() const;
  inline ::Adoter::Asset::SeverConfig_SeverElement* mutable_gmt_server();
  inline ::Adoter::Asset::SeverConfig_SeverElement* release_gmt_server();
  inline void set_allocated_gmt_server(::Adoter::Asset::SeverConfig_SeverElement* gmt_server);

  // optional .Adoter.Asset.SeverConfig.SeverElement game_server = 6;
  inline bool has_game_server() const;
  inline void clear_game_server();
  static const int kGameServerFieldNumber = 6;
  inline const ::Adoter::Asset::SeverConfig_SeverElement& game_server() const;
  inline ::Adoter::Asset::SeverConfig_SeverElement* mutable_game_server();
  inline ::Adoter::Asset::SeverConfig_SeverElement* release_game_server();
  inline void set_allocated_game_server(::Adoter::Asset::SeverConfig_SeverElement* game_server);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SeverConfig)
 private:
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_local_server();
  inline void clear_has_local_server();
  inline void set_has_center_server();
  inline void clear_has_center_server();
  inline void set_has_gmt_server();
  inline void clear_has_gmt_server();
  inline void set_has_game_server();
  inline void clear_has_game_server();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* description_;
  ::Adoter::Asset::SeverConfig_SeverElement* local_server_;
  ::Adoter::Asset::SeverConfig_SeverElement* center_server_;
  ::Adoter::Asset::SeverConfig_SeverElement* gmt_server_;
  ::Adoter::Asset::SeverConfig_SeverElement* game_server_;
  ::google::protobuf::int32 zone_id_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static SeverConfig* default_instance_;
};
// -------------------------------------------------------------------

class WhiteList : public ::google::protobuf::Message {
 public:
  WhiteList();
  virtual ~WhiteList();

  WhiteList(const WhiteList& from);

  inline WhiteList& operator=(const WhiteList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WhiteList& default_instance();

  void Swap(WhiteList* other);

  // implements Message ----------------------------------------------

  WhiteList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WhiteList& from);
  void MergeFrom(const WhiteList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool open = 1;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 1;
  inline bool open() const;
  inline void set_open(bool value);

  // repeated bytes ip_address = 2;
  inline int ip_address_size() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ip_address(int index) const;
  inline ::std::string* mutable_ip_address(int index);
  inline void set_ip_address(int index, const ::std::string& value);
  inline void set_ip_address(int index, const char* value);
  inline void set_ip_address(int index, const void* value, size_t size);
  inline ::std::string* add_ip_address();
  inline void add_ip_address(const ::std::string& value);
  inline void add_ip_address(const char* value);
  inline void add_ip_address(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_address() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_address();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WhiteList)
 private:
  inline void set_has_open();
  inline void clear_has_open();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_address_;
  bool open_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static WhiteList* default_instance_;
};
// -------------------------------------------------------------------

class BlackList : public ::google::protobuf::Message {
 public:
  BlackList();
  virtual ~BlackList();

  BlackList(const BlackList& from);

  inline BlackList& operator=(const BlackList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackList& default_instance();

  void Swap(BlackList* other);

  // implements Message ----------------------------------------------

  BlackList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlackList& from);
  void MergeFrom(const BlackList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool open = 1;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 1;
  inline bool open() const;
  inline void set_open(bool value);

  // repeated bytes ip_address = 2;
  inline int ip_address_size() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ip_address(int index) const;
  inline ::std::string* mutable_ip_address(int index);
  inline void set_ip_address(int index, const ::std::string& value);
  inline void set_ip_address(int index, const char* value);
  inline void set_ip_address(int index, const void* value, size_t size);
  inline ::std::string* add_ip_address();
  inline void add_ip_address(const ::std::string& value);
  inline void add_ip_address(const char* value);
  inline void add_ip_address(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_address() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_address();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.BlackList)
 private:
  inline void set_has_open();
  inline void clear_has_open();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_address_;
  bool open_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static BlackList* default_instance_;
};
// -------------------------------------------------------------------

class MatchStatistics_MatchingRoom_MatchingElement : public ::google::protobuf::Message {
 public:
  MatchStatistics_MatchingRoom_MatchingElement();
  virtual ~MatchStatistics_MatchingRoom_MatchingElement();

  MatchStatistics_MatchingRoom_MatchingElement(const MatchStatistics_MatchingRoom_MatchingElement& from);

  inline MatchStatistics_MatchingRoom_MatchingElement& operator=(const MatchStatistics_MatchingRoom_MatchingElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStatistics_MatchingRoom_MatchingElement& default_instance();

  void Swap(MatchStatistics_MatchingRoom_MatchingElement* other);

  // implements Message ----------------------------------------------

  MatchStatistics_MatchingRoom_MatchingElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStatistics_MatchingRoom_MatchingElement& from);
  void MergeFrom(const MatchStatistics_MatchingRoom_MatchingElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ROOM_TYPE room_type = 2;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROOM_TYPE room_type() const;
  inline void set_room_type(::Adoter::Asset::ROOM_TYPE value);

  // optional int32 player_count = 3;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 3;
  inline ::google::protobuf::int32 player_count() const;
  inline void set_player_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement)
 private:
  inline void set_has_room_type();
  inline void clear_has_room_type();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int room_type_;
  ::google::protobuf::int32 player_count_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static MatchStatistics_MatchingRoom_MatchingElement* default_instance_;
};
// -------------------------------------------------------------------

class MatchStatistics_MatchingRoom : public ::google::protobuf::Message {
 public:
  MatchStatistics_MatchingRoom();
  virtual ~MatchStatistics_MatchingRoom();

  MatchStatistics_MatchingRoom(const MatchStatistics_MatchingRoom& from);

  inline MatchStatistics_MatchingRoom& operator=(const MatchStatistics_MatchingRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStatistics_MatchingRoom& default_instance();

  void Swap(MatchStatistics_MatchingRoom* other);

  // implements Message ----------------------------------------------

  MatchStatistics_MatchingRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStatistics_MatchingRoom& from);
  void MergeFrom(const MatchStatistics_MatchingRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MatchStatistics_MatchingRoom_MatchingElement MatchingElement;

  // accessors -------------------------------------------------------

  // optional int64 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::int64 server_id() const;
  inline void set_server_id(::google::protobuf::int64 value);

  // repeated .Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement room_list = 2;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 2;
  inline const ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement& room_list(int index) const;
  inline ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement* mutable_room_list(int index);
  inline ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement* add_room_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement >&
      room_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MatchStatistics.MatchingRoom)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 server_id_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement > room_list_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static MatchStatistics_MatchingRoom* default_instance_;
};
// -------------------------------------------------------------------

class MatchStatistics : public ::google::protobuf::Message {
 public:
  MatchStatistics();
  virtual ~MatchStatistics();

  MatchStatistics(const MatchStatistics& from);

  inline MatchStatistics& operator=(const MatchStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStatistics& default_instance();

  void Swap(MatchStatistics* other);

  // implements Message ----------------------------------------------

  MatchStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStatistics& from);
  void MergeFrom(const MatchStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MatchStatistics_MatchingRoom MatchingRoom;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.MatchStatistics.MatchingRoom server_list = 1;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 1;
  inline const ::Adoter::Asset::MatchStatistics_MatchingRoom& server_list(int index) const;
  inline ::Adoter::Asset::MatchStatistics_MatchingRoom* mutable_server_list(int index);
  inline ::Adoter::Asset::MatchStatistics_MatchingRoom* add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom >&
      server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom >*
      mutable_server_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MatchStatistics)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom > server_list_;
  friend void  protobuf_AddDesc_P_5fServer_2eproto();
  friend void protobuf_AssignDesc_P_5fServer_2eproto();
  friend void protobuf_ShutdownFile_P_5fServer_2eproto();

  void InitAsDefaultInstance();
  static MatchStatistics* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgItem

// optional int64 message_id = 1;
inline bool MsgItem::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgItem::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgItem::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgItem::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 MsgItem::message_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.message_id)
  return message_id_;
}
inline void MsgItem::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.message_id)
}

// optional int32 type_t = 2;
inline bool MsgItem::has_type_t() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgItem::set_has_type_t() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgItem::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgItem::clear_type_t() {
  type_t_ = 0;
  clear_has_type_t();
}
inline ::google::protobuf::int32 MsgItem::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.type_t)
  return type_t_;
}
inline void MsgItem::set_type_t(::google::protobuf::int32 value) {
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.type_t)
}

// optional int32 priority = 3 [default = 10];
inline bool MsgItem::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgItem::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgItem::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgItem::clear_priority() {
  priority_ = 10;
  clear_has_priority();
}
inline ::google::protobuf::int32 MsgItem::priority() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.priority)
  return priority_;
}
inline void MsgItem::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.priority)
}

// optional int64 sender = 4;
inline bool MsgItem::has_sender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgItem::set_has_sender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgItem::clear_has_sender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgItem::clear_sender() {
  sender_ = GOOGLE_LONGLONG(0);
  clear_has_sender();
}
inline ::google::protobuf::int64 MsgItem::sender() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.sender)
  return sender_;
}
inline void MsgItem::set_sender(::google::protobuf::int64 value) {
  set_has_sender();
  sender_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.sender)
}

// optional int64 receiver = 5;
inline bool MsgItem::has_receiver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgItem::set_has_receiver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgItem::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgItem::clear_receiver() {
  receiver_ = GOOGLE_LONGLONG(0);
  clear_has_receiver();
}
inline ::google::protobuf::int64 MsgItem::receiver() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.receiver)
  return receiver_;
}
inline void MsgItem::set_receiver(::google::protobuf::int64 value) {
  set_has_receiver();
  receiver_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.receiver)
}

// optional int64 time = 6;
inline bool MsgItem::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgItem::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 MsgItem::time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.time)
  return time_;
}
inline void MsgItem::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.time)
}

// optional int32 delay = 7;
inline bool MsgItem::has_delay() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgItem::set_has_delay() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgItem::clear_has_delay() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgItem::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 MsgItem::delay() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.delay)
  return delay_;
}
inline void MsgItem::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.delay)
}

// optional bytes content = 8;
inline bool MsgItem::has_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgItem::set_has_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgItem::clear_has_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgItem::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MsgItem::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItem.content)
  return *content_;
}
inline void MsgItem::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.MsgItem.content)
}
inline void MsgItem::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.MsgItem.content)
}
inline void MsgItem::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.MsgItem.content)
}
inline ::std::string* MsgItem::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MsgItem.content)
  return content_;
}
inline ::std::string* MsgItem::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgItem::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.MsgItem.content)
}

// -------------------------------------------------------------------

// MsgItems

// repeated .Adoter.Asset.MsgItem items = 1;
inline int MsgItems::items_size() const {
  return items_.size();
}
inline void MsgItems::clear_items() {
  items_.Clear();
}
inline const ::Adoter::Asset::MsgItem& MsgItems::items(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MsgItems.items)
  return items_.Get(index);
}
inline ::Adoter::Asset::MsgItem* MsgItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MsgItems.items)
  return items_.Mutable(index);
}
inline ::Adoter::Asset::MsgItem* MsgItems::add_items() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.MsgItems.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MsgItem >&
MsgItems::items() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MsgItems.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MsgItem >*
MsgItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MsgItems.items)
  return &items_;
}

// -------------------------------------------------------------------

// FamilyName

// repeated bytes name = 1;
inline int FamilyName::name_size() const {
  return name_.size();
}
inline void FamilyName::clear_name() {
  name_.Clear();
}
inline const ::std::string& FamilyName::name(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.FamilyName.name)
  return name_.Get(index);
}
inline ::std::string* FamilyName::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.FamilyName.name)
  return name_.Mutable(index);
}
inline void FamilyName::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.FamilyName.name)
  name_.Mutable(index)->assign(value);
}
inline void FamilyName::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.FamilyName.name)
}
inline void FamilyName::set_name(int index, const void* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.FamilyName.name)
}
inline ::std::string* FamilyName::add_name() {
  return name_.Add();
}
inline void FamilyName::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.FamilyName.name)
}
inline void FamilyName::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.FamilyName.name)
}
inline void FamilyName::add_name(const void* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.FamilyName.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FamilyName::name() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.FamilyName.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FamilyName::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.FamilyName.name)
  return &name_;
}

// -------------------------------------------------------------------

// WomanName

// repeated bytes name = 1;
inline int WomanName::name_size() const {
  return name_.size();
}
inline void WomanName::clear_name() {
  name_.Clear();
}
inline const ::std::string& WomanName::name(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WomanName.name)
  return name_.Get(index);
}
inline ::std::string* WomanName::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WomanName.name)
  return name_.Mutable(index);
}
inline void WomanName::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.WomanName.name)
  name_.Mutable(index)->assign(value);
}
inline void WomanName::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WomanName.name)
}
inline void WomanName::set_name(int index, const void* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WomanName.name)
}
inline ::std::string* WomanName::add_name() {
  return name_.Add();
}
inline void WomanName::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.WomanName.name)
}
inline void WomanName::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.WomanName.name)
}
inline void WomanName::add_name(const void* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.WomanName.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WomanName::name() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.WomanName.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WomanName::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.WomanName.name)
  return &name_;
}

// -------------------------------------------------------------------

// ManName

// repeated bytes name = 1;
inline int ManName::name_size() const {
  return name_.size();
}
inline void ManName::clear_name() {
  name_.Clear();
}
inline const ::std::string& ManName::name(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ManName.name)
  return name_.Get(index);
}
inline ::std::string* ManName::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ManName.name)
  return name_.Mutable(index);
}
inline void ManName::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.ManName.name)
  name_.Mutable(index)->assign(value);
}
inline void ManName::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ManName.name)
}
inline void ManName::set_name(int index, const void* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ManName.name)
}
inline ::std::string* ManName::add_name() {
  return name_.Add();
}
inline void ManName::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.ManName.name)
}
inline void ManName::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.ManName.name)
}
inline void ManName::add_name(const void* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.ManName.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ManName::name() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.ManName.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ManName::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.ManName.name)
  return &name_;
}

// -------------------------------------------------------------------

// SeverConfig_SeverElement

// optional int32 server_id = 1;
inline bool SeverConfig_SeverElement::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeverConfig_SeverElement::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeverConfig_SeverElement::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeverConfig_SeverElement::clear_server_id() {
  server_id_ = 0;
  clear_has_server_id();
}
inline ::google::protobuf::int32 SeverConfig_SeverElement::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.SeverElement.server_id)
  return server_id_;
}
inline void SeverConfig_SeverElement::set_server_id(::google::protobuf::int32 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.SeverElement.server_id)
}

// optional bytes name = 2;
inline bool SeverConfig_SeverElement::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SeverConfig_SeverElement::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SeverConfig_SeverElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SeverConfig_SeverElement::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SeverConfig_SeverElement::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.SeverElement.name)
  return *name_;
}
inline void SeverConfig_SeverElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.SeverElement.name)
}
inline void SeverConfig_SeverElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SeverConfig.SeverElement.name)
}
inline void SeverConfig_SeverElement::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SeverConfig.SeverElement.name)
}
inline ::std::string* SeverConfig_SeverElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.SeverElement.name)
  return name_;
}
inline ::std::string* SeverConfig_SeverElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SeverConfig_SeverElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.SeverElement.name)
}

// optional bytes ip_address = 3 [default = "0.0.0.0"];
inline bool SeverConfig_SeverElement::has_ip_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SeverConfig_SeverElement::set_has_ip_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SeverConfig_SeverElement::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SeverConfig_SeverElement::clear_ip_address() {
  if (ip_address_ != _default_ip_address_) {
    ip_address_->assign(*_default_ip_address_);
  }
  clear_has_ip_address();
}
inline const ::std::string& SeverConfig_SeverElement::ip_address() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.SeverElement.ip_address)
  return *ip_address_;
}
inline void SeverConfig_SeverElement::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == _default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.SeverElement.ip_address)
}
inline void SeverConfig_SeverElement::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == _default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SeverConfig.SeverElement.ip_address)
}
inline void SeverConfig_SeverElement::set_ip_address(const void* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == _default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SeverConfig.SeverElement.ip_address)
}
inline ::std::string* SeverConfig_SeverElement::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == _default_ip_address_) {
    ip_address_ = new ::std::string(*_default_ip_address_);
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.SeverElement.ip_address)
  return ip_address_;
}
inline ::std::string* SeverConfig_SeverElement::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == _default_ip_address_) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(_default_ip_address_);
    return temp;
  }
}
inline void SeverConfig_SeverElement::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != _default_ip_address_) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(_default_ip_address_);
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.SeverElement.ip_address)
}

// optional int32 port = 4;
inline bool SeverConfig_SeverElement::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SeverConfig_SeverElement::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SeverConfig_SeverElement::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SeverConfig_SeverElement::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 SeverConfig_SeverElement::port() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.SeverElement.port)
  return port_;
}
inline void SeverConfig_SeverElement::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.SeverElement.port)
}

// optional int32 thread_count = 5;
inline bool SeverConfig_SeverElement::has_thread_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SeverConfig_SeverElement::set_has_thread_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SeverConfig_SeverElement::clear_has_thread_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SeverConfig_SeverElement::clear_thread_count() {
  thread_count_ = 0;
  clear_has_thread_count();
}
inline ::google::protobuf::int32 SeverConfig_SeverElement::thread_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.SeverElement.thread_count)
  return thread_count_;
}
inline void SeverConfig_SeverElement::set_thread_count(::google::protobuf::int32 value) {
  set_has_thread_count();
  thread_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.SeverElement.thread_count)
}

// -------------------------------------------------------------------

// SeverConfig

// optional int32 zone_id = 1;
inline bool SeverConfig::has_zone_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeverConfig::set_has_zone_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeverConfig::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeverConfig::clear_zone_id() {
  zone_id_ = 0;
  clear_has_zone_id();
}
inline ::google::protobuf::int32 SeverConfig::zone_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.zone_id)
  return zone_id_;
}
inline void SeverConfig::set_zone_id(::google::protobuf::int32 value) {
  set_has_zone_id();
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.zone_id)
}

// optional bytes description = 2;
inline bool SeverConfig::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SeverConfig::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SeverConfig::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SeverConfig::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SeverConfig::description() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.description)
  return *description_;
}
inline void SeverConfig::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SeverConfig.description)
}
inline void SeverConfig::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SeverConfig.description)
}
inline void SeverConfig::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SeverConfig.description)
}
inline ::std::string* SeverConfig::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.description)
  return description_;
}
inline ::std::string* SeverConfig::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SeverConfig::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.description)
}

// optional .Adoter.Asset.SeverConfig.SeverElement local_server = 3;
inline bool SeverConfig::has_local_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SeverConfig::set_has_local_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SeverConfig::clear_has_local_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SeverConfig::clear_local_server() {
  if (local_server_ != NULL) local_server_->::Adoter::Asset::SeverConfig_SeverElement::Clear();
  clear_has_local_server();
}
inline const ::Adoter::Asset::SeverConfig_SeverElement& SeverConfig::local_server() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.local_server)
  return local_server_ != NULL ? *local_server_ : *default_instance_->local_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::mutable_local_server() {
  set_has_local_server();
  if (local_server_ == NULL) local_server_ = new ::Adoter::Asset::SeverConfig_SeverElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.local_server)
  return local_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::release_local_server() {
  clear_has_local_server();
  ::Adoter::Asset::SeverConfig_SeverElement* temp = local_server_;
  local_server_ = NULL;
  return temp;
}
inline void SeverConfig::set_allocated_local_server(::Adoter::Asset::SeverConfig_SeverElement* local_server) {
  delete local_server_;
  local_server_ = local_server;
  if (local_server) {
    set_has_local_server();
  } else {
    clear_has_local_server();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.local_server)
}

// optional .Adoter.Asset.SeverConfig.SeverElement center_server = 4;
inline bool SeverConfig::has_center_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SeverConfig::set_has_center_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SeverConfig::clear_has_center_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SeverConfig::clear_center_server() {
  if (center_server_ != NULL) center_server_->::Adoter::Asset::SeverConfig_SeverElement::Clear();
  clear_has_center_server();
}
inline const ::Adoter::Asset::SeverConfig_SeverElement& SeverConfig::center_server() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.center_server)
  return center_server_ != NULL ? *center_server_ : *default_instance_->center_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::mutable_center_server() {
  set_has_center_server();
  if (center_server_ == NULL) center_server_ = new ::Adoter::Asset::SeverConfig_SeverElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.center_server)
  return center_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::release_center_server() {
  clear_has_center_server();
  ::Adoter::Asset::SeverConfig_SeverElement* temp = center_server_;
  center_server_ = NULL;
  return temp;
}
inline void SeverConfig::set_allocated_center_server(::Adoter::Asset::SeverConfig_SeverElement* center_server) {
  delete center_server_;
  center_server_ = center_server;
  if (center_server) {
    set_has_center_server();
  } else {
    clear_has_center_server();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.center_server)
}

// optional .Adoter.Asset.SeverConfig.SeverElement gmt_server = 5;
inline bool SeverConfig::has_gmt_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SeverConfig::set_has_gmt_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SeverConfig::clear_has_gmt_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SeverConfig::clear_gmt_server() {
  if (gmt_server_ != NULL) gmt_server_->::Adoter::Asset::SeverConfig_SeverElement::Clear();
  clear_has_gmt_server();
}
inline const ::Adoter::Asset::SeverConfig_SeverElement& SeverConfig::gmt_server() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.gmt_server)
  return gmt_server_ != NULL ? *gmt_server_ : *default_instance_->gmt_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::mutable_gmt_server() {
  set_has_gmt_server();
  if (gmt_server_ == NULL) gmt_server_ = new ::Adoter::Asset::SeverConfig_SeverElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.gmt_server)
  return gmt_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::release_gmt_server() {
  clear_has_gmt_server();
  ::Adoter::Asset::SeverConfig_SeverElement* temp = gmt_server_;
  gmt_server_ = NULL;
  return temp;
}
inline void SeverConfig::set_allocated_gmt_server(::Adoter::Asset::SeverConfig_SeverElement* gmt_server) {
  delete gmt_server_;
  gmt_server_ = gmt_server;
  if (gmt_server) {
    set_has_gmt_server();
  } else {
    clear_has_gmt_server();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.gmt_server)
}

// optional .Adoter.Asset.SeverConfig.SeverElement game_server = 6;
inline bool SeverConfig::has_game_server() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SeverConfig::set_has_game_server() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SeverConfig::clear_has_game_server() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SeverConfig::clear_game_server() {
  if (game_server_ != NULL) game_server_->::Adoter::Asset::SeverConfig_SeverElement::Clear();
  clear_has_game_server();
}
inline const ::Adoter::Asset::SeverConfig_SeverElement& SeverConfig::game_server() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SeverConfig.game_server)
  return game_server_ != NULL ? *game_server_ : *default_instance_->game_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::mutable_game_server() {
  set_has_game_server();
  if (game_server_ == NULL) game_server_ = new ::Adoter::Asset::SeverConfig_SeverElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SeverConfig.game_server)
  return game_server_;
}
inline ::Adoter::Asset::SeverConfig_SeverElement* SeverConfig::release_game_server() {
  clear_has_game_server();
  ::Adoter::Asset::SeverConfig_SeverElement* temp = game_server_;
  game_server_ = NULL;
  return temp;
}
inline void SeverConfig::set_allocated_game_server(::Adoter::Asset::SeverConfig_SeverElement* game_server) {
  delete game_server_;
  game_server_ = game_server;
  if (game_server) {
    set_has_game_server();
  } else {
    clear_has_game_server();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SeverConfig.game_server)
}

// -------------------------------------------------------------------

// WhiteList

// optional bool open = 1;
inline bool WhiteList::has_open() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhiteList::set_has_open() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WhiteList::clear_has_open() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WhiteList::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool WhiteList::open() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WhiteList.open)
  return open_;
}
inline void WhiteList::set_open(bool value) {
  set_has_open();
  open_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WhiteList.open)
}

// repeated bytes ip_address = 2;
inline int WhiteList::ip_address_size() const {
  return ip_address_.size();
}
inline void WhiteList::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::std::string& WhiteList::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WhiteList.ip_address)
  return ip_address_.Get(index);
}
inline ::std::string* WhiteList::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WhiteList.ip_address)
  return ip_address_.Mutable(index);
}
inline void WhiteList::set_ip_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.WhiteList.ip_address)
  ip_address_.Mutable(index)->assign(value);
}
inline void WhiteList::set_ip_address(int index, const char* value) {
  ip_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WhiteList.ip_address)
}
inline void WhiteList::set_ip_address(int index, const void* value, size_t size) {
  ip_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WhiteList.ip_address)
}
inline ::std::string* WhiteList::add_ip_address() {
  return ip_address_.Add();
}
inline void WhiteList::add_ip_address(const ::std::string& value) {
  ip_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.WhiteList.ip_address)
}
inline void WhiteList::add_ip_address(const char* value) {
  ip_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.WhiteList.ip_address)
}
inline void WhiteList::add_ip_address(const void* value, size_t size) {
  ip_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.WhiteList.ip_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WhiteList::ip_address() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.WhiteList.ip_address)
  return ip_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WhiteList::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.WhiteList.ip_address)
  return &ip_address_;
}

// -------------------------------------------------------------------

// BlackList

// optional bool open = 1;
inline bool BlackList::has_open() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackList::set_has_open() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackList::clear_has_open() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackList::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool BlackList::open() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BlackList.open)
  return open_;
}
inline void BlackList::set_open(bool value) {
  set_has_open();
  open_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BlackList.open)
}

// repeated bytes ip_address = 2;
inline int BlackList::ip_address_size() const {
  return ip_address_.size();
}
inline void BlackList::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::std::string& BlackList::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BlackList.ip_address)
  return ip_address_.Get(index);
}
inline ::std::string* BlackList::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.BlackList.ip_address)
  return ip_address_.Mutable(index);
}
inline void BlackList::set_ip_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.BlackList.ip_address)
  ip_address_.Mutable(index)->assign(value);
}
inline void BlackList::set_ip_address(int index, const char* value) {
  ip_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.BlackList.ip_address)
}
inline void BlackList::set_ip_address(int index, const void* value, size_t size) {
  ip_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.BlackList.ip_address)
}
inline ::std::string* BlackList::add_ip_address() {
  return ip_address_.Add();
}
inline void BlackList::add_ip_address(const ::std::string& value) {
  ip_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.BlackList.ip_address)
}
inline void BlackList::add_ip_address(const char* value) {
  ip_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.BlackList.ip_address)
}
inline void BlackList::add_ip_address(const void* value, size_t size) {
  ip_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.BlackList.ip_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlackList::ip_address() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.BlackList.ip_address)
  return ip_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlackList::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.BlackList.ip_address)
  return &ip_address_;
}

// -------------------------------------------------------------------

// MatchStatistics_MatchingRoom_MatchingElement

// optional .Adoter.Asset.ROOM_TYPE room_type = 2;
inline bool MatchStatistics_MatchingRoom_MatchingElement::has_room_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::set_has_room_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::clear_room_type() {
  room_type_ = 1;
  clear_has_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE MatchStatistics_MatchingRoom_MatchingElement::room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement.room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(room_type_);
}
inline void MatchStatistics_MatchingRoom_MatchingElement::set_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement.room_type)
}

// optional int32 player_count = 3;
inline bool MatchStatistics_MatchingRoom_MatchingElement::has_player_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::set_has_player_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::clear_player_count() {
  player_count_ = 0;
  clear_has_player_count();
}
inline ::google::protobuf::int32 MatchStatistics_MatchingRoom_MatchingElement::player_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement.player_count)
  return player_count_;
}
inline void MatchStatistics_MatchingRoom_MatchingElement::set_player_count(::google::protobuf::int32 value) {
  set_has_player_count();
  player_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement.player_count)
}

// -------------------------------------------------------------------

// MatchStatistics_MatchingRoom

// optional int64 server_id = 1;
inline bool MatchStatistics_MatchingRoom::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStatistics_MatchingRoom::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStatistics_MatchingRoom::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStatistics_MatchingRoom::clear_server_id() {
  server_id_ = GOOGLE_LONGLONG(0);
  clear_has_server_id();
}
inline ::google::protobuf::int64 MatchStatistics_MatchingRoom::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStatistics.MatchingRoom.server_id)
  return server_id_;
}
inline void MatchStatistics_MatchingRoom::set_server_id(::google::protobuf::int64 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStatistics.MatchingRoom.server_id)
}

// repeated .Adoter.Asset.MatchStatistics.MatchingRoom.MatchingElement room_list = 2;
inline int MatchStatistics_MatchingRoom::room_list_size() const {
  return room_list_.size();
}
inline void MatchStatistics_MatchingRoom::clear_room_list() {
  room_list_.Clear();
}
inline const ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement& MatchStatistics_MatchingRoom::room_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStatistics.MatchingRoom.room_list)
  return room_list_.Get(index);
}
inline ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement* MatchStatistics_MatchingRoom::mutable_room_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MatchStatistics.MatchingRoom.room_list)
  return room_list_.Mutable(index);
}
inline ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement* MatchStatistics_MatchingRoom::add_room_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.MatchStatistics.MatchingRoom.room_list)
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement >&
MatchStatistics_MatchingRoom::room_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MatchStatistics.MatchingRoom.room_list)
  return room_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom_MatchingElement >*
MatchStatistics_MatchingRoom::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MatchStatistics.MatchingRoom.room_list)
  return &room_list_;
}

// -------------------------------------------------------------------

// MatchStatistics

// repeated .Adoter.Asset.MatchStatistics.MatchingRoom server_list = 1;
inline int MatchStatistics::server_list_size() const {
  return server_list_.size();
}
inline void MatchStatistics::clear_server_list() {
  server_list_.Clear();
}
inline const ::Adoter::Asset::MatchStatistics_MatchingRoom& MatchStatistics::server_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStatistics.server_list)
  return server_list_.Get(index);
}
inline ::Adoter::Asset::MatchStatistics_MatchingRoom* MatchStatistics::mutable_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MatchStatistics.server_list)
  return server_list_.Mutable(index);
}
inline ::Adoter::Asset::MatchStatistics_MatchingRoom* MatchStatistics::add_server_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.MatchStatistics.server_list)
  return server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom >&
MatchStatistics::server_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MatchStatistics.server_list)
  return server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStatistics_MatchingRoom >*
MatchStatistics::mutable_server_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MatchStatistics.server_list)
  return &server_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::MSG_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::MSG_TYPE>() {
  return ::Adoter::Asset::MSG_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fServer_2eproto__INCLUDED
