// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Protocol.proto

#ifndef PROTOBUF_P_5fProtocol_2eproto__INCLUDED
#define PROTOBUF_P_5fProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "P_Asset.pb.h"
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fProtocol_2eproto();
void protobuf_AssignDesc_P_5fProtocol_2eproto();
void protobuf_ShutdownFile_P_5fProtocol_2eproto();

class Account;
class PaiElement;
class ShunZi;
class ItemElement;
class User;
class PlayerProp;
class PlayerBrief;
class GameRecord;
class GameRecord_GameElement;
class GameRecord_GameElement_DetailElement;
class RoomHistory;
class CommonProp;
class PlayerCommonLimit;
class PlayerCommonLimit_Element;
class PlayerCoolDown;
class PlayerCoolDown_Element;
class Location;
class ClientInfomation;
class Mail;
class Player;
class Inventory;
class Inventory_Element;
class SystemMessage;
class Clan;
class Clan_Member;
class Clan_RoomHistory;
class ItemEquipment;
class Meta;
class CreatePlayer;
class Login;
class WechatAccessToken;
class WechatError;
class WechatLogin;
class SwitchAccount;
class GetRoomData;
class UpdateRoom;
class WechatUnion;
class Logout;
class EnterGame;
class UpdateClientData;
class SystemChat;
class Room;
class CreateRoom;
class EnterRoom;
class Sign;
class PlayerLuckyPlate;
class RandomSaizi;
class SayHi;
class GuestLogin;
class PlayerSetting;
class GameSetting;
class BattleHistory;
class UserRecharge;
class PlayBack;
class PlayBack_PlayerElement;
class GetReward;
class PaiOperationCache;
class PaiOperation;
class GameOperation;
class BuySomething;
class LoadScene;
class ReConnect;
class MatchStats;
class MatchStats_MatchingRoom;
class ClanOperation;
class PlayerList;
class PlayerInformation;
class AlertMessage;
class LiuJu;
class LiuJu_LJElement;
class PaiNotify;
class PaiNotify_MutiPai;
class PaiNotify_SinglePai;
class SyncCommonProperty;
class PaiOperationAlert;
class PaiOperationAlert_AlertElement;
class SyncCommonLimit;
class SyncCommonReward;
class RoomInformation;
class RoomInformation_Player;
class RoomInformation_Player_DistanceElement;
class GameCalculate;
class RoomRecord;
class RoomCalculate;
class GameInformation;
class KickOut;
class SyncActivity;
class SyncActivity_ActivityElement;
class SystemBroadcasting;
class MultiplePai;
class PaiPushDown;
class PaiPushDown_PlayerElement;
class GamesFull;
class WeChatInfo;
class GameStart;
class RoomDisMiss;
class RoomDisMiss_RoomElement;
class RoomState;
class BattleList;
class RoomAll;
class RoomAll_Player;
class RoomBeenIn;
class RoomQueryResult;
class RegisterServer;
class KickOutPlayer;
class GmtInnerMeta;
class PlayerState;
class ClanRoomStatusChanged;
class ClanRoomSync;

enum EnterRoom_ENTER_TYPE {
  EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER = 1,
  EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL = 2
};
bool EnterRoom_ENTER_TYPE_IsValid(int value);
const EnterRoom_ENTER_TYPE EnterRoom_ENTER_TYPE_ENTER_TYPE_MIN = EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER;
const EnterRoom_ENTER_TYPE EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX = EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL;
const int EnterRoom_ENTER_TYPE_ENTER_TYPE_ARRAYSIZE = EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnterRoom_ENTER_TYPE_descriptor();
inline const ::std::string& EnterRoom_ENTER_TYPE_Name(EnterRoom_ENTER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnterRoom_ENTER_TYPE_descriptor(), value);
}
inline bool EnterRoom_ENTER_TYPE_Parse(
    const ::std::string& name, EnterRoom_ENTER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnterRoom_ENTER_TYPE>(
    EnterRoom_ENTER_TYPE_descriptor(), name, value);
}
enum RandomSaizi_REASON_TYPE {
  RandomSaizi_REASON_TYPE_REASON_TYPE_START = 1,
  RandomSaizi_REASON_TYPE_REASON_TYPE_TINGPAI = 2,
  RandomSaizi_REASON_TYPE_REASON_TYPE_HUIPAI = 3
};
bool RandomSaizi_REASON_TYPE_IsValid(int value);
const RandomSaizi_REASON_TYPE RandomSaizi_REASON_TYPE_REASON_TYPE_MIN = RandomSaizi_REASON_TYPE_REASON_TYPE_START;
const RandomSaizi_REASON_TYPE RandomSaizi_REASON_TYPE_REASON_TYPE_MAX = RandomSaizi_REASON_TYPE_REASON_TYPE_HUIPAI;
const int RandomSaizi_REASON_TYPE_REASON_TYPE_ARRAYSIZE = RandomSaizi_REASON_TYPE_REASON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RandomSaizi_REASON_TYPE_descriptor();
inline const ::std::string& RandomSaizi_REASON_TYPE_Name(RandomSaizi_REASON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RandomSaizi_REASON_TYPE_descriptor(), value);
}
inline bool RandomSaizi_REASON_TYPE_Parse(
    const ::std::string& name, RandomSaizi_REASON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RandomSaizi_REASON_TYPE>(
    RandomSaizi_REASON_TYPE_descriptor(), name, value);
}
enum GetReward_GET_REWARD_REASON {
  GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS = 1,
  GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_ALLOWANCE = 2,
  GetReward_GET_REWARD_REASON_GET_REWARD_REASON_SHARED = 3
};
bool GetReward_GET_REWARD_REASON_IsValid(int value);
const GetReward_GET_REWARD_REASON GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MIN = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS;
const GetReward_GET_REWARD_REASON GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_SHARED;
const int GetReward_GET_REWARD_REASON_GET_REWARD_REASON_ARRAYSIZE = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetReward_GET_REWARD_REASON_descriptor();
inline const ::std::string& GetReward_GET_REWARD_REASON_Name(GetReward_GET_REWARD_REASON value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetReward_GET_REWARD_REASON_descriptor(), value);
}
inline bool GetReward_GET_REWARD_REASON_Parse(
    const ::std::string& name, GetReward_GET_REWARD_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetReward_GET_REWARD_REASON>(
    GetReward_GET_REWARD_REASON_descriptor(), name, value);
}
enum PaiNotify_CARDS_DATA_TYPE {
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START = 1,
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_FAPAI = 2,
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC = 3
};
bool PaiNotify_CARDS_DATA_TYPE_IsValid(int value);
const PaiNotify_CARDS_DATA_TYPE PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MIN = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START;
const PaiNotify_CARDS_DATA_TYPE PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC;
const int PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_ARRAYSIZE = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PaiNotify_CARDS_DATA_TYPE_descriptor();
inline const ::std::string& PaiNotify_CARDS_DATA_TYPE_Name(PaiNotify_CARDS_DATA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PaiNotify_CARDS_DATA_TYPE_descriptor(), value);
}
inline bool PaiNotify_CARDS_DATA_TYPE_Parse(
    const ::std::string& name, PaiNotify_CARDS_DATA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PaiNotify_CARDS_DATA_TYPE>(
    PaiNotify_CARDS_DATA_TYPE_descriptor(), name, value);
}
enum SyncCommonProperty_SYNC_REASON_TYPE {
  SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF = 1,
  SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_GET = 2
};
bool SyncCommonProperty_SYNC_REASON_TYPE_IsValid(int value);
const SyncCommonProperty_SYNC_REASON_TYPE SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MIN = SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF;
const SyncCommonProperty_SYNC_REASON_TYPE SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX = SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_GET;
const int SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ARRAYSIZE = SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SyncCommonProperty_SYNC_REASON_TYPE_descriptor();
inline const ::std::string& SyncCommonProperty_SYNC_REASON_TYPE_Name(SyncCommonProperty_SYNC_REASON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SyncCommonProperty_SYNC_REASON_TYPE_descriptor(), value);
}
inline bool SyncCommonProperty_SYNC_REASON_TYPE_Parse(
    const ::std::string& name, SyncCommonProperty_SYNC_REASON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SyncCommonProperty_SYNC_REASON_TYPE>(
    SyncCommonProperty_SYNC_REASON_TYPE_descriptor(), name, value);
}
enum ERR_USE_ITEM_TYPE {
  ERR_USE_ITEM_TYPE_SUCCESS = 0,
  ERR_USE_ITEM_TYPE_LEVEL_BELOW = 1,
  ERR_USE_ITEM_TYPE_LEVEL_UP = 2
};
bool ERR_USE_ITEM_TYPE_IsValid(int value);
const ERR_USE_ITEM_TYPE ERR_USE_ITEM_TYPE_MIN = ERR_USE_ITEM_TYPE_SUCCESS;
const ERR_USE_ITEM_TYPE ERR_USE_ITEM_TYPE_MAX = ERR_USE_ITEM_TYPE_LEVEL_UP;
const int ERR_USE_ITEM_TYPE_ARRAYSIZE = ERR_USE_ITEM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERR_USE_ITEM_TYPE_descriptor();
inline const ::std::string& ERR_USE_ITEM_TYPE_Name(ERR_USE_ITEM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERR_USE_ITEM_TYPE_descriptor(), value);
}
inline bool ERR_USE_ITEM_TYPE_Parse(
    const ::std::string& name, ERR_USE_ITEM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERR_USE_ITEM_TYPE>(
    ERR_USE_ITEM_TYPE_descriptor(), name, value);
}
enum ITEM_CHANGED_TYPE {
  ITEM_CHANGED_TYPE_GMT = 1,
  ITEM_CHANGED_TYPE_MALL = 2
};
bool ITEM_CHANGED_TYPE_IsValid(int value);
const ITEM_CHANGED_TYPE ITEM_CHANGED_TYPE_MIN = ITEM_CHANGED_TYPE_GMT;
const ITEM_CHANGED_TYPE ITEM_CHANGED_TYPE_MAX = ITEM_CHANGED_TYPE_MALL;
const int ITEM_CHANGED_TYPE_ARRAYSIZE = ITEM_CHANGED_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ITEM_CHANGED_TYPE_descriptor();
inline const ::std::string& ITEM_CHANGED_TYPE_Name(ITEM_CHANGED_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ITEM_CHANGED_TYPE_descriptor(), value);
}
inline bool ITEM_CHANGED_TYPE_Parse(
    const ::std::string& name, ITEM_CHANGED_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ITEM_CHANGED_TYPE>(
    ITEM_CHANGED_TYPE_descriptor(), name, value);
}
enum DIAMOND_CHANGED_TYPE {
  DIAMOND_CHANGED_TYPE_GMT = 1,
  DIAMOND_CHANGED_TYPE_MALL = 2,
  DIAMOND_CHANGED_TYPE_GENERAL_REWARD = 3,
  DIAMOND_CHANGED_TYPE_OPEN_ROOM = 4
};
bool DIAMOND_CHANGED_TYPE_IsValid(int value);
const DIAMOND_CHANGED_TYPE DIAMOND_CHANGED_TYPE_MIN = DIAMOND_CHANGED_TYPE_GMT;
const DIAMOND_CHANGED_TYPE DIAMOND_CHANGED_TYPE_MAX = DIAMOND_CHANGED_TYPE_OPEN_ROOM;
const int DIAMOND_CHANGED_TYPE_ARRAYSIZE = DIAMOND_CHANGED_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DIAMOND_CHANGED_TYPE_descriptor();
inline const ::std::string& DIAMOND_CHANGED_TYPE_Name(DIAMOND_CHANGED_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DIAMOND_CHANGED_TYPE_descriptor(), value);
}
inline bool DIAMOND_CHANGED_TYPE_Parse(
    const ::std::string& name, DIAMOND_CHANGED_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DIAMOND_CHANGED_TYPE>(
    DIAMOND_CHANGED_TYPE_descriptor(), name, value);
}
enum HUANLEDOU_CHANGED_TYPE {
  HUANLEDOU_CHANGED_TYPE_GMT = 1,
  HUANLEDOU_CHANGED_TYPE_MALL = 2,
  HUANLEDOU_CHANGED_TYPE_GENERAL_REWARD = 3,
  HUANLEDOU_CHANGED_TYPE_ROOM_TICKET = 4,
  HUANLEDOU_CHANGED_TYPE_GAME = 5
};
bool HUANLEDOU_CHANGED_TYPE_IsValid(int value);
const HUANLEDOU_CHANGED_TYPE HUANLEDOU_CHANGED_TYPE_MIN = HUANLEDOU_CHANGED_TYPE_GMT;
const HUANLEDOU_CHANGED_TYPE HUANLEDOU_CHANGED_TYPE_MAX = HUANLEDOU_CHANGED_TYPE_GAME;
const int HUANLEDOU_CHANGED_TYPE_ARRAYSIZE = HUANLEDOU_CHANGED_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HUANLEDOU_CHANGED_TYPE_descriptor();
inline const ::std::string& HUANLEDOU_CHANGED_TYPE_Name(HUANLEDOU_CHANGED_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HUANLEDOU_CHANGED_TYPE_descriptor(), value);
}
inline bool HUANLEDOU_CHANGED_TYPE_Parse(
    const ::std::string& name, HUANLEDOU_CHANGED_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HUANLEDOU_CHANGED_TYPE>(
    HUANLEDOU_CHANGED_TYPE_descriptor(), name, value);
}
enum ROOM_CARD_CHANGED_TYPE {
  ROOM_CARD_CHANGED_TYPE_GMT = 1,
  ROOM_CARD_CHANGED_TYPE_MALL = 2,
  ROOM_CARD_CHANGED_TYPE_OPEN_ROOM = 3,
  ROOM_CARD_CHANGED_TYPE_FANBEI = 4,
  ROOM_CARD_CHANGED_TYPE_GENERAL_REWARD = 5,
  ROOM_CARD_CHANGED_TYPE_CREATE_CLAN = 6,
  ROOM_CARD_CHANGED_TYPE_RECHARGE_CLAN = 7
};
bool ROOM_CARD_CHANGED_TYPE_IsValid(int value);
const ROOM_CARD_CHANGED_TYPE ROOM_CARD_CHANGED_TYPE_MIN = ROOM_CARD_CHANGED_TYPE_GMT;
const ROOM_CARD_CHANGED_TYPE ROOM_CARD_CHANGED_TYPE_MAX = ROOM_CARD_CHANGED_TYPE_RECHARGE_CLAN;
const int ROOM_CARD_CHANGED_TYPE_ARRAYSIZE = ROOM_CARD_CHANGED_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_CARD_CHANGED_TYPE_descriptor();
inline const ::std::string& ROOM_CARD_CHANGED_TYPE_Name(ROOM_CARD_CHANGED_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_CARD_CHANGED_TYPE_descriptor(), value);
}
inline bool ROOM_CARD_CHANGED_TYPE_Parse(
    const ::std::string& name, ROOM_CARD_CHANGED_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_CARD_CHANGED_TYPE>(
    ROOM_CARD_CHANGED_TYPE_descriptor(), name, value);
}
enum SYSTEM_COOLDOWN_TYPE {
  SYSTEM_COOLDOWN_TYPE_MATCHING = 1
};
bool SYSTEM_COOLDOWN_TYPE_IsValid(int value);
const SYSTEM_COOLDOWN_TYPE SYSTEM_COOLDOWN_TYPE_MIN = SYSTEM_COOLDOWN_TYPE_MATCHING;
const SYSTEM_COOLDOWN_TYPE SYSTEM_COOLDOWN_TYPE_MAX = SYSTEM_COOLDOWN_TYPE_MATCHING;
const int SYSTEM_COOLDOWN_TYPE_ARRAYSIZE = SYSTEM_COOLDOWN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SYSTEM_COOLDOWN_TYPE_descriptor();
inline const ::std::string& SYSTEM_COOLDOWN_TYPE_Name(SYSTEM_COOLDOWN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SYSTEM_COOLDOWN_TYPE_descriptor(), value);
}
inline bool SYSTEM_COOLDOWN_TYPE_Parse(
    const ::std::string& name, SYSTEM_COOLDOWN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SYSTEM_COOLDOWN_TYPE>(
    SYSTEM_COOLDOWN_TYPE_descriptor(), name, value);
}
enum POSITION_TYPE {
  POSITION_TYPE_NULL = 0,
  POSITION_TYPE_EAST = 1,
  POSITION_TYPE_SOUTH = 2,
  POSITION_TYPE_WEST = 3,
  POSITION_TYPE_NORTH = 4
};
bool POSITION_TYPE_IsValid(int value);
const POSITION_TYPE POSITION_TYPE_MIN = POSITION_TYPE_NULL;
const POSITION_TYPE POSITION_TYPE_MAX = POSITION_TYPE_NORTH;
const int POSITION_TYPE_ARRAYSIZE = POSITION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* POSITION_TYPE_descriptor();
inline const ::std::string& POSITION_TYPE_Name(POSITION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    POSITION_TYPE_descriptor(), value);
}
inline bool POSITION_TYPE_Parse(
    const ::std::string& name, POSITION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<POSITION_TYPE>(
    POSITION_TYPE_descriptor(), name, value);
}
enum LOAD_SCENE_TYPE {
  LOAD_SCENE_TYPE_NULL = 1,
  LOAD_SCENE_TYPE_START = 2,
  LOAD_SCENE_TYPE_SUCCESS = 3,
  LOAD_SCENE_TYPE_FAILED = 4
};
bool LOAD_SCENE_TYPE_IsValid(int value);
const LOAD_SCENE_TYPE LOAD_SCENE_TYPE_MIN = LOAD_SCENE_TYPE_NULL;
const LOAD_SCENE_TYPE LOAD_SCENE_TYPE_MAX = LOAD_SCENE_TYPE_FAILED;
const int LOAD_SCENE_TYPE_ARRAYSIZE = LOAD_SCENE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOAD_SCENE_TYPE_descriptor();
inline const ::std::string& LOAD_SCENE_TYPE_Name(LOAD_SCENE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOAD_SCENE_TYPE_descriptor(), value);
}
inline bool LOAD_SCENE_TYPE_Parse(
    const ::std::string& name, LOAD_SCENE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOAD_SCENE_TYPE>(
    LOAD_SCENE_TYPE_descriptor(), name, value);
}
enum CLAN_MEM_STATUS_TYPE {
  CLAN_MEM_STATUS_TYPE_GAMING = 1,
  CLAN_MEM_STATUS_TYPE_AVAILABLE = 2,
  CLAN_MEM_STATUS_TYPE_OFFLINE = 3
};
bool CLAN_MEM_STATUS_TYPE_IsValid(int value);
const CLAN_MEM_STATUS_TYPE CLAN_MEM_STATUS_TYPE_MIN = CLAN_MEM_STATUS_TYPE_GAMING;
const CLAN_MEM_STATUS_TYPE CLAN_MEM_STATUS_TYPE_MAX = CLAN_MEM_STATUS_TYPE_OFFLINE;
const int CLAN_MEM_STATUS_TYPE_ARRAYSIZE = CLAN_MEM_STATUS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CLAN_MEM_STATUS_TYPE_descriptor();
inline const ::std::string& CLAN_MEM_STATUS_TYPE_Name(CLAN_MEM_STATUS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CLAN_MEM_STATUS_TYPE_descriptor(), value);
}
inline bool CLAN_MEM_STATUS_TYPE_Parse(
    const ::std::string& name, CLAN_MEM_STATUS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CLAN_MEM_STATUS_TYPE>(
    CLAN_MEM_STATUS_TYPE_descriptor(), name, value);
}
enum ERROR_TYPE {
  ERROR_TYPE_NORMAL = 1,
  ERROR_TYPE_INVENTORY_FULL = 2
};
bool ERROR_TYPE_IsValid(int value);
const ERROR_TYPE ERROR_TYPE_MIN = ERROR_TYPE_NORMAL;
const ERROR_TYPE ERROR_TYPE_MAX = ERROR_TYPE_INVENTORY_FULL;
const int ERROR_TYPE_ARRAYSIZE = ERROR_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_TYPE_descriptor();
inline const ::std::string& ERROR_TYPE_Name(ERROR_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_TYPE_descriptor(), value);
}
inline bool ERROR_TYPE_Parse(
    const ::std::string& name, ERROR_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_TYPE>(
    ERROR_TYPE_descriptor(), name, value);
}
enum ERROR_SHOW_TYPE {
  ERROR_SHOW_TYPE_NORMAL = 1,
  ERROR_SHOW_TYPE_MESSAGE_BOX = 2
};
bool ERROR_SHOW_TYPE_IsValid(int value);
const ERROR_SHOW_TYPE ERROR_SHOW_TYPE_MIN = ERROR_SHOW_TYPE_NORMAL;
const ERROR_SHOW_TYPE ERROR_SHOW_TYPE_MAX = ERROR_SHOW_TYPE_MESSAGE_BOX;
const int ERROR_SHOW_TYPE_ARRAYSIZE = ERROR_SHOW_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_SHOW_TYPE_descriptor();
inline const ::std::string& ERROR_SHOW_TYPE_Name(ERROR_SHOW_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_SHOW_TYPE_descriptor(), value);
}
inline bool ERROR_SHOW_TYPE_Parse(
    const ::std::string& name, ERROR_SHOW_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_SHOW_TYPE>(
    ERROR_SHOW_TYPE_descriptor(), name, value);
}
enum ERROR_CODE {
  ERROR_SUCCESS = 0,
  ERROR_INNER = 1,
  ERROR_DIAMOND_NOT_ENOUGH = 2,
  ERROR_HUANLEDOU_NOT_ENOUGH = 3,
  ERROR_INVENTORY_FULL = 4,
  ERROR_REWARD_HAS_GOT = 5,
  ERROR_HUANLEDOU_LIMIT = 6,
  ERROR_MALL_NOT_FOUND = 7,
  ERROR_ACTIVITY_NOT_OPEN = 8,
  ERROR_CLIENT_DATA = 9,
  ERROR_HAS_NO_PLAYER = 10,
  ERROR_DATABASE = 11,
  ERROR_ROOM_CARD_NOT_ENOUGH = 12,
  ERROR_VERSION_LIMIT = 13,
  ERROR_ONLINE_PLAYERS_LIMIT = 14,
  ERROR_LONGTIME_NO_OPERATION = 15,
  ERROR_ROOM_NOT_FOUNT = 20,
  ERROR_ROOM_PASSWORD = 21,
  ERROR_ROOM_IS_FULL = 22,
  ERROR_ROOM_NOT_AVAILABLE = 23,
  ERROR_ROOM_NO_PERMISSION = 24,
  ERROR_ROOM_BEANS_MIN_LIMIT = 25,
  ERROR_ROOM_BEANS_MAX_LIMIT = 26,
  ERROR_ROOM_TYPE_NOT_FOUND = 27,
  ERROR_ROOM_HAS_BEEN_IN = 28,
  ERROR_ROOM_GUEST_FORBID_ENTER = 29,
  ERROR_ROOM_CARD_GAMES_FULL = 30,
  ERROR_ROOM_DISMISS_COOLDOWN = 31,
  ERROR_ROOM_BEEN_OVER = 32,
  ERROR_ROOM_BEEN_DISMISS = 33,
  ERROR_ROOM_PLAYBACK_NO_RECORD = 34,
  ERROR_ROOM_AA_DIAMOND_NOT_ENOUGH = 35,
  ERROR_ROOM_FRIEND_NOT_FORBID = 36,
  ERROR_ROOM_QUERY_NOT_FORBID = 37,
  ERROR_GAME_NO_PERMISSION = 40,
  ERROR_GAME_PAI_UNSATISFIED = 41,
  ERROR_COMMON_REWARD_DATA = 50,
  ERROR_COMMON_REWARD_HAS_GOT = 51,
  ERROR_COOLDOWN_MATCHING = 60,
  ERROR_CLAN_NAME_EMPTY = 71,
  ERROR_CLAN_NAME_UPPER = 72,
  ERROR_CLAN_HOSTER_UPPER = 73,
  ERROR_CLAN_JOIN_UPPER = 74,
  ERROR_CLAN_CREATE_INNER = 75,
  ERROR_CLAN_FULL = 76,
  ERROR_CLAN_ROOM_CARD_NOT_ENOUGH = 77,
  ERROR_CLAN_NOT_FOUND = 78,
  ERROR_CLAN_NO_PERMISSION = 79,
  ERROR_CLAN_NO_RECORD = 80,
  ERROR_CLAN_HAS_JOINED = 81
};
bool ERROR_CODE_IsValid(int value);
const ERROR_CODE ERROR_CODE_MIN = ERROR_SUCCESS;
const ERROR_CODE ERROR_CODE_MAX = ERROR_CLAN_HAS_JOINED;
const int ERROR_CODE_ARRAYSIZE = ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_CODE_descriptor();
inline const ::std::string& ERROR_CODE_Name(ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_CODE_descriptor(), value);
}
inline bool ERROR_CODE_Parse(
    const ::std::string& name, ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_CODE>(
    ERROR_CODE_descriptor(), name, value);
}
enum META_TYPE {
  META_TYPE_SHARE_BEGIN = 1,
  META_TYPE_SHARE_CREATE_PLAYER = 2,
  META_TYPE_SHARE_CREATE_ROOM = 3,
  META_TYPE_SHARE_PAI_OPERATION = 4,
  META_TYPE_SHARE_GAME_OPERATION = 5,
  META_TYPE_SHARE_COMMON_PROPERTY = 6,
  META_TYPE_SHARE_BUY_SOMETHING = 7,
  META_TYPE_SHARE_ENTER_ROOM = 8,
  META_TYPE_SHARE_SIGN = 9,
  META_TYPE_SHARE_LUCKY_PLATE = 10,
  META_TYPE_SHARE_RANDOM_SAIZI = 11,
  META_TYPE_SHARE_SAY_HI = 12,
  META_TYPE_SHARE_GUEST_LOGIN = 13,
  META_TYPE_SHARE_GAME_SETTING = 14,
  META_TYPE_SHARE_UPDATE_CLIENT_DATA = 15,
  META_TYPE_SHARE_SYSTEM_CHAT = 16,
  META_TYPE_SHARE_ROOM_HISTORY = 17,
  META_TYPE_SHARE_RECHARGE = 18,
  META_TYPE_SHARE_PLAY_BACK = 19,
  META_TYPE_SHARE_MATCHING_STATS = 20,
  META_TYPE_SHARE_CLAN_OPERATION = 21,
  META_TYPE_SHARE_COUNT = 50,
  META_TYPE_C2S_BEGIN = 51,
  META_TYPE_C2S_LOGIN = 52,
  META_TYPE_C2S_LOGOUT = 53,
  META_TYPE_C2S_SELECT_SERVER = 54,
  META_TYPE_C2S_ENTER_GAME = 55,
  META_TYPE_C2S_GET_REWARD = 56,
  META_TYPE_C2S_LOAD_SCENE = 57,
  META_TYPE_C2S_RECONNECT = 58,
  META_TYPE_C2S_WECHAT_LOGIN = 59,
  META_TYPE_C2S_SWITCH_ACCOUNT = 60,
  META_TYPE_C2S_GET_ROOM_DATA = 61,
  META_TYPE_C2S_UPDATE_ROOM = 62,
  META_TYPE_C2S_COUNT = 255,
  META_TYPE_S2C_BEGIN = 501,
  META_TYPE_S2C_TICKET = 502,
  META_TYPE_S2C_SERVER_LIST = 503,
  META_TYPE_S2C_PLAYERS = 504,
  META_TYPE_S2C_PLAYER_INFO = 505,
  META_TYPE_S2C_ALERT_ERROR = 507,
  META_TYPE_S2C_LIUJU = 508,
  META_TYPE_S2C_PAI_NOTIFY = 509,
  META_TYPE_S2C_PAI_OPERATION_ALERT = 510,
  META_TYPE_S2C_COMMON_LIMIT = 511,
  META_TYPE_S2C_COMMON_REWARD = 512,
  META_TYPE_S2C_ROOM_INFO = 513,
  META_TYPE_S2C_GAME_CALCULATE = 514,
  META_TYPE_S2C_GAME_INFO = 515,
  META_TYPE_S2C_KILL_OUT = 516,
  META_TYPE_S2C_ACTIVITY = 517,
  META_TYPE_S2C_SYSTEM_BROADCAST = 518,
  META_TYPE_S2C_PAI_PUSH_DOWN = 519,
  META_TYPE_S2C_GAMES_FULL = 520,
  META_TYPE_S2C_WECHAT_INFOMATION = 521,
  META_TYPE_S2C_GAME_START = 522,
  META_TYPE_S2C_ROOM_CALCULATE = 523,
  META_TYPE_S2C_ROOM_DISMISS = 524,
  META_TYPE_S2C_ROOM_STATE = 525,
  META_TYPE_S2C_ROOM_HISTORY = 526,
  META_TYPE_S2C_ROOM_ALL = 527,
  META_TYPE_S2C_ROOM_IN = 528,
  META_TYPE_S2C_ROOM_QUERY = 529,
  META_TYPE_S2C_COUNT = 1000,
  META_TYPE_S2S_REGISTER = 1001,
  META_TYPE_S2S_KICKOUT_PLAYER = 1002,
  META_TYPE_S2S_GMT_INNER_META = 1003,
  META_TYPE_S2S_PLAYER_STATE = 1004,
  META_TYPE_S2S_CLAN_ROOM_START_OR_OVER = 1005,
  META_TYPE_S2S_CLAN_ROOM_SYNC = 1006
};
bool META_TYPE_IsValid(int value);
const META_TYPE META_TYPE_MIN = META_TYPE_SHARE_BEGIN;
const META_TYPE META_TYPE_MAX = META_TYPE_S2S_CLAN_ROOM_SYNC;
const int META_TYPE_ARRAYSIZE = META_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* META_TYPE_descriptor();
inline const ::std::string& META_TYPE_Name(META_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    META_TYPE_descriptor(), value);
}
inline bool META_TYPE_Parse(
    const ::std::string& name, META_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<META_TYPE>(
    META_TYPE_descriptor(), name, value);
}
enum ACCOUNT_TYPE {
  ACCOUNT_TYPE_8HERE = 1,
  ACCOUNT_TYPE_GUEST = 2,
  ACCOUNT_TYPE_WECHAT = 3,
  ACCOUNT_TYPE_QQ = 4
};
bool ACCOUNT_TYPE_IsValid(int value);
const ACCOUNT_TYPE ACCOUNT_TYPE_MIN = ACCOUNT_TYPE_8HERE;
const ACCOUNT_TYPE ACCOUNT_TYPE_MAX = ACCOUNT_TYPE_QQ;
const int ACCOUNT_TYPE_ARRAYSIZE = ACCOUNT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCOUNT_TYPE_descriptor();
inline const ::std::string& ACCOUNT_TYPE_Name(ACCOUNT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCOUNT_TYPE_descriptor(), value);
}
inline bool ACCOUNT_TYPE_Parse(
    const ::std::string& name, ACCOUNT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCOUNT_TYPE>(
    ACCOUNT_TYPE_descriptor(), name, value);
}
enum RECHARGE_TYPE {
  RECHARGE_TYPE_IOS = 1,
  RECHARGE_TYPE_ANDROID = 2
};
bool RECHARGE_TYPE_IsValid(int value);
const RECHARGE_TYPE RECHARGE_TYPE_MIN = RECHARGE_TYPE_IOS;
const RECHARGE_TYPE RECHARGE_TYPE_MAX = RECHARGE_TYPE_ANDROID;
const int RECHARGE_TYPE_ARRAYSIZE = RECHARGE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RECHARGE_TYPE_descriptor();
inline const ::std::string& RECHARGE_TYPE_Name(RECHARGE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RECHARGE_TYPE_descriptor(), value);
}
inline bool RECHARGE_TYPE_Parse(
    const ::std::string& name, RECHARGE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RECHARGE_TYPE>(
    RECHARGE_TYPE_descriptor(), name, value);
}
enum CHAT_TYPE {
  CHAT_TYPE_TEXT = 1,
  CHAT_TYPE_FACE = 2
};
bool CHAT_TYPE_IsValid(int value);
const CHAT_TYPE CHAT_TYPE_MIN = CHAT_TYPE_TEXT;
const CHAT_TYPE CHAT_TYPE_MAX = CHAT_TYPE_FACE;
const int CHAT_TYPE_ARRAYSIZE = CHAT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CHAT_TYPE_descriptor();
inline const ::std::string& CHAT_TYPE_Name(CHAT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CHAT_TYPE_descriptor(), value);
}
inline bool CHAT_TYPE_Parse(
    const ::std::string& name, CHAT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CHAT_TYPE>(
    CHAT_TYPE_descriptor(), name, value);
}
enum ZHUOBU_TYPE {
  ZHUOBU_TYPE_GREEN = 1,
  ZHUOBU_TYPE_BLUE = 2,
  ZHUOBU_TYPE_RED = 3
};
bool ZHUOBU_TYPE_IsValid(int value);
const ZHUOBU_TYPE ZHUOBU_TYPE_MIN = ZHUOBU_TYPE_GREEN;
const ZHUOBU_TYPE ZHUOBU_TYPE_MAX = ZHUOBU_TYPE_RED;
const int ZHUOBU_TYPE_ARRAYSIZE = ZHUOBU_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZHUOBU_TYPE_descriptor();
inline const ::std::string& ZHUOBU_TYPE_Name(ZHUOBU_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZHUOBU_TYPE_descriptor(), value);
}
inline bool ZHUOBU_TYPE_Parse(
    const ::std::string& name, ZHUOBU_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZHUOBU_TYPE>(
    ZHUOBU_TYPE_descriptor(), name, value);
}
enum CARD_COLOR_TYPE {
  CARD_COLOR_TYPE_GREEN = 1,
  CARD_COLOR_TYPE_BLUE = 2,
  CARD_COLOR_TYPE_GOLDEN = 3
};
bool CARD_COLOR_TYPE_IsValid(int value);
const CARD_COLOR_TYPE CARD_COLOR_TYPE_MIN = CARD_COLOR_TYPE_GREEN;
const CARD_COLOR_TYPE CARD_COLOR_TYPE_MAX = CARD_COLOR_TYPE_GOLDEN;
const int CARD_COLOR_TYPE_ARRAYSIZE = CARD_COLOR_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CARD_COLOR_TYPE_descriptor();
inline const ::std::string& CARD_COLOR_TYPE_Name(CARD_COLOR_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CARD_COLOR_TYPE_descriptor(), value);
}
inline bool CARD_COLOR_TYPE_Parse(
    const ::std::string& name, CARD_COLOR_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CARD_COLOR_TYPE>(
    CARD_COLOR_TYPE_descriptor(), name, value);
}
enum PAI_OPER_TYPE {
  PAI_OPER_TYPE_BEGIN = 0,
  PAI_OPER_TYPE_DAPAI = 1,
  PAI_OPER_TYPE_HUPAI = 2,
  PAI_OPER_TYPE_QIANGGANG = 3,
  PAI_OPER_TYPE_GANGPAI = 4,
  PAI_OPER_TYPE_PENGPAI = 5,
  PAI_OPER_TYPE_CHIPAI = 6,
  PAI_OPER_TYPE_GIVEUP = 7,
  PAI_OPER_TYPE_XUANFENG_FENG = 8,
  PAI_OPER_TYPE_XUANFENG_JIAN = 9,
  PAI_OPER_TYPE_ANGANGPAI = 10,
  PAI_OPER_TYPE_TINGPAI = 11,
  PAI_OPER_TYPE_BAOPAI = 12,
  PAI_OPER_TYPE_FAPAI = 13,
  PAI_OPER_TYPE_LIUJU = 14,
  PAI_OPER_TYPE_CANCEL = 15,
  PAI_OPER_TYPE_HUIPAI = 16,
  PAI_OPER_TYPE_COUNT = 17
};
bool PAI_OPER_TYPE_IsValid(int value);
const PAI_OPER_TYPE PAI_OPER_TYPE_MIN = PAI_OPER_TYPE_BEGIN;
const PAI_OPER_TYPE PAI_OPER_TYPE_MAX = PAI_OPER_TYPE_COUNT;
const int PAI_OPER_TYPE_ARRAYSIZE = PAI_OPER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PAI_OPER_TYPE_descriptor();
inline const ::std::string& PAI_OPER_TYPE_Name(PAI_OPER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PAI_OPER_TYPE_descriptor(), value);
}
inline bool PAI_OPER_TYPE_Parse(
    const ::std::string& name, PAI_OPER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PAI_OPER_TYPE>(
    PAI_OPER_TYPE_descriptor(), name, value);
}
enum GAME_OPER_TYPE {
  GAME_OPER_TYPE_NULL = 1,
  GAME_OPER_TYPE_START = 2,
  GAME_OPER_TYPE_LEAVE = 3,
  GAME_OPER_TYPE_KICKOUT = 4,
  GAME_OPER_TYPE_DISMISS_AGREE = 5,
  GAME_OPER_TYPE_DISMISS_DISAGREE = 6,
  GAME_OPER_TYPE_HOSTER_DISMISS = 7,
  GAME_OPER_TYPE_OFFLINE = 8,
  GAME_OPER_TYPE_ONLINE = 9,
  GAME_OPER_TYPE_JIAOZHUANG = 10
};
bool GAME_OPER_TYPE_IsValid(int value);
const GAME_OPER_TYPE GAME_OPER_TYPE_MIN = GAME_OPER_TYPE_NULL;
const GAME_OPER_TYPE GAME_OPER_TYPE_MAX = GAME_OPER_TYPE_JIAOZHUANG;
const int GAME_OPER_TYPE_ARRAYSIZE = GAME_OPER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GAME_OPER_TYPE_descriptor();
inline const ::std::string& GAME_OPER_TYPE_Name(GAME_OPER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GAME_OPER_TYPE_descriptor(), value);
}
inline bool GAME_OPER_TYPE_Parse(
    const ::std::string& name, GAME_OPER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GAME_OPER_TYPE>(
    GAME_OPER_TYPE_descriptor(), name, value);
}
enum CLAN_OPER_TYPE {
  CLAN_OPER_TYPE_CREATE = 1,
  CLAN_OPER_TYPE_JOIN = 2,
  CLAN_OPER_TYPE_EDIT = 3,
  CLAN_OPER_TYPE_DISMISS = 4,
  CLAN_OPER_TYPE_RECHARGE = 5,
  CLAN_OPER_TYPE_MEMEBER_AGEE = 6,
  CLAN_OPER_TYPE_MEMEBER_DISAGEE = 7,
  CLAN_OPER_TYPE_MEMEBER_DELETE = 8,
  CLAN_OPER_TYPE_MEMEBER_QUIT = 9,
  CLAN_OPER_TYPE_MEMEBER_QUERY = 10,
  CLAN_OPER_TYPE_ROOM_LIST_QUERY = 11
};
bool CLAN_OPER_TYPE_IsValid(int value);
const CLAN_OPER_TYPE CLAN_OPER_TYPE_MIN = CLAN_OPER_TYPE_CREATE;
const CLAN_OPER_TYPE CLAN_OPER_TYPE_MAX = CLAN_OPER_TYPE_ROOM_LIST_QUERY;
const int CLAN_OPER_TYPE_ARRAYSIZE = CLAN_OPER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CLAN_OPER_TYPE_descriptor();
inline const ::std::string& CLAN_OPER_TYPE_Name(CLAN_OPER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CLAN_OPER_TYPE_descriptor(), value);
}
inline bool CLAN_OPER_TYPE_Parse(
    const ::std::string& name, CLAN_OPER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CLAN_OPER_TYPE>(
    CLAN_OPER_TYPE_descriptor(), name, value);
}
enum ROOM_SYNC_TYPE {
  ROOM_SYNC_TYPE_NORMAL = 1,
  ROOM_SYNC_TYPE_STATE_CHANGED = 2,
  ROOM_SYNC_TYPE_QUERY = 3
};
bool ROOM_SYNC_TYPE_IsValid(int value);
const ROOM_SYNC_TYPE ROOM_SYNC_TYPE_MIN = ROOM_SYNC_TYPE_NORMAL;
const ROOM_SYNC_TYPE ROOM_SYNC_TYPE_MAX = ROOM_SYNC_TYPE_QUERY;
const int ROOM_SYNC_TYPE_ARRAYSIZE = ROOM_SYNC_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_SYNC_TYPE_descriptor();
inline const ::std::string& ROOM_SYNC_TYPE_Name(ROOM_SYNC_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_SYNC_TYPE_descriptor(), value);
}
inline bool ROOM_SYNC_TYPE_Parse(
    const ::std::string& name, ROOM_SYNC_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_SYNC_TYPE>(
    ROOM_SYNC_TYPE_descriptor(), name, value);
}
enum CALCULATE_TYPE {
  CALCULATE_TYPE_HUPAI = 1,
  CALCULATE_TYPE_LIUJU = 2,
  CALCULATE_TYPE_FULL = 3,
  CALCULATE_TYPE_DISMISS = 4
};
bool CALCULATE_TYPE_IsValid(int value);
const CALCULATE_TYPE CALCULATE_TYPE_MIN = CALCULATE_TYPE_HUPAI;
const CALCULATE_TYPE CALCULATE_TYPE_MAX = CALCULATE_TYPE_DISMISS;
const int CALCULATE_TYPE_ARRAYSIZE = CALCULATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CALCULATE_TYPE_descriptor();
inline const ::std::string& CALCULATE_TYPE_Name(CALCULATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CALCULATE_TYPE_descriptor(), value);
}
inline bool CALCULATE_TYPE_Parse(
    const ::std::string& name, CALCULATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CALCULATE_TYPE>(
    CALCULATE_TYPE_descriptor(), name, value);
}
enum KICK_OUT_REASON {
  KICK_OUT_REASON_BEGIN = 0,
  KICK_OUT_REASON_DISCONNECT = 1,
  KICK_OUT_REASON_OTHER_LOGIN = 2,
  KICK_OUT_REASON_CHANGE_SERVER = 3,
  KICK_OUT_REASON_LOGOUT = 4
};
bool KICK_OUT_REASON_IsValid(int value);
const KICK_OUT_REASON KICK_OUT_REASON_MIN = KICK_OUT_REASON_BEGIN;
const KICK_OUT_REASON KICK_OUT_REASON_MAX = KICK_OUT_REASON_LOGOUT;
const int KICK_OUT_REASON_ARRAYSIZE = KICK_OUT_REASON_MAX + 1;

const ::google::protobuf::EnumDescriptor* KICK_OUT_REASON_descriptor();
inline const ::std::string& KICK_OUT_REASON_Name(KICK_OUT_REASON value) {
  return ::google::protobuf::internal::NameOfEnum(
    KICK_OUT_REASON_descriptor(), value);
}
inline bool KICK_OUT_REASON_Parse(
    const ::std::string& name, KICK_OUT_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KICK_OUT_REASON>(
    KICK_OUT_REASON_descriptor(), name, value);
}
enum SYSTEM_BROADCAST_TYPE {
  SYSTEM_BROADCAST_TYPE_SCROLL = 1,
  SYSTEM_BROADCAST_TYPE_CHAT = 2
};
bool SYSTEM_BROADCAST_TYPE_IsValid(int value);
const SYSTEM_BROADCAST_TYPE SYSTEM_BROADCAST_TYPE_MIN = SYSTEM_BROADCAST_TYPE_SCROLL;
const SYSTEM_BROADCAST_TYPE SYSTEM_BROADCAST_TYPE_MAX = SYSTEM_BROADCAST_TYPE_CHAT;
const int SYSTEM_BROADCAST_TYPE_ARRAYSIZE = SYSTEM_BROADCAST_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SYSTEM_BROADCAST_TYPE_descriptor();
inline const ::std::string& SYSTEM_BROADCAST_TYPE_Name(SYSTEM_BROADCAST_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SYSTEM_BROADCAST_TYPE_descriptor(), value);
}
inline bool SYSTEM_BROADCAST_TYPE_Parse(
    const ::std::string& name, SYSTEM_BROADCAST_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SYSTEM_BROADCAST_TYPE>(
    SYSTEM_BROADCAST_TYPE_descriptor(), name, value);
}
enum ROLE_TYPE {
  ROLE_TYPE_NULL = 0,
  ROLE_TYPE_PLAYER = 1,
  ROLE_TYPE_GAME_SERVER = 2
};
bool ROLE_TYPE_IsValid(int value);
const ROLE_TYPE ROLE_TYPE_MIN = ROLE_TYPE_NULL;
const ROLE_TYPE ROLE_TYPE_MAX = ROLE_TYPE_GAME_SERVER;
const int ROLE_TYPE_ARRAYSIZE = ROLE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROLE_TYPE_descriptor();
inline const ::std::string& ROLE_TYPE_Name(ROLE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROLE_TYPE_descriptor(), value);
}
inline bool ROLE_TYPE_Parse(
    const ::std::string& name, ROLE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROLE_TYPE>(
    ROLE_TYPE_descriptor(), name, value);
}
enum CLAN_ROOM_STATUS_TYPE {
  CLAN_ROOM_STATUS_TYPE_START = 1,
  CLAN_ROOM_STATUS_TYPE_OVER = 2
};
bool CLAN_ROOM_STATUS_TYPE_IsValid(int value);
const CLAN_ROOM_STATUS_TYPE CLAN_ROOM_STATUS_TYPE_MIN = CLAN_ROOM_STATUS_TYPE_START;
const CLAN_ROOM_STATUS_TYPE CLAN_ROOM_STATUS_TYPE_MAX = CLAN_ROOM_STATUS_TYPE_OVER;
const int CLAN_ROOM_STATUS_TYPE_ARRAYSIZE = CLAN_ROOM_STATUS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CLAN_ROOM_STATUS_TYPE_descriptor();
inline const ::std::string& CLAN_ROOM_STATUS_TYPE_Name(CLAN_ROOM_STATUS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CLAN_ROOM_STATUS_TYPE_descriptor(), value);
}
inline bool CLAN_ROOM_STATUS_TYPE_Parse(
    const ::std::string& name, CLAN_ROOM_STATUS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CLAN_ROOM_STATUS_TYPE>(
    CLAN_ROOM_STATUS_TYPE_descriptor(), name, value);
}
// ===================================================================

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .Adoter.Asset.ACCOUNT_TYPE account_type = 3;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 3;
  inline ::Adoter::Asset::ACCOUNT_TYPE account_type() const;
  inline void set_account_type(::Adoter::Asset::ACCOUNT_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Account)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_account_type();
  inline void clear_has_account_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* username_;
  ::std::string* password_;
  int account_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class PaiElement : public ::google::protobuf::Message {
 public:
  PaiElement();
  virtual ~PaiElement();

  PaiElement(const PaiElement& from);

  inline PaiElement& operator=(const PaiElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiElement& default_instance();

  void Swap(PaiElement* other);

  // implements Message ----------------------------------------------

  PaiElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiElement& from);
  void MergeFrom(const PaiElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // optional int32 card_value = 2;
  inline bool has_card_value() const;
  inline void clear_card_value();
  static const int kCardValueFieldNumber = 2;
  inline ::google::protobuf::int32 card_value() const;
  inline void set_card_value(::google::protobuf::int32 value);

  // optional int32 card_index = 3;
  inline bool has_card_index() const;
  inline void clear_card_index();
  static const int kCardIndexFieldNumber = 3;
  inline ::google::protobuf::int32 card_index() const;
  inline void set_card_index(::google::protobuf::int32 value);

  // optional int64 source_player_id = 4;
  inline bool has_source_player_id() const;
  inline void clear_source_player_id();
  static const int kSourcePlayerIdFieldNumber = 4;
  inline ::google::protobuf::int64 source_player_id() const;
  inline void set_source_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiElement)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_card_value();
  inline void clear_has_card_value();
  inline void set_has_card_index();
  inline void clear_has_card_index();
  inline void set_has_source_player_id();
  inline void clear_has_source_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int card_type_;
  ::google::protobuf::int32 card_value_;
  ::google::protobuf::int64 source_player_id_;
  ::google::protobuf::int32 card_index_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiElement* default_instance_;
};
// -------------------------------------------------------------------

class ShunZi : public ::google::protobuf::Message {
 public:
  ShunZi();
  virtual ~ShunZi();

  ShunZi(const ShunZi& from);

  inline ShunZi& operator=(const ShunZi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShunZi& default_instance();

  void Swap(ShunZi* other);

  // implements Message ----------------------------------------------

  ShunZi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShunZi& from);
  void MergeFrom(const ShunZi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.PaiElement pai = 1;
  inline int pai_size() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 1;
  inline const ::Adoter::Asset::PaiElement& pai(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pai(int index);
  inline ::Adoter::Asset::PaiElement* add_pai();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pai() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pai();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ShunZi)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pai_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ShunZi* default_instance_;
};
// -------------------------------------------------------------------

class ItemElement : public ::google::protobuf::Message {
 public:
  ItemElement();
  virtual ~ItemElement();

  ItemElement(const ItemElement& from);

  inline ItemElement& operator=(const ItemElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemElement& default_instance();

  void Swap(ItemElement* other);

  // implements Message ----------------------------------------------

  ItemElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemElement& from);
  void MergeFrom(const ItemElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
  inline bool has_inventory_type() const;
  inline void clear_inventory_type();
  static const int kInventoryTypeFieldNumber = 1;
  inline ::Adoter::Asset::INVENTORY_TYPE inventory_type() const;
  inline void set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value);

  // optional int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 global_id = 3;
  inline bool has_global_id() const;
  inline void clear_global_id();
  static const int kGlobalIdFieldNumber = 3;
  inline ::google::protobuf::int32 global_id() const;
  inline void set_global_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ItemElement)
 private:
  inline void set_has_inventory_type();
  inline void clear_has_inventory_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_global_id();
  inline void clear_has_global_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int inventory_type_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 global_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ItemElement* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.Account account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::Adoter::Asset::Account& account() const;
  inline ::Adoter::Asset::Account* mutable_account();
  inline ::Adoter::Asset::Account* release_account();
  inline void set_allocated_account(::Adoter::Asset::Account* account);

  // repeated int64 player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline ::google::protobuf::int64 player_list(int index) const;
  inline void set_player_list(int index, ::google::protobuf::int64 value);
  inline void add_player_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      player_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_player_list();

  // optional .Adoter.Asset.WechatUnion wechat = 3;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 3;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // optional .Adoter.Asset.ClientInfomation client_info = 4;
  inline bool has_client_info() const;
  inline void clear_client_info();
  static const int kClientInfoFieldNumber = 4;
  inline const ::Adoter::Asset::ClientInfomation& client_info() const;
  inline ::Adoter::Asset::ClientInfomation* mutable_client_info();
  inline ::Adoter::Asset::ClientInfomation* release_client_info();
  inline void set_allocated_client_info(::Adoter::Asset::ClientInfomation* client_info);

  // optional int32 created_time = 5;
  inline bool has_created_time() const;
  inline void clear_created_time();
  static const int kCreatedTimeFieldNumber = 5;
  inline ::google::protobuf::int32 created_time() const;
  inline void set_created_time(::google::protobuf::int32 value);

  // optional bytes daili_acount = 6;
  inline bool has_daili_acount() const;
  inline void clear_daili_acount();
  static const int kDailiAcountFieldNumber = 6;
  inline const ::std::string& daili_acount() const;
  inline void set_daili_acount(const ::std::string& value);
  inline void set_daili_acount(const char* value);
  inline void set_daili_acount(const void* value, size_t size);
  inline ::std::string* mutable_daili_acount();
  inline ::std::string* release_daili_acount();
  inline void set_allocated_daili_acount(::std::string* daili_acount);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.User)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_wechat();
  inline void clear_has_wechat();
  inline void set_has_client_info();
  inline void clear_has_client_info();
  inline void set_has_created_time();
  inline void clear_has_created_time();
  inline void set_has_daili_acount();
  inline void clear_has_daili_acount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Account* account_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > player_list_;
  ::Adoter::Asset::WechatUnion* wechat_;
  ::Adoter::Asset::ClientInfomation* client_info_;
  ::std::string* daili_acount_;
  ::google::protobuf::int32 created_time_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProp : public ::google::protobuf::Message {
 public:
  PlayerProp();
  virtual ~PlayerProp();

  PlayerProp(const PlayerProp& from);

  inline PlayerProp& operator=(const PlayerProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProp& default_instance();

  void Swap(PlayerProp* other);

  // implements Message ----------------------------------------------

  PlayerProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProp& from);
  void MergeFrom(const PlayerProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.POSITION_TYPE position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 3;
  inline bool has_load_type() const;
  inline void clear_load_type();
  static const int kLoadTypeFieldNumber = 3;
  inline ::Adoter::Asset::LOAD_SCENE_TYPE load_type() const;
  inline void set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE game_oper_state = 4;
  inline bool has_game_oper_state() const;
  inline void clear_game_oper_state();
  static const int kGameOperStateFieldNumber = 4;
  inline ::Adoter::Asset::GAME_OPER_TYPE game_oper_state() const;
  inline void set_game_oper_state(::Adoter::Asset::GAME_OPER_TYPE value);

  // optional int32 pai_oper_count = 5;
  inline bool has_pai_oper_count() const;
  inline void clear_pai_oper_count();
  static const int kPaiOperCountFieldNumber = 5;
  inline ::google::protobuf::int32 pai_oper_count() const;
  inline void set_pai_oper_count(::google::protobuf::int32 value);

  // optional bool has_tinged = 6;
  inline bool has_has_tinged() const;
  inline void clear_has_tinged();
  static const int kHasTingedFieldNumber = 6;
  inline bool has_tinged() const;
  inline void set_has_tinged(bool value);

  // optional bool offline = 7;
  inline bool has_offline() const;
  inline void clear_offline();
  static const int kOfflineFieldNumber = 7;
  inline bool offline() const;
  inline void set_offline(bool value);

  // optional int64 voice_member_id = 8;
  inline bool has_voice_member_id() const;
  inline void clear_voice_member_id();
  static const int kVoiceMemberIdFieldNumber = 8;
  inline ::google::protobuf::int64 voice_member_id() const;
  inline void set_voice_member_id(::google::protobuf::int64 value);

  // optional int32 beilv = 9;
  inline bool has_beilv() const;
  inline void clear_beilv();
  static const int kBeilvFieldNumber = 9;
  inline ::google::protobuf::int32 beilv() const;
  inline void set_beilv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerProp)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_load_type();
  inline void clear_has_load_type();
  inline void set_has_game_oper_state();
  inline void clear_has_game_oper_state();
  inline void set_has_pai_oper_count();
  inline void clear_has_pai_oper_count();
  inline void set_has_has_tinged();
  inline void clear_has_has_tinged();
  inline void set_has_offline();
  inline void clear_has_offline();
  inline void set_has_voice_member_id();
  inline void clear_has_voice_member_id();
  inline void set_has_beilv();
  inline void clear_has_beilv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int position_;
  int load_type_;
  int game_oper_state_;
  ::google::protobuf::int32 pai_oper_count_;
  bool has_tinged_;
  bool offline_;
  ::google::protobuf::int32 beilv_;
  ::google::protobuf::int64 voice_member_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerProp* default_instance_;
};
// -------------------------------------------------------------------

class PlayerBrief : public ::google::protobuf::Message {
 public:
  PlayerBrief();
  virtual ~PlayerBrief();

  PlayerBrief(const PlayerBrief& from);

  inline PlayerBrief& operator=(const PlayerBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerBrief& default_instance();

  void Swap(PlayerBrief* other);

  // implements Message ----------------------------------------------

  PlayerBrief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerBrief& from);
  void MergeFrom(const PlayerBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const void* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional bytes headimgurl = 3;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 3;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const void* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerBrief)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* nickname_;
  ::std::string* headimgurl_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerBrief* default_instance_;
};
// -------------------------------------------------------------------

class GameRecord_GameElement_DetailElement : public ::google::protobuf::Message {
 public:
  GameRecord_GameElement_DetailElement();
  virtual ~GameRecord_GameElement_DetailElement();

  GameRecord_GameElement_DetailElement(const GameRecord_GameElement_DetailElement& from);

  inline GameRecord_GameElement_DetailElement& operator=(const GameRecord_GameElement_DetailElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameRecord_GameElement_DetailElement& default_instance();

  void Swap(GameRecord_GameElement_DetailElement* other);

  // implements Message ----------------------------------------------

  GameRecord_GameElement_DetailElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameRecord_GameElement_DetailElement& from);
  void MergeFrom(const GameRecord_GameElement_DetailElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 fan_type = 2;
  inline bool has_fan_type() const;
  inline void clear_fan_type();
  static const int kFanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 fan_type() const;
  inline void set_fan_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameRecord.GameElement.DetailElement)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_fan_type();
  inline void clear_has_fan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 fan_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameRecord_GameElement_DetailElement* default_instance_;
};
// -------------------------------------------------------------------

class GameRecord_GameElement : public ::google::protobuf::Message {
 public:
  GameRecord_GameElement();
  virtual ~GameRecord_GameElement();

  GameRecord_GameElement(const GameRecord_GameElement& from);

  inline GameRecord_GameElement& operator=(const GameRecord_GameElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameRecord_GameElement& default_instance();

  void Swap(GameRecord_GameElement* other);

  // implements Message ----------------------------------------------

  GameRecord_GameElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameRecord_GameElement& from);
  void MergeFrom(const GameRecord_GameElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameRecord_GameElement_DetailElement DetailElement;

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const void* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional bytes headimgurl = 3;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 3;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const void* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // optional int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.GameRecord.GameElement.DetailElement details = 5;
  inline int details_size() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 5;
  inline const ::Adoter::Asset::GameRecord_GameElement_DetailElement& details(int index) const;
  inline ::Adoter::Asset::GameRecord_GameElement_DetailElement* mutable_details(int index);
  inline ::Adoter::Asset::GameRecord_GameElement_DetailElement* add_details();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement_DetailElement >&
      details() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement_DetailElement >*
      mutable_details();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameRecord.GameElement)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* nickname_;
  ::std::string* headimgurl_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement_DetailElement > details_;
  ::google::protobuf::int32 score_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameRecord_GameElement* default_instance_;
};
// -------------------------------------------------------------------

class GameRecord : public ::google::protobuf::Message {
 public:
  GameRecord();
  virtual ~GameRecord();

  GameRecord(const GameRecord& from);

  inline GameRecord& operator=(const GameRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameRecord& default_instance();

  void Swap(GameRecord* other);

  // implements Message ----------------------------------------------

  GameRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameRecord& from);
  void MergeFrom(const GameRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameRecord_GameElement GameElement;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.GameRecord.GameElement list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::Adoter::Asset::GameRecord_GameElement& list(int index) const;
  inline ::Adoter::Asset::GameRecord_GameElement* mutable_list(int index);
  inline ::Adoter::Asset::GameRecord_GameElement* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameRecord)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement > list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameRecord* default_instance_;
};
// -------------------------------------------------------------------

class RoomHistory : public ::google::protobuf::Message {
 public:
  RoomHistory();
  virtual ~RoomHistory();

  RoomHistory(const RoomHistory& from);

  inline RoomHistory& operator=(const RoomHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomHistory& default_instance();

  void Swap(RoomHistory* other);

  // implements Message ----------------------------------------------

  RoomHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomHistory& from);
  void MergeFrom(const RoomHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional int32 create_time = 2;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional .Adoter.Asset.RoomOptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline const ::Adoter::Asset::RoomOptions& options() const;
  inline ::Adoter::Asset::RoomOptions* mutable_options();
  inline ::Adoter::Asset::RoomOptions* release_options();
  inline void set_allocated_options(::Adoter::Asset::RoomOptions* options);

  // repeated .Adoter.Asset.GameRecord list = 4;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 4;
  inline const ::Adoter::Asset::GameRecord& list(int index) const;
  inline ::Adoter::Asset::GameRecord* mutable_list(int index);
  inline ::Adoter::Asset::GameRecord* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >*
      mutable_list();

  // repeated .Adoter.Asset.PlayerBrief player_brief_list = 5;
  inline int player_brief_list_size() const;
  inline void clear_player_brief_list();
  static const int kPlayerBriefListFieldNumber = 5;
  inline const ::Adoter::Asset::PlayerBrief& player_brief_list(int index) const;
  inline ::Adoter::Asset::PlayerBrief* mutable_player_brief_list(int index);
  inline ::Adoter::Asset::PlayerBrief* add_player_brief_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >&
      player_brief_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >*
      mutable_player_brief_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomHistory)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  ::Adoter::Asset::RoomOptions* options_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord > list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief > player_brief_list_;
  ::google::protobuf::int32 create_time_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomHistory* default_instance_;
};
// -------------------------------------------------------------------

class CommonProp : public ::google::protobuf::Message {
 public:
  CommonProp();
  virtual ~CommonProp();

  CommonProp(const CommonProp& from);

  inline CommonProp& operator=(const CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonProp& default_instance();

  void Swap(CommonProp* other);

  // implements Message ----------------------------------------------

  CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonProp& from);
  void MergeFrom(const CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int32 local_server_id = 2;
  inline bool has_local_server_id() const;
  inline void clear_local_server_id();
  static const int kLocalServerIdFieldNumber = 2;
  inline ::google::protobuf::int32 local_server_id() const;
  inline void set_local_server_id(::google::protobuf::int32 value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 iphoto = 4;
  inline bool has_iphoto() const;
  inline void clear_iphoto();
  static const int kIphotoFieldNumber = 4;
  inline ::google::protobuf::int32 iphoto() const;
  inline void set_iphoto(::google::protobuf::int32 value);

  // optional int32 level = 5 [default = 1];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional .Adoter.Asset.GENDER_TYPE gender = 6 [default = GENDER_TYPE_WOMAN];
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 6;
  inline ::Adoter::Asset::GENDER_TYPE gender() const;
  inline void set_gender(::Adoter::Asset::GENDER_TYPE value);

  // optional int64 diamond = 7;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 7;
  inline ::google::protobuf::int64 diamond() const;
  inline void set_diamond(::google::protobuf::int64 value);

  // optional int64 huanledou = 8 [default = 10000];
  inline bool has_huanledou() const;
  inline void clear_huanledou();
  static const int kHuanledouFieldNumber = 8;
  inline ::google::protobuf::int64 huanledou() const;
  inline void set_huanledou(::google::protobuf::int64 value);

  // optional int64 room_card_count = 9 [default = 2];
  inline bool has_room_card_count() const;
  inline void clear_room_card_count();
  static const int kRoomCardCountFieldNumber = 9;
  inline ::google::protobuf::int64 room_card_count() const;
  inline void set_room_card_count(::google::protobuf::int64 value);

  // optional int64 total_rounds = 10;
  inline bool has_total_rounds() const;
  inline void clear_total_rounds();
  static const int kTotalRoundsFieldNumber = 10;
  inline ::google::protobuf::int64 total_rounds() const;
  inline void set_total_rounds(::google::protobuf::int64 value);

  // optional int64 room_card_rounds = 11;
  inline bool has_room_card_rounds() const;
  inline void clear_room_card_rounds();
  static const int kRoomCardRoundsFieldNumber = 11;
  inline ::google::protobuf::int64 room_card_rounds() const;
  inline void set_room_card_rounds(::google::protobuf::int64 value);

  // optional int64 total_win_rounds = 12;
  inline bool has_total_win_rounds() const;
  inline void clear_total_win_rounds();
  static const int kTotalWinRoundsFieldNumber = 12;
  inline ::google::protobuf::int64 total_win_rounds() const;
  inline void set_total_win_rounds(::google::protobuf::int64 value);

  // optional int64 streak_wins = 13;
  inline bool has_streak_wins() const;
  inline void clear_streak_wins();
  static const int kStreakWinsFieldNumber = 13;
  inline ::google::protobuf::int64 streak_wins() const;
  inline void set_streak_wins(::google::protobuf::int64 value);

  // optional int64 score = 14;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 14;
  inline ::google::protobuf::int64 score() const;
  inline void set_score(::google::protobuf::int64 value);

  // optional int32 score_win_rounds = 15;
  inline bool has_score_win_rounds() const;
  inline void clear_score_win_rounds();
  static const int kScoreWinRoundsFieldNumber = 15;
  inline ::google::protobuf::int32 score_win_rounds() const;
  inline void set_score_win_rounds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonProp)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_local_server_id();
  inline void clear_has_local_server_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_iphoto();
  inline void clear_has_iphoto();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_huanledou();
  inline void clear_has_huanledou();
  inline void set_has_room_card_count();
  inline void clear_has_room_card_count();
  inline void set_has_total_rounds();
  inline void clear_has_total_rounds();
  inline void set_has_room_card_rounds();
  inline void clear_has_room_card_rounds();
  inline void set_has_total_win_rounds();
  inline void clear_has_total_win_rounds();
  inline void set_has_streak_wins();
  inline void clear_has_streak_wins();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_score_win_rounds();
  inline void clear_has_score_win_rounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* name_;
  ::google::protobuf::int32 local_server_id_;
  ::google::protobuf::int32 iphoto_;
  ::google::protobuf::int32 level_;
  int gender_;
  ::google::protobuf::int64 diamond_;
  ::google::protobuf::int64 huanledou_;
  ::google::protobuf::int64 room_card_count_;
  ::google::protobuf::int64 total_rounds_;
  ::google::protobuf::int64 room_card_rounds_;
  ::google::protobuf::int64 total_win_rounds_;
  ::google::protobuf::int64 streak_wins_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int32 score_win_rounds_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCommonLimit_Element : public ::google::protobuf::Message {
 public:
  PlayerCommonLimit_Element();
  virtual ~PlayerCommonLimit_Element();

  PlayerCommonLimit_Element(const PlayerCommonLimit_Element& from);

  inline PlayerCommonLimit_Element& operator=(const PlayerCommonLimit_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommonLimit_Element& default_instance();

  void Swap(PlayerCommonLimit_Element* other);

  // implements Message ----------------------------------------------

  PlayerCommonLimit_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCommonLimit_Element& from);
  void MergeFrom(const PlayerCommonLimit_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 common_limit_id = 1;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 1;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // optional int32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::int32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int32 value);

  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCommonLimit.Element)
 private:
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_limit_id_;
  ::google::protobuf::int32 time_stamp_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCommonLimit_Element* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCommonLimit : public ::google::protobuf::Message {
 public:
  PlayerCommonLimit();
  virtual ~PlayerCommonLimit();

  PlayerCommonLimit(const PlayerCommonLimit& from);

  inline PlayerCommonLimit& operator=(const PlayerCommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommonLimit& default_instance();

  void Swap(PlayerCommonLimit* other);

  // implements Message ----------------------------------------------

  PlayerCommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCommonLimit& from);
  void MergeFrom(const PlayerCommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerCommonLimit_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.PlayerCommonLimit.Element elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Adoter::Asset::PlayerCommonLimit_Element& elements(int index) const;
  inline ::Adoter::Asset::PlayerCommonLimit_Element* mutable_elements(int index);
  inline ::Adoter::Asset::PlayerCommonLimit_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCommonLimit)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element > elements_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCoolDown_Element : public ::google::protobuf::Message {
 public:
  PlayerCoolDown_Element();
  virtual ~PlayerCoolDown_Element();

  PlayerCoolDown_Element(const PlayerCoolDown_Element& from);

  inline PlayerCoolDown_Element& operator=(const PlayerCoolDown_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCoolDown_Element& default_instance();

  void Swap(PlayerCoolDown_Element* other);

  // implements Message ----------------------------------------------

  PlayerCoolDown_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCoolDown_Element& from);
  void MergeFrom(const PlayerCoolDown_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 cool_down_id = 1;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 1;
  inline ::google::protobuf::int64 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int64 value);

  // optional int32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::int32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCoolDown.Element)
 private:
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 cool_down_id_;
  ::google::protobuf::int32 time_stamp_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCoolDown_Element* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCoolDown : public ::google::protobuf::Message {
 public:
  PlayerCoolDown();
  virtual ~PlayerCoolDown();

  PlayerCoolDown(const PlayerCoolDown& from);

  inline PlayerCoolDown& operator=(const PlayerCoolDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCoolDown& default_instance();

  void Swap(PlayerCoolDown* other);

  // implements Message ----------------------------------------------

  PlayerCoolDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCoolDown& from);
  void MergeFrom(const PlayerCoolDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerCoolDown_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.PlayerCoolDown.Element elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Adoter::Asset::PlayerCoolDown_Element& elements(int index) const;
  inline ::Adoter::Asset::PlayerCoolDown_Element* mutable_elements(int index);
  inline ::Adoter::Asset::PlayerCoolDown_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCoolDown)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element > elements_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCoolDown* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Location)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double longitude_;
  double latitude_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class ClientInfomation : public ::google::protobuf::Message {
 public:
  ClientInfomation();
  virtual ~ClientInfomation();

  ClientInfomation(const ClientInfomation& from);

  inline ClientInfomation& operator=(const ClientInfomation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInfomation& default_instance();

  void Swap(ClientInfomation* other);

  // implements Message ----------------------------------------------

  ClientInfomation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientInfomation& from);
  void MergeFrom(const ClientInfomation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ip_address = 1;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const void* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // optional bytes system = 2;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 2;
  inline const ::std::string& system() const;
  inline void set_system(const ::std::string& value);
  inline void set_system(const char* value);
  inline void set_system(const void* value, size_t size);
  inline ::std::string* mutable_system();
  inline ::std::string* release_system();
  inline void set_allocated_system(::std::string* system);

  // optional bytes phone_type = 3;
  inline bool has_phone_type() const;
  inline void clear_phone_type();
  static const int kPhoneTypeFieldNumber = 3;
  inline const ::std::string& phone_type() const;
  inline void set_phone_type(const ::std::string& value);
  inline void set_phone_type(const char* value);
  inline void set_phone_type(const void* value, size_t size);
  inline ::std::string* mutable_phone_type();
  inline ::std::string* release_phone_type();
  inline void set_allocated_phone_type(::std::string* phone_type);

  // optional .Adoter.Asset.Location location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::Adoter::Asset::Location& location() const;
  inline ::Adoter::Asset::Location* mutable_location();
  inline ::Adoter::Asset::Location* release_location();
  inline void set_allocated_location(::Adoter::Asset::Location* location);

  // optional int32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional bytes imei = 6;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 6;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const void* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ClientInfomation)
 private:
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_phone_type();
  inline void clear_has_phone_type();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_imei();
  inline void clear_has_imei();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_address_;
  ::std::string* system_;
  ::std::string* phone_type_;
  ::Adoter::Asset::Location* location_;
  ::std::string* imei_;
  ::google::protobuf::int32 version_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClientInfomation* default_instance_;
};
// -------------------------------------------------------------------

class Mail : public ::google::protobuf::Message {
 public:
  Mail();
  virtual ~Mail();

  Mail(const Mail& from);

  inline Mail& operator=(const Mail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mail& default_instance();

  void Swap(Mail* other);

  // implements Message ----------------------------------------------

  Mail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mail& from);
  void MergeFrom(const Mail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const void* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional bytes send_player = 2 [default = "\347\263\273\347\273\237\351\202\256\344\273\266"];
  inline bool has_send_player() const;
  inline void clear_send_player();
  static const int kSendPlayerFieldNumber = 2;
  inline const ::std::string& send_player() const;
  inline void set_send_player(const ::std::string& value);
  inline void set_send_player(const char* value);
  inline void set_send_player(const void* value, size_t size);
  inline ::std::string* mutable_send_player();
  inline ::std::string* release_send_player();
  inline void set_allocated_send_player(::std::string* send_player);

  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional int32 send_time = 4;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 4;
  inline ::google::protobuf::int32 send_time() const;
  inline void set_send_time(::google::protobuf::int32 value);

  // optional bool readed = 5;
  inline bool has_readed() const;
  inline void clear_readed();
  static const int kReadedFieldNumber = 5;
  inline bool readed() const;
  inline void set_readed(bool value);

  // repeated .Adoter.Asset.MailAttachment attachments = 6;
  inline int attachments_size() const;
  inline void clear_attachments();
  static const int kAttachmentsFieldNumber = 6;
  inline const ::Adoter::Asset::MailAttachment& attachments(int index) const;
  inline ::Adoter::Asset::MailAttachment* mutable_attachments(int index);
  inline ::Adoter::Asset::MailAttachment* add_attachments();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MailAttachment >&
      attachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MailAttachment >*
      mutable_attachments();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Mail)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_send_player();
  inline void clear_has_send_player();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_readed();
  inline void clear_has_readed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  static ::std::string* _default_send_player_;
  ::std::string* send_player_;
  ::std::string* content_;
  ::google::protobuf::int32 send_time_;
  bool readed_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MailAttachment > attachments_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Mail* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CommonProp common_prop = 1;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 1;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // optional bytes account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int64 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::int64 server_id() const;
  inline void set_server_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.Inventory inventory = 4;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 4;
  inline const ::Adoter::Asset::Inventory& inventory() const;
  inline ::Adoter::Asset::Inventory* mutable_inventory();
  inline ::Adoter::Asset::Inventory* release_inventory();
  inline void set_allocated_inventory(::Adoter::Asset::Inventory* inventory);

  // optional .Adoter.Asset.PlayerCommonLimit common_limit = 5;
  inline bool has_common_limit() const;
  inline void clear_common_limit();
  static const int kCommonLimitFieldNumber = 5;
  inline const ::Adoter::Asset::PlayerCommonLimit& common_limit() const;
  inline ::Adoter::Asset::PlayerCommonLimit* mutable_common_limit();
  inline ::Adoter::Asset::PlayerCommonLimit* release_common_limit();
  inline void set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit);

  // optional .Adoter.Asset.PlayerCoolDown cool_down = 6;
  inline bool has_cool_down() const;
  inline void clear_cool_down();
  static const int kCoolDownFieldNumber = 6;
  inline const ::Adoter::Asset::PlayerCoolDown& cool_down() const;
  inline ::Adoter::Asset::PlayerCoolDown* mutable_cool_down();
  inline ::Adoter::Asset::PlayerCoolDown* release_cool_down();
  inline void set_allocated_cool_down(::Adoter::Asset::PlayerCoolDown* cool_down);

  // optional int32 login_time = 7;
  inline bool has_login_time() const;
  inline void clear_login_time();
  static const int kLoginTimeFieldNumber = 7;
  inline ::google::protobuf::int32 login_time() const;
  inline void set_login_time(::google::protobuf::int32 value);

  // optional int32 logout_time = 8;
  inline bool has_logout_time() const;
  inline void clear_logout_time();
  static const int kLogoutTimeFieldNumber = 8;
  inline ::google::protobuf::int32 logout_time() const;
  inline void set_logout_time(::google::protobuf::int32 value);

  // repeated int32 sign_time = 9;
  inline int sign_time_size() const;
  inline void clear_sign_time();
  static const int kSignTimeFieldNumber = 9;
  inline ::google::protobuf::int32 sign_time(int index) const;
  inline void set_sign_time(int index, ::google::protobuf::int32 value);
  inline void add_sign_time(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sign_time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sign_time();

  // repeated int64 mail_list_system = 10;
  inline int mail_list_system_size() const;
  inline void clear_mail_list_system();
  static const int kMailListSystemFieldNumber = 10;
  inline ::google::protobuf::int64 mail_list_system(int index) const;
  inline void set_mail_list_system(int index, ::google::protobuf::int64 value);
  inline void add_mail_list_system(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      mail_list_system() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_mail_list_system();

  // repeated .Adoter.Asset.Mail mail_list_customized = 11;
  inline int mail_list_customized_size() const;
  inline void clear_mail_list_customized();
  static const int kMailListCustomizedFieldNumber = 11;
  inline const ::Adoter::Asset::Mail& mail_list_customized(int index) const;
  inline ::Adoter::Asset::Mail* mutable_mail_list_customized(int index);
  inline ::Adoter::Asset::Mail* add_mail_list_customized();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >&
      mail_list_customized() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >*
      mutable_mail_list_customized();

  // optional .Adoter.Asset.PlayerSetting game_setting = 12;
  inline bool has_game_setting() const;
  inline void clear_game_setting();
  static const int kGameSettingFieldNumber = 12;
  inline const ::Adoter::Asset::PlayerSetting& game_setting() const;
  inline ::Adoter::Asset::PlayerSetting* mutable_game_setting();
  inline ::Adoter::Asset::PlayerSetting* release_game_setting();
  inline void set_allocated_game_setting(::Adoter::Asset::PlayerSetting* game_setting);

  // repeated int64 room_history = 13;
  inline int room_history_size() const;
  inline void clear_room_history();
  static const int kRoomHistoryFieldNumber = 13;
  inline ::google::protobuf::int64 room_history(int index) const;
  inline void set_room_history(int index, ::google::protobuf::int64 value);
  inline void add_room_history(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      room_history() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_room_history();

  // optional int64 room_id = 14;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 14;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional bool card_count_changed = 15 [default = false];
  inline bool has_card_count_changed() const;
  inline void clear_card_count_changed();
  static const int kCardCountChangedFieldNumber = 15;
  inline bool card_count_changed() const;
  inline void set_card_count_changed(bool value);

  // optional .Adoter.Asset.ROOM_TYPE matching_room_type = 16;
  inline bool has_matching_room_type() const;
  inline void clear_matching_room_type();
  static const int kMatchingRoomTypeFieldNumber = 16;
  inline ::Adoter::Asset::ROOM_TYPE matching_room_type() const;
  inline void set_matching_room_type(::Adoter::Asset::ROOM_TYPE value);

  // repeated int64 clan_hosters = 17;
  inline int clan_hosters_size() const;
  inline void clear_clan_hosters();
  static const int kClanHostersFieldNumber = 17;
  inline ::google::protobuf::int64 clan_hosters(int index) const;
  inline void set_clan_hosters(int index, ::google::protobuf::int64 value);
  inline void add_clan_hosters(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      clan_hosters() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_clan_hosters();

  // repeated int64 clan_joiners = 18;
  inline int clan_joiners_size() const;
  inline void clear_clan_joiners();
  static const int kClanJoinersFieldNumber = 18;
  inline ::google::protobuf::int64 clan_joiners(int index) const;
  inline void set_clan_joiners(int index, ::google::protobuf::int64 value);
  inline void add_clan_joiners(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      clan_joiners() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_clan_joiners();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Player)
 private:
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_common_limit();
  inline void clear_has_common_limit();
  inline void set_has_cool_down();
  inline void clear_has_cool_down();
  inline void set_has_login_time();
  inline void clear_has_login_time();
  inline void set_has_logout_time();
  inline void clear_has_logout_time();
  inline void set_has_game_setting();
  inline void clear_has_game_setting();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_card_count_changed();
  inline void clear_has_card_count_changed();
  inline void set_has_matching_room_type();
  inline void clear_has_matching_room_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::CommonProp* common_prop_;
  ::std::string* account_;
  ::google::protobuf::int64 server_id_;
  ::Adoter::Asset::Inventory* inventory_;
  ::Adoter::Asset::PlayerCommonLimit* common_limit_;
  ::Adoter::Asset::PlayerCoolDown* cool_down_;
  ::google::protobuf::int32 login_time_;
  ::google::protobuf::int32 logout_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sign_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > mail_list_system_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail > mail_list_customized_;
  ::Adoter::Asset::PlayerSetting* game_setting_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > room_history_;
  ::google::protobuf::int64 room_id_;
  bool card_count_changed_;
  int matching_room_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > clan_hosters_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > clan_joiners_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class Inventory_Element : public ::google::protobuf::Message {
 public:
  Inventory_Element();
  virtual ~Inventory_Element();

  Inventory_Element(const Inventory_Element& from);

  inline Inventory_Element& operator=(const Inventory_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory_Element& default_instance();

  void Swap(Inventory_Element* other);

  // implements Message ----------------------------------------------

  Inventory_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inventory_Element& from);
  void MergeFrom(const Inventory_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
  inline bool has_inventory_type() const;
  inline void clear_inventory_type();
  static const int kInventoryTypeFieldNumber = 1;
  inline ::Adoter::Asset::INVENTORY_TYPE inventory_type() const;
  inline void set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value);

  // repeated .Adoter.Asset.Item_Item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::Adoter::Asset::Item_Item& items(int index) const;
  inline ::Adoter::Asset::Item_Item* mutable_items(int index);
  inline ::Adoter::Asset::Item_Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Inventory.Element)
 private:
  inline void set_has_inventory_type();
  inline void clear_has_inventory_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item > items_;
  int inventory_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Inventory_Element* default_instance_;
};
// -------------------------------------------------------------------

class Inventory : public ::google::protobuf::Message {
 public:
  Inventory();
  virtual ~Inventory();

  Inventory(const Inventory& from);

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory& default_instance();

  void Swap(Inventory* other);

  // implements Message ----------------------------------------------

  Inventory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Inventory_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.Inventory.Element inventory = 1;
  inline int inventory_size() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 1;
  inline const ::Adoter::Asset::Inventory_Element& inventory(int index) const;
  inline ::Adoter::Asset::Inventory_Element* mutable_inventory(int index);
  inline ::Adoter::Asset::Inventory_Element* add_inventory();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >&
      inventory() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >*
      mutable_inventory();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Inventory)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element > inventory_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Inventory* default_instance_;
};
// -------------------------------------------------------------------

class SystemMessage : public ::google::protobuf::Message {
 public:
  SystemMessage();
  virtual ~SystemMessage();

  SystemMessage(const SystemMessage& from);

  inline SystemMessage& operator=(const SystemMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemMessage& default_instance();

  void Swap(SystemMessage* other);

  // implements Message ----------------------------------------------

  SystemMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemMessage& from);
  void MergeFrom(const SystemMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 oper_time = 3;
  inline bool has_oper_time() const;
  inline void clear_oper_time();
  static const int kOperTimeFieldNumber = 3;
  inline ::google::protobuf::int32 oper_time() const;
  inline void set_oper_time(::google::protobuf::int32 value);

  // optional .Adoter.Asset.CLAN_OPER_TYPE oper_type = 4;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 4;
  inline ::Adoter::Asset::CLAN_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::CLAN_OPER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SystemMessage)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_oper_time();
  inline void clear_has_oper_time();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* name_;
  ::google::protobuf::int32 oper_time_;
  int oper_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SystemMessage* default_instance_;
};
// -------------------------------------------------------------------

class Clan_Member : public ::google::protobuf::Message {
 public:
  Clan_Member();
  virtual ~Clan_Member();

  Clan_Member(const Clan_Member& from);

  inline Clan_Member& operator=(const Clan_Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan_Member& default_instance();

  void Swap(Clan_Member* other);

  // implements Message ----------------------------------------------

  Clan_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan_Member& from);
  void MergeFrom(const Clan_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .Adoter.Asset.CLAN_MEM_STATUS_TYPE status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::Adoter::Asset::CLAN_MEM_STATUS_TYPE status() const;
  inline void set_status(::Adoter::Asset::CLAN_MEM_STATUS_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Clan.Member)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* name_;
  int status_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Clan_Member* default_instance_;
};
// -------------------------------------------------------------------

class Clan_RoomHistory : public ::google::protobuf::Message {
 public:
  Clan_RoomHistory();
  virtual ~Clan_RoomHistory();

  Clan_RoomHistory(const Clan_RoomHistory& from);

  inline Clan_RoomHistory& operator=(const Clan_RoomHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan_RoomHistory& default_instance();

  void Swap(Clan_RoomHistory* other);

  // implements Message ----------------------------------------------

  Clan_RoomHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan_RoomHistory& from);
  void MergeFrom(const Clan_RoomHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional int32 battle_time = 2;
  inline bool has_battle_time() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 2;
  inline ::google::protobuf::int32 battle_time() const;
  inline void set_battle_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Clan.RoomHistory)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_battle_time();
  inline void clear_has_battle_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  ::google::protobuf::int32 battle_time_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Clan_RoomHistory* default_instance_;
};
// -------------------------------------------------------------------

class Clan : public ::google::protobuf::Message {
 public:
  Clan();
  virtual ~Clan();

  Clan(const Clan& from);

  inline Clan& operator=(const Clan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan& default_instance();

  void Swap(Clan* other);

  // implements Message ----------------------------------------------

  Clan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan& from);
  void MergeFrom(const Clan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Clan_Member Member;
  typedef Clan_RoomHistory RoomHistory;

  // accessors -------------------------------------------------------

  // optional int64 clan_id = 1;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::int64 clan_id() const;
  inline void set_clan_id(::google::protobuf::int64 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 created_time = 3;
  inline bool has_created_time() const;
  inline void clear_created_time();
  static const int kCreatedTimeFieldNumber = 3;
  inline ::google::protobuf::int32 created_time() const;
  inline void set_created_time(::google::protobuf::int32 value);

  // optional int64 hoster_id = 4;
  inline bool has_hoster_id() const;
  inline void clear_hoster_id();
  static const int kHosterIdFieldNumber = 4;
  inline ::google::protobuf::int64 hoster_id() const;
  inline void set_hoster_id(::google::protobuf::int64 value);

  // optional bytes hoster_name = 5;
  inline bool has_hoster_name() const;
  inline void clear_hoster_name();
  static const int kHosterNameFieldNumber = 5;
  inline const ::std::string& hoster_name() const;
  inline void set_hoster_name(const ::std::string& value);
  inline void set_hoster_name(const char* value);
  inline void set_hoster_name(const void* value, size_t size);
  inline ::std::string* mutable_hoster_name();
  inline ::std::string* release_hoster_name();
  inline void set_allocated_hoster_name(::std::string* hoster_name);

  // optional int64 room_card_count = 6;
  inline bool has_room_card_count() const;
  inline void clear_room_card_count();
  static const int kRoomCardCountFieldNumber = 6;
  inline ::google::protobuf::int64 room_card_count() const;
  inline void set_room_card_count(::google::protobuf::int64 value);

  // optional bytes announcement = 7;
  inline bool has_announcement() const;
  inline void clear_announcement();
  static const int kAnnouncementFieldNumber = 7;
  inline const ::std::string& announcement() const;
  inline void set_announcement(const ::std::string& value);
  inline void set_announcement(const char* value);
  inline void set_announcement(const void* value, size_t size);
  inline ::std::string* mutable_announcement();
  inline ::std::string* release_announcement();
  inline void set_allocated_announcement(::std::string* announcement);

  // repeated .Adoter.Asset.Clan.Member member_list = 8;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 8;
  inline const ::Adoter::Asset::Clan_Member& member_list(int index) const;
  inline ::Adoter::Asset::Clan_Member* mutable_member_list(int index);
  inline ::Adoter::Asset::Clan_Member* add_member_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_Member >&
      member_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_Member >*
      mutable_member_list();

  // optional bool dismiss = 9;
  inline bool has_dismiss() const;
  inline void clear_dismiss();
  static const int kDismissFieldNumber = 9;
  inline bool dismiss() const;
  inline void set_dismiss(bool value);

  // repeated .Adoter.Asset.Clan.RoomHistory battle_history = 10;
  inline int battle_history_size() const;
  inline void clear_battle_history();
  static const int kBattleHistoryFieldNumber = 10;
  inline const ::Adoter::Asset::Clan_RoomHistory& battle_history(int index) const;
  inline ::Adoter::Asset::Clan_RoomHistory* mutable_battle_history(int index);
  inline ::Adoter::Asset::Clan_RoomHistory* add_battle_history();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_RoomHistory >&
      battle_history() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_RoomHistory >*
      mutable_battle_history();

  // repeated .Adoter.Asset.SystemMessage message_list = 11;
  inline int message_list_size() const;
  inline void clear_message_list();
  static const int kMessageListFieldNumber = 11;
  inline const ::Adoter::Asset::SystemMessage& message_list(int index) const;
  inline ::Adoter::Asset::SystemMessage* mutable_message_list(int index);
  inline ::Adoter::Asset::SystemMessage* add_message_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SystemMessage >&
      message_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SystemMessage >*
      mutable_message_list();

  // repeated int64 room_list = 12;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 12;
  inline ::google::protobuf::int64 room_list(int index) const;
  inline void set_room_list(int index, ::google::protobuf::int64 value);
  inline void add_room_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      room_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Clan)
 private:
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_created_time();
  inline void clear_has_created_time();
  inline void set_has_hoster_id();
  inline void clear_has_hoster_id();
  inline void set_has_hoster_name();
  inline void clear_has_hoster_name();
  inline void set_has_room_card_count();
  inline void clear_has_room_card_count();
  inline void set_has_announcement();
  inline void clear_has_announcement();
  inline void set_has_dismiss();
  inline void clear_has_dismiss();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 clan_id_;
  ::std::string* name_;
  ::google::protobuf::int64 hoster_id_;
  ::std::string* hoster_name_;
  ::google::protobuf::int64 room_card_count_;
  ::google::protobuf::int32 created_time_;
  bool dismiss_;
  ::std::string* announcement_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_Member > member_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_RoomHistory > battle_history_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SystemMessage > message_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > room_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Clan* default_instance_;
};
// -------------------------------------------------------------------

class ItemEquipment : public ::google::protobuf::Message {
 public:
  ItemEquipment();
  virtual ~ItemEquipment();

  ItemEquipment(const ItemEquipment& from);

  inline ItemEquipment& operator=(const ItemEquipment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemEquipment& default_instance();

  void Swap(ItemEquipment* other);

  // implements Message ----------------------------------------------

  ItemEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemEquipment& from);
  void MergeFrom(const ItemEquipment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 star = 1;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 1;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ItemEquipment)
 private:
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 star_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ItemEquipment* default_instance_;
};
// -------------------------------------------------------------------

class Meta : public ::google::protobuf::Message {
 public:
  Meta();
  virtual ~Meta();

  Meta(const Meta& from);

  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Meta& default_instance();

  void Swap(Meta* other);

  // implements Message ----------------------------------------------

  Meta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Meta& from);
  void MergeFrom(const Meta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1;
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes stuff = 2;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 2;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Meta)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_stuff();
  inline void clear_has_stuff();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stuff_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Meta* default_instance_;
};
// -------------------------------------------------------------------

class CreatePlayer : public ::google::protobuf::Message {
 public:
  CreatePlayer();
  virtual ~CreatePlayer();

  CreatePlayer(const CreatePlayer& from);

  inline CreatePlayer& operator=(const CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayer& default_instance();

  void Swap(CreatePlayer* other);

  // implements Message ----------------------------------------------

  CreatePlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePlayer& from);
  void MergeFrom(const CreatePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_PLAYER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CreatePlayer)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CreatePlayer* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Account account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::Adoter::Asset::Account& account() const;
  inline ::Adoter::Asset::Account* mutable_account();
  inline ::Adoter::Asset::Account* release_account();
  inline void set_allocated_account(::Adoter::Asset::Account* account);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Login)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Account* account_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class WechatAccessToken : public ::google::protobuf::Message {
 public:
  WechatAccessToken();
  virtual ~WechatAccessToken();

  WechatAccessToken(const WechatAccessToken& from);

  inline WechatAccessToken& operator=(const WechatAccessToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WechatAccessToken& default_instance();

  void Swap(WechatAccessToken* other);

  // implements Message ----------------------------------------------

  WechatAccessToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WechatAccessToken& from);
  void MergeFrom(const WechatAccessToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const void* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional int32 expires_in = 2;
  inline bool has_expires_in() const;
  inline void clear_expires_in();
  static const int kExpiresInFieldNumber = 2;
  inline ::google::protobuf::int32 expires_in() const;
  inline void set_expires_in(::google::protobuf::int32 value);

  // optional bytes refresh_token = 3;
  inline bool has_refresh_token() const;
  inline void clear_refresh_token();
  static const int kRefreshTokenFieldNumber = 3;
  inline const ::std::string& refresh_token() const;
  inline void set_refresh_token(const ::std::string& value);
  inline void set_refresh_token(const char* value);
  inline void set_refresh_token(const void* value, size_t size);
  inline ::std::string* mutable_refresh_token();
  inline ::std::string* release_refresh_token();
  inline void set_allocated_refresh_token(::std::string* refresh_token);

  // optional bytes openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const void* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional bytes scope = 5;
  inline bool has_scope() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 5;
  inline const ::std::string& scope() const;
  inline void set_scope(const ::std::string& value);
  inline void set_scope(const char* value);
  inline void set_scope(const void* value, size_t size);
  inline ::std::string* mutable_scope();
  inline ::std::string* release_scope();
  inline void set_allocated_scope(::std::string* scope);

  // optional bytes unionid = 6;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 6;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const void* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WechatAccessToken)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_expires_in();
  inline void clear_has_expires_in();
  inline void set_has_refresh_token();
  inline void clear_has_refresh_token();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_scope();
  inline void clear_has_scope();
  inline void set_has_unionid();
  inline void clear_has_unionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* refresh_token_;
  ::std::string* openid_;
  ::std::string* scope_;
  ::std::string* unionid_;
  ::google::protobuf::int32 expires_in_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static WechatAccessToken* default_instance_;
};
// -------------------------------------------------------------------

class WechatError : public ::google::protobuf::Message {
 public:
  WechatError();
  virtual ~WechatError();

  WechatError(const WechatError& from);

  inline WechatError& operator=(const WechatError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WechatError& default_instance();

  void Swap(WechatError* other);

  // implements Message ----------------------------------------------

  WechatError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WechatError& from);
  void MergeFrom(const WechatError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int32 errcode() const;
  inline void set_errcode(::google::protobuf::int32 value);

  // optional bytes errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const void* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WechatError)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* errmsg_;
  ::google::protobuf::int32 errcode_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static WechatError* default_instance_;
};
// -------------------------------------------------------------------

class WechatLogin : public ::google::protobuf::Message {
 public:
  WechatLogin();
  virtual ~WechatLogin();

  WechatLogin(const WechatLogin& from);

  inline WechatLogin& operator=(const WechatLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WechatLogin& default_instance();

  void Swap(WechatLogin* other);

  // implements Message ----------------------------------------------

  WechatLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WechatLogin& from);
  void MergeFrom(const WechatLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_WECHAT_LOGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.WechatUnion wechat = 2;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 2;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WechatLogin)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_wechat();
  inline void clear_has_wechat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::WechatUnion* wechat_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static WechatLogin* default_instance_;
};
// -------------------------------------------------------------------

class SwitchAccount : public ::google::protobuf::Message {
 public:
  SwitchAccount();
  virtual ~SwitchAccount();

  SwitchAccount(const SwitchAccount& from);

  inline SwitchAccount& operator=(const SwitchAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchAccount& default_instance();

  void Swap(SwitchAccount* other);

  // implements Message ----------------------------------------------

  SwitchAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchAccount& from);
  void MergeFrom(const SwitchAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_SWITCH_ACCOUNT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes account_name = 2;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 2;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const void* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SwitchAccount)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* account_name_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SwitchAccount* default_instance_;
};
// -------------------------------------------------------------------

class GetRoomData : public ::google::protobuf::Message {
 public:
  GetRoomData();
  virtual ~GetRoomData();

  GetRoomData(const GetRoomData& from);

  inline GetRoomData& operator=(const GetRoomData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomData& default_instance();

  void Swap(GetRoomData* other);

  // implements Message ----------------------------------------------

  GetRoomData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoomData& from);
  void MergeFrom(const GetRoomData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_ROOM_DATA];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ROOM_SYNC_TYPE reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline ::Adoter::Asset::ROOM_SYNC_TYPE reason() const;
  inline void set_reason(::Adoter::Asset::ROOM_SYNC_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GetRoomData)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int type_t_;
  int reason_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetRoomData* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRoom : public ::google::protobuf::Message {
 public:
  UpdateRoom();
  virtual ~UpdateRoom();

  UpdateRoom(const UpdateRoom& from);

  inline UpdateRoom& operator=(const UpdateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRoom& default_instance();

  void Swap(UpdateRoom* other);

  // implements Message ----------------------------------------------

  UpdateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateRoom& from);
  void MergeFrom(const UpdateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_UPDATE_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 voice_member_id = 2;
  inline bool has_voice_member_id() const;
  inline void clear_voice_member_id();
  static const int kVoiceMemberIdFieldNumber = 2;
  inline ::google::protobuf::int64 voice_member_id() const;
  inline void set_voice_member_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.UpdateRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_voice_member_id();
  inline void clear_has_voice_member_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 voice_member_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static UpdateRoom* default_instance_;
};
// -------------------------------------------------------------------

class WechatUnion : public ::google::protobuf::Message {
 public:
  WechatUnion();
  virtual ~WechatUnion();

  WechatUnion(const WechatUnion& from);

  inline WechatUnion& operator=(const WechatUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WechatUnion& default_instance();

  void Swap(WechatUnion* other);

  // implements Message ----------------------------------------------

  WechatUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WechatUnion& from);
  void MergeFrom(const WechatUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const void* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional bytes nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const void* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional bytes province = 4;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 4;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const void* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional bytes city = 5;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 5;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const void* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional bytes country = 6;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 6;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const void* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional bytes headimgurl = 7;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 7;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const void* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // repeated bytes privilege = 8;
  inline int privilege_size() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 8;
  inline const ::std::string& privilege(int index) const;
  inline ::std::string* mutable_privilege(int index);
  inline void set_privilege(int index, const ::std::string& value);
  inline void set_privilege(int index, const char* value);
  inline void set_privilege(int index, const void* value, size_t size);
  inline ::std::string* add_privilege();
  inline void add_privilege(const ::std::string& value);
  inline void add_privilege(const char* value);
  inline void add_privilege(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& privilege() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_privilege();

  // optional bytes unionid = 9;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 9;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const void* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WechatUnion)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_unionid();
  inline void clear_has_unionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* openid_;
  ::std::string* nickname_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* country_;
  ::std::string* headimgurl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> privilege_;
  ::std::string* unionid_;
  ::google::protobuf::int32 sex_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static WechatUnion* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGOUT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Logout)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class EnterGame : public ::google::protobuf::Message {
 public:
  EnterGame();
  virtual ~EnterGame();

  EnterGame(const EnterGame& from);

  inline EnterGame& operator=(const EnterGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterGame& default_instance();

  void Swap(EnterGame* other);

  // implements Message ----------------------------------------------

  EnterGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterGame& from);
  void MergeFrom(const EnterGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_ENTER_GAME];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.EnterGame)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static EnterGame* default_instance_;
};
// -------------------------------------------------------------------

class UpdateClientData : public ::google::protobuf::Message {
 public:
  UpdateClientData();
  virtual ~UpdateClientData();

  UpdateClientData(const UpdateClientData& from);

  inline UpdateClientData& operator=(const UpdateClientData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateClientData& default_instance();

  void Swap(UpdateClientData* other);

  // implements Message ----------------------------------------------

  UpdateClientData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateClientData& from);
  void MergeFrom(const UpdateClientData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_UPDATE_CLIENT_DATA];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.ClientInfomation client_info = 2;
  inline bool has_client_info() const;
  inline void clear_client_info();
  static const int kClientInfoFieldNumber = 2;
  inline const ::Adoter::Asset::ClientInfomation& client_info() const;
  inline ::Adoter::Asset::ClientInfomation* mutable_client_info();
  inline ::Adoter::Asset::ClientInfomation* release_client_info();
  inline void set_allocated_client_info(::Adoter::Asset::ClientInfomation* client_info);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.UpdateClientData)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_client_info();
  inline void clear_has_client_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::ClientInfomation* client_info_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static UpdateClientData* default_instance_;
};
// -------------------------------------------------------------------

class SystemChat : public ::google::protobuf::Message {
 public:
  SystemChat();
  virtual ~SystemChat();

  SystemChat(const SystemChat& from);

  inline SystemChat& operator=(const SystemChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemChat& default_instance();

  void Swap(SystemChat* other);

  // implements Message ----------------------------------------------

  SystemChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemChat& from);
  void MergeFrom(const SystemChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SYSTEM_CHAT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CHAT_TYPE chat_type = 2;
  inline bool has_chat_type() const;
  inline void clear_chat_type();
  static const int kChatTypeFieldNumber = 2;
  inline ::Adoter::Asset::CHAT_TYPE chat_type() const;
  inline void set_chat_type(::Adoter::Asset::CHAT_TYPE value);

  // optional .Adoter.Asset.POSITION_TYPE position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional int32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SystemChat)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_chat_type();
  inline void clear_has_chat_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int chat_type_;
  int position_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SystemChat* default_instance_;
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  void Swap(Room* other);

  // implements Message ----------------------------------------------

  Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ROOM_TYPE room_type = 2;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROOM_TYPE room_type() const;
  inline void set_room_type(::Adoter::Asset::ROOM_TYPE value);

  // optional bytes enter_password = 3;
  inline bool has_enter_password() const;
  inline void clear_enter_password();
  static const int kEnterPasswordFieldNumber = 3;
  inline const ::std::string& enter_password() const;
  inline void set_enter_password(const ::std::string& value);
  inline void set_enter_password(const char* value);
  inline void set_enter_password(const void* value, size_t size);
  inline ::std::string* mutable_enter_password();
  inline ::std::string* release_enter_password();
  inline void set_allocated_enter_password(::std::string* enter_password);

  // optional .Adoter.Asset.RoomOptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::Adoter::Asset::RoomOptions& options() const;
  inline ::Adoter::Asset::RoomOptions* mutable_options();
  inline ::Adoter::Asset::RoomOptions* release_options();
  inline void set_allocated_options(::Adoter::Asset::RoomOptions* options);

  // optional int64 clan_id = 5;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 5;
  inline ::google::protobuf::int64 clan_id() const;
  inline void set_clan_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Room)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_type();
  inline void clear_has_room_type();
  inline void set_has_enter_password();
  inline void clear_has_enter_password();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  ::std::string* enter_password_;
  ::Adoter::Asset::RoomOptions* options_;
  ::google::protobuf::int64 clan_id_;
  int room_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Room* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();

  void Swap(CreateRoom* other);

  // implements Message ----------------------------------------------

  CreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Room room = 2;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 2;
  inline const ::Adoter::Asset::Room& room() const;
  inline ::Adoter::Asset::Room* mutable_room();
  inline ::Adoter::Asset::Room* release_room();
  inline void set_allocated_room(::Adoter::Asset::Room* room);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CreateRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Room* room_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoom : public ::google::protobuf::Message {
 public:
  EnterRoom();
  virtual ~EnterRoom();

  EnterRoom(const EnterRoom& from);

  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoom& default_instance();

  void Swap(EnterRoom* other);

  // implements Message ----------------------------------------------

  EnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnterRoom_ENTER_TYPE ENTER_TYPE;
  static const ENTER_TYPE ENTER_TYPE_ENTER = EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER;
  static const ENTER_TYPE ENTER_TYPE_CANCEL = EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL;
  static inline bool ENTER_TYPE_IsValid(int value) {
    return EnterRoom_ENTER_TYPE_IsValid(value);
  }
  static const ENTER_TYPE ENTER_TYPE_MIN =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_MIN;
  static const ENTER_TYPE ENTER_TYPE_MAX =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX;
  static const int ENTER_TYPE_ARRAYSIZE =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ENTER_TYPE_descriptor() {
    return EnterRoom_ENTER_TYPE_descriptor();
  }
  static inline const ::std::string& ENTER_TYPE_Name(ENTER_TYPE value) {
    return EnterRoom_ENTER_TYPE_Name(value);
  }
  static inline bool ENTER_TYPE_Parse(const ::std::string& name,
      ENTER_TYPE* value) {
    return EnterRoom_ENTER_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ENTER_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Room room = 2;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 2;
  inline const ::Adoter::Asset::Room& room() const;
  inline ::Adoter::Asset::Room* mutable_room();
  inline ::Adoter::Asset::Room* release_room();
  inline void set_allocated_room(::Adoter::Asset::Room* room);

  // optional .Adoter.Asset.ERROR_CODE error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::Adoter::Asset::ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::ERROR_CODE value);

  // optional .Adoter.Asset.EnterRoom.ENTER_TYPE enter_type = 4;
  inline bool has_enter_type() const;
  inline void clear_enter_type();
  static const int kEnterTypeFieldNumber = 4;
  inline ::Adoter::Asset::EnterRoom_ENTER_TYPE enter_type() const;
  inline void set_enter_type(::Adoter::Asset::EnterRoom_ENTER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.EnterRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_enter_type();
  inline void clear_has_enter_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Room* room_;
  int type_t_;
  int error_code_;
  int enter_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static EnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class Sign : public ::google::protobuf::Message {
 public:
  Sign();
  virtual ~Sign();

  Sign(const Sign& from);

  inline Sign& operator=(const Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sign& default_instance();

  void Swap(Sign* other);

  // implements Message ----------------------------------------------

  Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sign& from);
  void MergeFrom(const Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SIGN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bool success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Sign)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  bool success_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Sign* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLuckyPlate : public ::google::protobuf::Message {
 public:
  PlayerLuckyPlate();
  virtual ~PlayerLuckyPlate();

  PlayerLuckyPlate(const PlayerLuckyPlate& from);

  inline PlayerLuckyPlate& operator=(const PlayerLuckyPlate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLuckyPlate& default_instance();

  void Swap(PlayerLuckyPlate* other);

  // implements Message ----------------------------------------------

  PlayerLuckyPlate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerLuckyPlate& from);
  void MergeFrom(const PlayerLuckyPlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_LUCKY_PLATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 plate_id = 2;
  inline bool has_plate_id() const;
  inline void clear_plate_id();
  static const int kPlateIdFieldNumber = 2;
  inline ::google::protobuf::int64 plate_id() const;
  inline void set_plate_id(::google::protobuf::int64 value);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerLuckyPlate)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_plate_id();
  inline void clear_has_plate_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 plate_id_;
  int type_t_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerLuckyPlate* default_instance_;
};
// -------------------------------------------------------------------

class RandomSaizi : public ::google::protobuf::Message {
 public:
  RandomSaizi();
  virtual ~RandomSaizi();

  RandomSaizi(const RandomSaizi& from);

  inline RandomSaizi& operator=(const RandomSaizi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomSaizi& default_instance();

  void Swap(RandomSaizi* other);

  // implements Message ----------------------------------------------

  RandomSaizi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RandomSaizi& from);
  void MergeFrom(const RandomSaizi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RandomSaizi_REASON_TYPE REASON_TYPE;
  static const REASON_TYPE REASON_TYPE_START = RandomSaizi_REASON_TYPE_REASON_TYPE_START;
  static const REASON_TYPE REASON_TYPE_TINGPAI = RandomSaizi_REASON_TYPE_REASON_TYPE_TINGPAI;
  static const REASON_TYPE REASON_TYPE_HUIPAI = RandomSaizi_REASON_TYPE_REASON_TYPE_HUIPAI;
  static inline bool REASON_TYPE_IsValid(int value) {
    return RandomSaizi_REASON_TYPE_IsValid(value);
  }
  static const REASON_TYPE REASON_TYPE_MIN =
    RandomSaizi_REASON_TYPE_REASON_TYPE_MIN;
  static const REASON_TYPE REASON_TYPE_MAX =
    RandomSaizi_REASON_TYPE_REASON_TYPE_MAX;
  static const int REASON_TYPE_ARRAYSIZE =
    RandomSaizi_REASON_TYPE_REASON_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  REASON_TYPE_descriptor() {
    return RandomSaizi_REASON_TYPE_descriptor();
  }
  static inline const ::std::string& REASON_TYPE_Name(REASON_TYPE value) {
    return RandomSaizi_REASON_TYPE_Name(value);
  }
  static inline bool REASON_TYPE_Parse(const ::std::string& name,
      REASON_TYPE* value) {
    return RandomSaizi_REASON_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_RANDOM_SAIZI];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.RandomSaizi.REASON_TYPE reason_type = 2;
  inline bool has_reason_type() const;
  inline void clear_reason_type();
  static const int kReasonTypeFieldNumber = 2;
  inline ::Adoter::Asset::RandomSaizi_REASON_TYPE reason_type() const;
  inline void set_reason_type(::Adoter::Asset::RandomSaizi_REASON_TYPE value);

  // repeated int32 random_result = 3;
  inline int random_result_size() const;
  inline void clear_random_result();
  static const int kRandomResultFieldNumber = 3;
  inline ::google::protobuf::int32 random_result(int index) const;
  inline void set_random_result(int index, ::google::protobuf::int32 value);
  inline void add_random_result(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      random_result() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_random_result();

  // optional .Adoter.Asset.PaiElement pai = 4;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // optional bool has_rand_saizi = 5;
  inline bool has_has_rand_saizi() const;
  inline void clear_has_rand_saizi();
  static const int kHasRandSaiziFieldNumber = 5;
  inline bool has_rand_saizi() const;
  inline void set_has_rand_saizi(bool value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RandomSaizi)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason_type();
  inline void clear_has_reason_type();
  inline void set_has_pai();
  inline void clear_has_pai();
  inline void set_has_has_rand_saizi();
  inline void clear_has_has_rand_saizi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > random_result_;
  ::Adoter::Asset::PaiElement* pai_;
  bool has_rand_saizi_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RandomSaizi* default_instance_;
};
// -------------------------------------------------------------------

class SayHi : public ::google::protobuf::Message {
 public:
  SayHi();
  virtual ~SayHi();

  SayHi(const SayHi& from);

  inline SayHi& operator=(const SayHi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SayHi& default_instance();

  void Swap(SayHi* other);

  // implements Message ----------------------------------------------

  SayHi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SayHi& from);
  void MergeFrom(const SayHi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SAY_HI];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int32 heart_count = 2;
  inline bool has_heart_count() const;
  inline void clear_heart_count();
  static const int kHeartCountFieldNumber = 2;
  inline ::google::protobuf::int32 heart_count() const;
  inline void set_heart_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SayHi)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_heart_count();
  inline void clear_has_heart_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  ::google::protobuf::int32 heart_count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SayHi* default_instance_;
};
// -------------------------------------------------------------------

class GuestLogin : public ::google::protobuf::Message {
 public:
  GuestLogin();
  virtual ~GuestLogin();

  GuestLogin(const GuestLogin& from);

  inline GuestLogin& operator=(const GuestLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestLogin& default_instance();

  void Swap(GuestLogin* other);

  // implements Message ----------------------------------------------

  GuestLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestLogin& from);
  void MergeFrom(const GuestLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GUEST_LOGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GuestLogin)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* account_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GuestLogin* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSetting : public ::google::protobuf::Message {
 public:
  PlayerSetting();
  virtual ~PlayerSetting();

  PlayerSetting(const PlayerSetting& from);

  inline PlayerSetting& operator=(const PlayerSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSetting& default_instance();

  void Swap(PlayerSetting* other);

  // implements Message ----------------------------------------------

  PlayerSetting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSetting& from);
  void MergeFrom(const PlayerSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool music = 1 [default = true];
  inline bool has_music() const;
  inline void clear_music();
  static const int kMusicFieldNumber = 1;
  inline bool music() const;
  inline void set_music(bool value);

  // optional bool voice = 2 [default = true];
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 2;
  inline bool voice() const;
  inline void set_voice(bool value);

  // optional bool audio = 3 [default = true];
  inline bool has_audio() const;
  inline void clear_audio();
  static const int kAudioFieldNumber = 3;
  inline bool audio() const;
  inline void set_audio(bool value);

  // optional bool click_push = 4;
  inline bool has_click_push() const;
  inline void clear_click_push();
  static const int kClickPushFieldNumber = 4;
  inline bool click_push() const;
  inline void set_click_push(bool value);

  // optional .Adoter.Asset.ZHUOBU_TYPE zhuobu_type = 5;
  inline bool has_zhuobu_type() const;
  inline void clear_zhuobu_type();
  static const int kZhuobuTypeFieldNumber = 5;
  inline ::Adoter::Asset::ZHUOBU_TYPE zhuobu_type() const;
  inline void set_zhuobu_type(::Adoter::Asset::ZHUOBU_TYPE value);

  // optional .Adoter.Asset.CARD_COLOR_TYPE card_color_type = 6;
  inline bool has_card_color_type() const;
  inline void clear_card_color_type();
  static const int kCardColorTypeFieldNumber = 6;
  inline ::Adoter::Asset::CARD_COLOR_TYPE card_color_type() const;
  inline void set_card_color_type(::Adoter::Asset::CARD_COLOR_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerSetting)
 private:
  inline void set_has_music();
  inline void clear_has_music();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_audio();
  inline void clear_has_audio();
  inline void set_has_click_push();
  inline void clear_has_click_push();
  inline void set_has_zhuobu_type();
  inline void clear_has_zhuobu_type();
  inline void set_has_card_color_type();
  inline void clear_has_card_color_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool music_;
  bool voice_;
  bool audio_;
  bool click_push_;
  int zhuobu_type_;
  int card_color_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerSetting* default_instance_;
};
// -------------------------------------------------------------------

class GameSetting : public ::google::protobuf::Message {
 public:
  GameSetting();
  virtual ~GameSetting();

  GameSetting(const GameSetting& from);

  inline GameSetting& operator=(const GameSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSetting& default_instance();

  void Swap(GameSetting* other);

  // implements Message ----------------------------------------------

  GameSetting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameSetting& from);
  void MergeFrom(const GameSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_SETTING];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PlayerSetting game_setting = 2;
  inline bool has_game_setting() const;
  inline void clear_game_setting();
  static const int kGameSettingFieldNumber = 2;
  inline const ::Adoter::Asset::PlayerSetting& game_setting() const;
  inline ::Adoter::Asset::PlayerSetting* mutable_game_setting();
  inline ::Adoter::Asset::PlayerSetting* release_game_setting();
  inline void set_allocated_game_setting(::Adoter::Asset::PlayerSetting* game_setting);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameSetting)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_game_setting();
  inline void clear_has_game_setting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::PlayerSetting* game_setting_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameSetting* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistory : public ::google::protobuf::Message {
 public:
  BattleHistory();
  virtual ~BattleHistory();

  BattleHistory(const BattleHistory& from);

  inline BattleHistory& operator=(const BattleHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistory& default_instance();

  void Swap(BattleHistory* other);

  // implements Message ----------------------------------------------

  BattleHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistory& from);
  void MergeFrom(const BattleHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ROOM_HISTORY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::int32 start_index() const;
  inline void set_start_index(::google::protobuf::int32 value);

  // optional int32 end_index = 3;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 3;
  inline ::google::protobuf::int32 end_index() const;
  inline void set_end_index(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.RoomHistory history_list = 4;
  inline int history_list_size() const;
  inline void clear_history_list();
  static const int kHistoryListFieldNumber = 4;
  inline const ::Adoter::Asset::RoomHistory& history_list(int index) const;
  inline ::Adoter::Asset::RoomHistory* mutable_history_list(int index);
  inline ::Adoter::Asset::RoomHistory* add_history_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomHistory >&
      history_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomHistory >*
      mutable_history_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.BattleHistory)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  ::google::protobuf::int32 start_index_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomHistory > history_list_;
  ::google::protobuf::int32 end_index_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static BattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class UserRecharge : public ::google::protobuf::Message {
 public:
  UserRecharge();
  virtual ~UserRecharge();

  UserRecharge(const UserRecharge& from);

  inline UserRecharge& operator=(const UserRecharge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRecharge& default_instance();

  void Swap(UserRecharge* other);

  // implements Message ----------------------------------------------

  UserRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserRecharge& from);
  void MergeFrom(const UserRecharge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_RECHARGE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.RECHARGE_TYPE recharge_type = 2;
  inline bool has_recharge_type() const;
  inline void clear_recharge_type();
  static const int kRechargeTypeFieldNumber = 2;
  inline ::Adoter::Asset::RECHARGE_TYPE recharge_type() const;
  inline void set_recharge_type(::Adoter::Asset::RECHARGE_TYPE value);

  // optional bytes product_id = 3;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 3;
  inline const ::std::string& product_id() const;
  inline void set_product_id(const ::std::string& value);
  inline void set_product_id(const char* value);
  inline void set_product_id(const void* value, size_t size);
  inline ::std::string* mutable_product_id();
  inline ::std::string* release_product_id();
  inline void set_allocated_product_id(::std::string* product_id);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.UserRecharge)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_recharge_type();
  inline void clear_has_recharge_type();
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int recharge_type_;
  ::std::string* product_id_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserRecharge* default_instance_;
};
// -------------------------------------------------------------------

class PlayBack_PlayerElement : public ::google::protobuf::Message {
 public:
  PlayBack_PlayerElement();
  virtual ~PlayBack_PlayerElement();

  PlayBack_PlayerElement(const PlayBack_PlayerElement& from);

  inline PlayBack_PlayerElement& operator=(const PlayBack_PlayerElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayBack_PlayerElement& default_instance();

  void Swap(PlayBack_PlayerElement* other);

  // implements Message ----------------------------------------------

  PlayBack_PlayerElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayBack_PlayerElement& from);
  void MergeFrom(const PlayBack_PlayerElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.POSITION_TYPE position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional .Adoter.Asset.CommonProp common_prop = 3;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 3;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // optional .Adoter.Asset.WechatUnion wechat = 4;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 4;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // repeated .Adoter.Asset.MultiplePai pai_list = 5;
  inline int pai_list_size() const;
  inline void clear_pai_list();
  static const int kPaiListFieldNumber = 5;
  inline const ::Adoter::Asset::MultiplePai& pai_list(int index) const;
  inline ::Adoter::Asset::MultiplePai* mutable_pai_list(int index);
  inline ::Adoter::Asset::MultiplePai* add_pai_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
      pai_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
      mutable_pai_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayBack.PlayerElement)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_wechat();
  inline void clear_has_wechat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::Adoter::Asset::CommonProp* common_prop_;
  ::Adoter::Asset::WechatUnion* wechat_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai > pai_list_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayBack_PlayerElement* default_instance_;
};
// -------------------------------------------------------------------

class PlayBack : public ::google::protobuf::Message {
 public:
  PlayBack();
  virtual ~PlayBack();

  PlayBack(const PlayBack& from);

  inline PlayBack& operator=(const PlayBack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayBack& default_instance();

  void Swap(PlayBack* other);

  // implements Message ----------------------------------------------

  PlayBack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayBack& from);
  void MergeFrom(const PlayBack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayBack_PlayerElement PlayerElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PLAY_BACK];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.RoomOptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline const ::Adoter::Asset::RoomOptions& options() const;
  inline ::Adoter::Asset::RoomOptions* mutable_options();
  inline ::Adoter::Asset::RoomOptions* release_options();
  inline void set_allocated_options(::Adoter::Asset::RoomOptions* options);

  // optional int32 game_index = 4;
  inline bool has_game_index() const;
  inline void clear_game_index();
  static const int kGameIndexFieldNumber = 4;
  inline ::google::protobuf::int32 game_index() const;
  inline void set_game_index(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.PlayBack.PlayerElement player_list = 5;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 5;
  inline const ::Adoter::Asset::PlayBack_PlayerElement& player_list(int index) const;
  inline ::Adoter::Asset::PlayBack_PlayerElement* mutable_player_list(int index);
  inline ::Adoter::Asset::PlayBack_PlayerElement* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayBack_PlayerElement >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayBack_PlayerElement >*
      mutable_player_list();

  // repeated .Adoter.Asset.PaiOperation oper_list = 6;
  inline int oper_list_size() const;
  inline void clear_oper_list();
  static const int kOperListFieldNumber = 6;
  inline const ::Adoter::Asset::PaiOperation& oper_list(int index) const;
  inline ::Adoter::Asset::PaiOperation* mutable_oper_list(int index);
  inline ::Adoter::Asset::PaiOperation* add_oper_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperation >&
      oper_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperation >*
      mutable_oper_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayBack)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_game_index();
  inline void clear_has_game_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int type_t_;
  ::google::protobuf::int32 game_index_;
  ::Adoter::Asset::RoomOptions* options_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayBack_PlayerElement > player_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperation > oper_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayBack* default_instance_;
};
// -------------------------------------------------------------------

class GetReward : public ::google::protobuf::Message {
 public:
  GetReward();
  virtual ~GetReward();

  GetReward(const GetReward& from);

  inline GetReward& operator=(const GetReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetReward& default_instance();

  void Swap(GetReward* other);

  // implements Message ----------------------------------------------

  GetReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetReward& from);
  void MergeFrom(const GetReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetReward_GET_REWARD_REASON GET_REWARD_REASON;
  static const GET_REWARD_REASON GET_REWARD_REASON_DAILY_BONUS = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS;
  static const GET_REWARD_REASON GET_REWARD_REASON_DAILY_ALLOWANCE = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_ALLOWANCE;
  static const GET_REWARD_REASON GET_REWARD_REASON_SHARED = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_SHARED;
  static inline bool GET_REWARD_REASON_IsValid(int value) {
    return GetReward_GET_REWARD_REASON_IsValid(value);
  }
  static const GET_REWARD_REASON GET_REWARD_REASON_MIN =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MIN;
  static const GET_REWARD_REASON GET_REWARD_REASON_MAX =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX;
  static const int GET_REWARD_REASON_ARRAYSIZE =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GET_REWARD_REASON_descriptor() {
    return GetReward_GET_REWARD_REASON_descriptor();
  }
  static inline const ::std::string& GET_REWARD_REASON_Name(GET_REWARD_REASON value) {
    return GetReward_GET_REWARD_REASON_Name(value);
  }
  static inline bool GET_REWARD_REASON_Parse(const ::std::string& name,
      GET_REWARD_REASON* value) {
    return GetReward_GET_REWARD_REASON_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_REWARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.GetReward.GET_REWARD_REASON reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::Adoter::Asset::GetReward_GET_REWARD_REASON reason() const;
  inline void set_reason(::Adoter::Asset::GetReward_GET_REWARD_REASON value);

  // optional int64 reward_id = 3;
  inline bool has_reward_id() const;
  inline void clear_reward_id();
  static const int kRewardIdFieldNumber = 3;
  inline ::google::protobuf::int64 reward_id() const;
  inline void set_reward_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GetReward)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_reward_id();
  inline void clear_has_reward_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_;
  ::google::protobuf::int64 reward_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetReward* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationCache : public ::google::protobuf::Message {
 public:
  PaiOperationCache();
  virtual ~PaiOperationCache();

  PaiOperationCache(const PaiOperationCache& from);

  inline PaiOperationCache& operator=(const PaiOperationCache& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationCache& default_instance();

  void Swap(PaiOperationCache* other);

  // implements Message ----------------------------------------------

  PaiOperationCache* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationCache& from);
  void MergeFrom(const PaiOperationCache& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int64 source_player_id = 2;
  inline bool has_source_player_id() const;
  inline void clear_source_player_id();
  static const int kSourcePlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 source_player_id() const;
  inline void set_source_player_id(::google::protobuf::int64 value);

  // optional int32 time_out = 3;
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 3;
  inline ::google::protobuf::int32 time_out() const;
  inline void set_time_out(::google::protobuf::int32 value);

  // optional .Adoter.Asset.PaiElement pai = 4;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // repeated .Adoter.Asset.PAI_OPER_TYPE oper_list = 5;
  inline int oper_list_size() const;
  inline void clear_oper_list();
  static const int kOperListFieldNumber = 5;
  inline ::Adoter::Asset::PAI_OPER_TYPE oper_list(int index) const;
  inline void set_oper_list(int index, ::Adoter::Asset::PAI_OPER_TYPE value);
  inline void add_oper_list(::Adoter::Asset::PAI_OPER_TYPE value);
  inline const ::google::protobuf::RepeatedField<int>& oper_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_oper_list();

  // repeated .Adoter.Asset.PaiElement ting_pais = 6;
  inline int ting_pais_size() const;
  inline void clear_ting_pais();
  static const int kTingPaisFieldNumber = 6;
  inline const ::Adoter::Asset::PaiElement& ting_pais(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_ting_pais(int index);
  inline ::Adoter::Asset::PaiElement* add_ting_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      ting_pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_ting_pais();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationCache)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_source_player_id();
  inline void clear_has_source_player_id();
  inline void set_has_time_out();
  inline void clear_has_time_out();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::google::protobuf::int64 source_player_id_;
  ::Adoter::Asset::PaiElement* pai_;
  ::google::protobuf::RepeatedField<int> oper_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > ting_pais_;
  ::google::protobuf::int32 time_out_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationCache* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperation : public ::google::protobuf::Message {
 public:
  PaiOperation();
  virtual ~PaiOperation();

  PaiOperation(const PaiOperation& from);

  inline PaiOperation& operator=(const PaiOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperation& default_instance();

  void Swap(PaiOperation* other);

  // implements Message ----------------------------------------------

  PaiOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperation& from);
  void MergeFrom(const PaiOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PAI_OPERATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PAI_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::PAI_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::PAI_OPER_TYPE value);

  // optional .Adoter.Asset.POSITION_TYPE position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // repeated .Adoter.Asset.PaiElement pais = 4;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pais(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pais(int index);
  inline ::Adoter::Asset::PaiElement* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pais();

  // optional .Adoter.Asset.PaiElement pai = 5;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 5;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pais_;
  ::Adoter::Asset::PaiElement* pai_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperation* default_instance_;
};
// -------------------------------------------------------------------

class GameOperation : public ::google::protobuf::Message {
 public:
  GameOperation();
  virtual ~GameOperation();

  GameOperation(const GameOperation& from);

  inline GameOperation& operator=(const GameOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameOperation& default_instance();

  void Swap(GameOperation* other);

  // implements Message ----------------------------------------------

  GameOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameOperation& from);
  void MergeFrom(const GameOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_OPERATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // optional int64 source_player_id = 3;
  inline bool has_source_player_id() const;
  inline void clear_source_player_id();
  static const int kSourcePlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 source_player_id() const;
  inline void set_source_player_id(::google::protobuf::int64 value);

  // optional int64 destination_player_id = 4;
  inline bool has_destination_player_id() const;
  inline void clear_destination_player_id();
  static const int kDestinationPlayerIdFieldNumber = 4;
  inline ::google::protobuf::int64 destination_player_id() const;
  inline void set_destination_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ERROR_CODE error_code = 5;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 5;
  inline ::Adoter::Asset::ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::ERROR_CODE value);

  // optional int32 beilv = 6;
  inline bool has_beilv() const;
  inline void clear_beilv();
  static const int kBeilvFieldNumber = 6;
  inline ::google::protobuf::int32 beilv() const;
  inline void set_beilv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameOperation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_source_player_id();
  inline void clear_has_source_player_id();
  inline void set_has_destination_player_id();
  inline void clear_has_destination_player_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_beilv();
  inline void clear_has_beilv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  ::google::protobuf::int64 source_player_id_;
  ::google::protobuf::int64 destination_player_id_;
  int error_code_;
  ::google::protobuf::int32 beilv_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameOperation* default_instance_;
};
// -------------------------------------------------------------------

class BuySomething : public ::google::protobuf::Message {
 public:
  BuySomething();
  virtual ~BuySomething();

  BuySomething(const BuySomething& from);

  inline BuySomething& operator=(const BuySomething& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuySomething& default_instance();

  void Swap(BuySomething* other);

  // implements Message ----------------------------------------------

  BuySomething* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuySomething& from);
  void MergeFrom(const BuySomething& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_BUY_SOMETHING];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 mall_id = 2;
  inline bool has_mall_id() const;
  inline void clear_mall_id();
  static const int kMallIdFieldNumber = 2;
  inline ::google::protobuf::int64 mall_id() const;
  inline void set_mall_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ERROR_CODE result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::Adoter::Asset::ERROR_CODE result() const;
  inline void set_result(::Adoter::Asset::ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.BuySomething)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_mall_id();
  inline void clear_has_mall_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 mall_id_;
  int type_t_;
  int result_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static BuySomething* default_instance_;
};
// -------------------------------------------------------------------

class LoadScene : public ::google::protobuf::Message {
 public:
  LoadScene();
  virtual ~LoadScene();

  LoadScene(const LoadScene& from);

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadScene& default_instance();

  void Swap(LoadScene* other);

  // implements Message ----------------------------------------------

  LoadScene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadScene& from);
  void MergeFrom(const LoadScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOAD_SCENE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 2;
  inline bool has_load_type() const;
  inline void clear_load_type();
  static const int kLoadTypeFieldNumber = 2;
  inline ::Adoter::Asset::LOAD_SCENE_TYPE load_type() const;
  inline void set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value);

  // optional int64 scene_id = 3;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 3;
  inline ::google::protobuf::int64 scene_id() const;
  inline void set_scene_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LoadScene)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_load_type();
  inline void clear_has_load_type();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int load_type_;
  ::google::protobuf::int64 scene_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoadScene* default_instance_;
};
// -------------------------------------------------------------------

class ReConnect : public ::google::protobuf::Message {
 public:
  ReConnect();
  virtual ~ReConnect();

  ReConnect(const ReConnect& from);

  inline ReConnect& operator=(const ReConnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReConnect& default_instance();

  void Swap(ReConnect* other);

  // implements Message ----------------------------------------------

  ReConnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReConnect& from);
  void MergeFrom(const ReConnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_RECONNECT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.Account account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::Adoter::Asset::Account& account() const;
  inline ::Adoter::Asset::Account* mutable_account();
  inline ::Adoter::Asset::Account* release_account();
  inline void set_allocated_account(::Adoter::Asset::Account* account);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ReConnect)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::Adoter::Asset::Account* account_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ReConnect* default_instance_;
};
// -------------------------------------------------------------------

class MatchStats_MatchingRoom : public ::google::protobuf::Message {
 public:
  MatchStats_MatchingRoom();
  virtual ~MatchStats_MatchingRoom();

  MatchStats_MatchingRoom(const MatchStats_MatchingRoom& from);

  inline MatchStats_MatchingRoom& operator=(const MatchStats_MatchingRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStats_MatchingRoom& default_instance();

  void Swap(MatchStats_MatchingRoom* other);

  // implements Message ----------------------------------------------

  MatchStats_MatchingRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStats_MatchingRoom& from);
  void MergeFrom(const MatchStats_MatchingRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ROOM_TYPE room_type = 1;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 1;
  inline ::Adoter::Asset::ROOM_TYPE room_type() const;
  inline void set_room_type(::Adoter::Asset::ROOM_TYPE value);

  // optional int32 player_count = 2;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 2;
  inline ::google::protobuf::int32 player_count() const;
  inline void set_player_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MatchStats.MatchingRoom)
 private:
  inline void set_has_room_type();
  inline void clear_has_room_type();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int room_type_;
  ::google::protobuf::int32 player_count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static MatchStats_MatchingRoom* default_instance_;
};
// -------------------------------------------------------------------

class MatchStats : public ::google::protobuf::Message {
 public:
  MatchStats();
  virtual ~MatchStats();

  MatchStats(const MatchStats& from);

  inline MatchStats& operator=(const MatchStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStats& default_instance();

  void Swap(MatchStats* other);

  // implements Message ----------------------------------------------

  MatchStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStats& from);
  void MergeFrom(const MatchStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MatchStats_MatchingRoom MatchingRoom;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_MATCHING_STATS];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.MatchStats.MatchingRoom room_list = 2;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 2;
  inline const ::Adoter::Asset::MatchStats_MatchingRoom& room_list(int index) const;
  inline ::Adoter::Asset::MatchStats_MatchingRoom* mutable_room_list(int index);
  inline ::Adoter::Asset::MatchStats_MatchingRoom* add_room_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStats_MatchingRoom >&
      room_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStats_MatchingRoom >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MatchStats)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStats_MatchingRoom > room_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static MatchStats* default_instance_;
};
// -------------------------------------------------------------------

class ClanOperation : public ::google::protobuf::Message {
 public:
  ClanOperation();
  virtual ~ClanOperation();

  ClanOperation(const ClanOperation& from);

  inline ClanOperation& operator=(const ClanOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanOperation& default_instance();

  void Swap(ClanOperation* other);

  // implements Message ----------------------------------------------

  ClanOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanOperation& from);
  void MergeFrom(const ClanOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CLAN_OPERATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CLAN_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::CLAN_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::CLAN_OPER_TYPE value);

  // optional int64 clan_id = 3;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 3;
  inline ::google::protobuf::int64 clan_id() const;
  inline void set_clan_id(::google::protobuf::int64 value);

  // optional int32 oper_result = 4;
  inline bool has_oper_result() const;
  inline void clear_oper_result();
  static const int kOperResultFieldNumber = 4;
  inline ::google::protobuf::int32 oper_result() const;
  inline void set_oper_result(::google::protobuf::int32 value);

  // optional bytes name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes announcement = 6;
  inline bool has_announcement() const;
  inline void clear_announcement();
  static const int kAnnouncementFieldNumber = 6;
  inline const ::std::string& announcement() const;
  inline void set_announcement(const ::std::string& value);
  inline void set_announcement(const char* value);
  inline void set_announcement(const void* value, size_t size);
  inline ::std::string* mutable_announcement();
  inline ::std::string* release_announcement();
  inline void set_allocated_announcement(::std::string* announcement);

  // optional int64 dest_player_id = 7;
  inline bool has_dest_player_id() const;
  inline void clear_dest_player_id();
  static const int kDestPlayerIdFieldNumber = 7;
  inline ::google::protobuf::int64 dest_player_id() const;
  inline void set_dest_player_id(::google::protobuf::int64 value);

  // optional int32 recharge_count = 8;
  inline bool has_recharge_count() const;
  inline void clear_recharge_count();
  static const int kRechargeCountFieldNumber = 8;
  inline ::google::protobuf::int32 recharge_count() const;
  inline void set_recharge_count(::google::protobuf::int32 value);

  // optional .Adoter.Asset.Clan clan = 9;
  inline bool has_clan() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 9;
  inline const ::Adoter::Asset::Clan& clan() const;
  inline ::Adoter::Asset::Clan* mutable_clan();
  inline ::Adoter::Asset::Clan* release_clan();
  inline void set_allocated_clan(::Adoter::Asset::Clan* clan);

  // optional int32 room_query_start_index = 10;
  inline bool has_room_query_start_index() const;
  inline void clear_room_query_start_index();
  static const int kRoomQueryStartIndexFieldNumber = 10;
  inline ::google::protobuf::int32 room_query_start_index() const;
  inline void set_room_query_start_index(::google::protobuf::int32 value);

  // optional int32 room_query_end_index = 11;
  inline bool has_room_query_end_index() const;
  inline void clear_room_query_end_index();
  static const int kRoomQueryEndIndexFieldNumber = 11;
  inline ::google::protobuf::int32 room_query_end_index() const;
  inline void set_room_query_end_index(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.RoomQueryResult room_list = 12;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 12;
  inline const ::Adoter::Asset::RoomQueryResult& room_list(int index) const;
  inline ::Adoter::Asset::RoomQueryResult* mutable_room_list(int index);
  inline ::Adoter::Asset::RoomQueryResult* add_room_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomQueryResult >&
      room_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomQueryResult >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ClanOperation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_oper_result();
  inline void clear_has_oper_result();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_announcement();
  inline void clear_has_announcement();
  inline void set_has_dest_player_id();
  inline void clear_has_dest_player_id();
  inline void set_has_recharge_count();
  inline void clear_has_recharge_count();
  inline void set_has_clan();
  inline void clear_has_clan();
  inline void set_has_room_query_start_index();
  inline void clear_has_room_query_start_index();
  inline void set_has_room_query_end_index();
  inline void clear_has_room_query_end_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  ::google::protobuf::int64 clan_id_;
  ::std::string* name_;
  ::std::string* announcement_;
  ::google::protobuf::int32 oper_result_;
  ::google::protobuf::int32 recharge_count_;
  ::google::protobuf::int64 dest_player_id_;
  ::Adoter::Asset::Clan* clan_;
  ::google::protobuf::int32 room_query_start_index_;
  ::google::protobuf::int32 room_query_end_index_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomQueryResult > room_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClanOperation* default_instance_;
};
// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  void Swap(PlayerList* other);

  // implements Message ----------------------------------------------

  PlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYERS];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated int64 player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline ::google::protobuf::int64 player_list(int index) const;
  inline void set_player_list(int index, ::google::protobuf::int64 value);
  inline void add_player_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      player_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_player_list();

  // optional .Adoter.Asset.WechatUnion wechat = 3;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 3;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerList)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_wechat();
  inline void clear_has_wechat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > player_list_;
  ::Adoter::Asset::WechatUnion* wechat_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInformation : public ::google::protobuf::Message {
 public:
  PlayerInformation();
  virtual ~PlayerInformation();

  PlayerInformation(const PlayerInformation& from);

  inline PlayerInformation& operator=(const PlayerInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInformation& default_instance();

  void Swap(PlayerInformation* other);

  // implements Message ----------------------------------------------

  PlayerInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInformation& from);
  void MergeFrom(const PlayerInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYER_INFO];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Player player = 2;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::Adoter::Asset::Player& player() const;
  inline ::Adoter::Asset::Player* mutable_player();
  inline ::Adoter::Asset::Player* release_player();
  inline void set_allocated_player(::Adoter::Asset::Player* player);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerInformation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player();
  inline void clear_has_player();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Player* player_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerInformation* default_instance_;
};
// -------------------------------------------------------------------

class AlertMessage : public ::google::protobuf::Message {
 public:
  AlertMessage();
  virtual ~AlertMessage();

  AlertMessage(const AlertMessage& from);

  inline AlertMessage& operator=(const AlertMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertMessage& default_instance();

  void Swap(AlertMessage* other);

  // implements Message ----------------------------------------------

  AlertMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertMessage& from);
  void MergeFrom(const AlertMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ALERT_ERROR];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.ERROR_TYPE error_type = 2;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 2;
  inline ::Adoter::Asset::ERROR_TYPE error_type() const;
  inline void set_error_type(::Adoter::Asset::ERROR_TYPE value);

  // optional .Adoter.Asset.ERROR_SHOW_TYPE error_show_type = 3;
  inline bool has_error_show_type() const;
  inline void clear_error_show_type();
  static const int kErrorShowTypeFieldNumber = 3;
  inline ::Adoter::Asset::ERROR_SHOW_TYPE error_show_type() const;
  inline void set_error_show_type(::Adoter::Asset::ERROR_SHOW_TYPE value);

  // optional int32 error_code = 4;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.AlertMessage)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_error_show_type();
  inline void clear_has_error_show_type();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_type_;
  int error_show_type_;
  ::google::protobuf::int32 error_code_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static AlertMessage* default_instance_;
};
// -------------------------------------------------------------------

class LiuJu_LJElement : public ::google::protobuf::Message {
 public:
  LiuJu_LJElement();
  virtual ~LiuJu_LJElement();

  LiuJu_LJElement(const LiuJu_LJElement& from);

  inline LiuJu_LJElement& operator=(const LiuJu_LJElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LiuJu_LJElement& default_instance();

  void Swap(LiuJu_LJElement* other);

  // implements Message ----------------------------------------------

  LiuJu_LJElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LiuJu_LJElement& from);
  void MergeFrom(const LiuJu_LJElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.PaiElement pai = 3;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 3;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LiuJu.LJElement)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::Adoter::Asset::PaiElement* pai_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static LiuJu_LJElement* default_instance_;
};
// -------------------------------------------------------------------

class LiuJu : public ::google::protobuf::Message {
 public:
  LiuJu();
  virtual ~LiuJu();

  LiuJu(const LiuJu& from);

  inline LiuJu& operator=(const LiuJu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LiuJu& default_instance();

  void Swap(LiuJu* other);

  // implements Message ----------------------------------------------

  LiuJu* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LiuJu& from);
  void MergeFrom(const LiuJu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LiuJu_LJElement LJElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_LIUJU];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.LiuJu.LJElement elements = 2;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 2;
  inline const ::Adoter::Asset::LiuJu_LJElement& elements(int index) const;
  inline ::Adoter::Asset::LiuJu_LJElement* mutable_elements(int index);
  inline ::Adoter::Asset::LiuJu_LJElement* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LiuJu_LJElement >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LiuJu_LJElement >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LiuJu)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LiuJu_LJElement > elements_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static LiuJu* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify_MutiPai : public ::google::protobuf::Message {
 public:
  PaiNotify_MutiPai();
  virtual ~PaiNotify_MutiPai();

  PaiNotify_MutiPai(const PaiNotify_MutiPai& from);

  inline PaiNotify_MutiPai& operator=(const PaiNotify_MutiPai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify_MutiPai& default_instance();

  void Swap(PaiNotify_MutiPai* other);

  // implements Message ----------------------------------------------

  PaiNotify_MutiPai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify_MutiPai& from);
  void MergeFrom(const PaiNotify_MutiPai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // repeated int32 cards = 2;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline ::google::protobuf::int32 cards(int index) const;
  inline void set_cards(int index, ::google::protobuf::int32 value);
  inline void add_cards(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cards();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify.MutiPai)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cards_;
  int card_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify_MutiPai* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify_SinglePai : public ::google::protobuf::Message {
 public:
  PaiNotify_SinglePai();
  virtual ~PaiNotify_SinglePai();

  PaiNotify_SinglePai(const PaiNotify_SinglePai& from);

  inline PaiNotify_SinglePai& operator=(const PaiNotify_SinglePai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify_SinglePai& default_instance();

  void Swap(PaiNotify_SinglePai* other);

  // implements Message ----------------------------------------------

  PaiNotify_SinglePai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify_SinglePai& from);
  void MergeFrom(const PaiNotify_SinglePai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // optional int32 card_value = 2;
  inline bool has_card_value() const;
  inline void clear_card_value();
  static const int kCardValueFieldNumber = 2;
  inline ::google::protobuf::int32 card_value() const;
  inline void set_card_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify.SinglePai)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_card_value();
  inline void clear_has_card_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int card_type_;
  ::google::protobuf::int32 card_value_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify_SinglePai* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify : public ::google::protobuf::Message {
 public:
  PaiNotify();
  virtual ~PaiNotify();

  PaiNotify(const PaiNotify& from);

  inline PaiNotify& operator=(const PaiNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify& default_instance();

  void Swap(PaiNotify* other);

  // implements Message ----------------------------------------------

  PaiNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify& from);
  void MergeFrom(const PaiNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PaiNotify_MutiPai MutiPai;
  typedef PaiNotify_SinglePai SinglePai;

  typedef PaiNotify_CARDS_DATA_TYPE CARDS_DATA_TYPE;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_START = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_FAPAI = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_FAPAI;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_SYNC = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC;
  static inline bool CARDS_DATA_TYPE_IsValid(int value) {
    return PaiNotify_CARDS_DATA_TYPE_IsValid(value);
  }
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_MIN =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MIN;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_MAX =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX;
  static const int CARDS_DATA_TYPE_ARRAYSIZE =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CARDS_DATA_TYPE_descriptor() {
    return PaiNotify_CARDS_DATA_TYPE_descriptor();
  }
  static inline const ::std::string& CARDS_DATA_TYPE_Name(CARDS_DATA_TYPE value) {
    return PaiNotify_CARDS_DATA_TYPE_Name(value);
  }
  static inline bool CARDS_DATA_TYPE_Parse(const ::std::string& name,
      CARDS_DATA_TYPE* value) {
    return PaiNotify_CARDS_DATA_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_NOTIFY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.PaiNotify.CARDS_DATA_TYPE data_type = 3;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  inline ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE data_type() const;
  inline void set_data_type(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE value);

  // repeated .Adoter.Asset.PaiNotify.MutiPai pais = 4;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 4;
  inline const ::Adoter::Asset::PaiNotify_MutiPai& pais(int index) const;
  inline ::Adoter::Asset::PaiNotify_MutiPai* mutable_pais(int index);
  inline ::Adoter::Asset::PaiNotify_MutiPai* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >*
      mutable_pais();

  // optional .Adoter.Asset.PaiNotify.SinglePai pai = 5;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 5;
  inline const ::Adoter::Asset::PaiNotify_SinglePai& pai() const;
  inline ::Adoter::Asset::PaiNotify_SinglePai* mutable_pai();
  inline ::Adoter::Asset::PaiNotify_SinglePai* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiNotify_SinglePai* pai);

  // optional int32 cards_remain = 6;
  inline bool has_cards_remain() const;
  inline void clear_cards_remain();
  static const int kCardsRemainFieldNumber = 6;
  inline ::google::protobuf::int32 cards_remain() const;
  inline void set_cards_remain(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_pai();
  inline void clear_has_pai();
  inline void set_has_cards_remain();
  inline void clear_has_cards_remain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  int data_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai > pais_;
  ::Adoter::Asset::PaiNotify_SinglePai* pai_;
  ::google::protobuf::int32 cards_remain_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify* default_instance_;
};
// -------------------------------------------------------------------

class SyncCommonProperty : public ::google::protobuf::Message {
 public:
  SyncCommonProperty();
  virtual ~SyncCommonProperty();

  SyncCommonProperty(const SyncCommonProperty& from);

  inline SyncCommonProperty& operator=(const SyncCommonProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCommonProperty& default_instance();

  void Swap(SyncCommonProperty* other);

  // implements Message ----------------------------------------------

  SyncCommonProperty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncCommonProperty& from);
  void MergeFrom(const SyncCommonProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SyncCommonProperty_SYNC_REASON_TYPE SYNC_REASON_TYPE;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_SELF = SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_GET = SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_GET;
  static inline bool SYNC_REASON_TYPE_IsValid(int value) {
    return SyncCommonProperty_SYNC_REASON_TYPE_IsValid(value);
  }
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_MIN =
    SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MIN;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_MAX =
    SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX;
  static const int SYNC_REASON_TYPE_ARRAYSIZE =
    SyncCommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SYNC_REASON_TYPE_descriptor() {
    return SyncCommonProperty_SYNC_REASON_TYPE_descriptor();
  }
  static inline const ::std::string& SYNC_REASON_TYPE_Name(SYNC_REASON_TYPE value) {
    return SyncCommonProperty_SYNC_REASON_TYPE_Name(value);
  }
  static inline bool SYNC_REASON_TYPE_Parse(const ::std::string& name,
      SYNC_REASON_TYPE* value) {
    return SyncCommonProperty_SYNC_REASON_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_COMMON_PROPERTY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.SyncCommonProperty.SYNC_REASON_TYPE reason_type = 2;
  inline bool has_reason_type() const;
  inline void clear_reason_type();
  static const int kReasonTypeFieldNumber = 2;
  inline ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE reason_type() const;
  inline void set_reason_type(::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE value);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.CommonProp common_prop = 4;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 4;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncCommonProperty)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason_type();
  inline void clear_has_reason_type();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_type_;
  ::google::protobuf::int64 player_id_;
  ::Adoter::Asset::CommonProp* common_prop_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncCommonProperty* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationAlert_AlertElement : public ::google::protobuf::Message {
 public:
  PaiOperationAlert_AlertElement();
  virtual ~PaiOperationAlert_AlertElement();

  PaiOperationAlert_AlertElement(const PaiOperationAlert_AlertElement& from);

  inline PaiOperationAlert_AlertElement& operator=(const PaiOperationAlert_AlertElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationAlert_AlertElement& default_instance();

  void Swap(PaiOperationAlert_AlertElement* other);

  // implements Message ----------------------------------------------

  PaiOperationAlert_AlertElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationAlert_AlertElement& from);
  void MergeFrom(const PaiOperationAlert_AlertElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.PaiElement pai = 1;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 1;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // repeated .Adoter.Asset.PAI_OPER_TYPE oper_list = 2;
  inline int oper_list_size() const;
  inline void clear_oper_list();
  static const int kOperListFieldNumber = 2;
  inline ::Adoter::Asset::PAI_OPER_TYPE oper_list(int index) const;
  inline void set_oper_list(int index, ::Adoter::Asset::PAI_OPER_TYPE value);
  inline void add_oper_list(::Adoter::Asset::PAI_OPER_TYPE value);
  inline const ::google::protobuf::RepeatedField<int>& oper_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_oper_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationAlert.AlertElement)
 private:
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::PaiElement* pai_;
  ::google::protobuf::RepeatedField<int> oper_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationAlert_AlertElement* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationAlert : public ::google::protobuf::Message {
 public:
  PaiOperationAlert();
  virtual ~PaiOperationAlert();

  PaiOperationAlert(const PaiOperationAlert& from);

  inline PaiOperationAlert& operator=(const PaiOperationAlert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationAlert& default_instance();

  void Swap(PaiOperationAlert* other);

  // implements Message ----------------------------------------------

  PaiOperationAlert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationAlert& from);
  void MergeFrom(const PaiOperationAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PaiOperationAlert_AlertElement AlertElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_OPERATION_ALERT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.PaiOperationAlert.AlertElement pais = 2;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 2;
  inline const ::Adoter::Asset::PaiOperationAlert_AlertElement& pais(int index) const;
  inline ::Adoter::Asset::PaiOperationAlert_AlertElement* mutable_pais(int index);
  inline ::Adoter::Asset::PaiOperationAlert_AlertElement* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperationAlert_AlertElement >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperationAlert_AlertElement >*
      mutable_pais();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationAlert)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperationAlert_AlertElement > pais_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationAlert* default_instance_;
};
// -------------------------------------------------------------------

class SyncCommonLimit : public ::google::protobuf::Message {
 public:
  SyncCommonLimit();
  virtual ~SyncCommonLimit();

  SyncCommonLimit(const SyncCommonLimit& from);

  inline SyncCommonLimit& operator=(const SyncCommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCommonLimit& default_instance();

  void Swap(SyncCommonLimit* other);

  // implements Message ----------------------------------------------

  SyncCommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncCommonLimit& from);
  void MergeFrom(const SyncCommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_LIMIT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PlayerCommonLimit common_limit = 2;
  inline bool has_common_limit() const;
  inline void clear_common_limit();
  static const int kCommonLimitFieldNumber = 2;
  inline const ::Adoter::Asset::PlayerCommonLimit& common_limit() const;
  inline ::Adoter::Asset::PlayerCommonLimit* mutable_common_limit();
  inline ::Adoter::Asset::PlayerCommonLimit* release_common_limit();
  inline void set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncCommonLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_limit();
  inline void clear_has_common_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::PlayerCommonLimit* common_limit_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncCommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class SyncCommonReward : public ::google::protobuf::Message {
 public:
  SyncCommonReward();
  virtual ~SyncCommonReward();

  SyncCommonReward(const SyncCommonReward& from);

  inline SyncCommonReward& operator=(const SyncCommonReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCommonReward& default_instance();

  void Swap(SyncCommonReward* other);

  // implements Message ----------------------------------------------

  SyncCommonReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncCommonReward& from);
  void MergeFrom(const SyncCommonReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_REWARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 common_reward_id = 2;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 2;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // optional int32 error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncCommonReward)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_reward_id_;
  int type_t_;
  ::google::protobuf::int32 error_code_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncCommonReward* default_instance_;
};
// -------------------------------------------------------------------

class RoomInformation_Player_DistanceElement : public ::google::protobuf::Message {
 public:
  RoomInformation_Player_DistanceElement();
  virtual ~RoomInformation_Player_DistanceElement();

  RoomInformation_Player_DistanceElement(const RoomInformation_Player_DistanceElement& from);

  inline RoomInformation_Player_DistanceElement& operator=(const RoomInformation_Player_DistanceElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation_Player_DistanceElement& default_instance();

  void Swap(RoomInformation_Player_DistanceElement* other);

  // implements Message ----------------------------------------------

  RoomInformation_Player_DistanceElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInformation_Player_DistanceElement& from);
  void MergeFrom(const RoomInformation_Player_DistanceElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.POSITION_TYPE position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional double distance = 2;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 2;
  inline double distance() const;
  inline void set_distance(double value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomInformation.Player.DistanceElement)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_distance();
  inline void clear_has_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double distance_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomInformation_Player_DistanceElement* default_instance_;
};
// -------------------------------------------------------------------

class RoomInformation_Player : public ::google::protobuf::Message {
 public:
  RoomInformation_Player();
  virtual ~RoomInformation_Player();

  RoomInformation_Player(const RoomInformation_Player& from);

  inline RoomInformation_Player& operator=(const RoomInformation_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation_Player& default_instance();

  void Swap(RoomInformation_Player* other);

  // implements Message ----------------------------------------------

  RoomInformation_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInformation_Player& from);
  void MergeFrom(const RoomInformation_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomInformation_Player_DistanceElement DistanceElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.POSITION_TYPE position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 3;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // optional .Adoter.Asset.CommonProp common_prop = 4;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 4;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // optional .Adoter.Asset.WechatUnion wechat = 5;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 5;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // optional bytes ip_address = 6;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 6;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const void* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // repeated .Adoter.Asset.RoomInformation.Player.DistanceElement dis_list = 7;
  inline int dis_list_size() const;
  inline void clear_dis_list();
  static const int kDisListFieldNumber = 7;
  inline const ::Adoter::Asset::RoomInformation_Player_DistanceElement& dis_list(int index) const;
  inline ::Adoter::Asset::RoomInformation_Player_DistanceElement* mutable_dis_list(int index);
  inline ::Adoter::Asset::RoomInformation_Player_DistanceElement* add_dis_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player_DistanceElement >&
      dis_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player_DistanceElement >*
      mutable_dis_list();

  // optional int64 voice_member_id = 8;
  inline bool has_voice_member_id() const;
  inline void clear_voice_member_id();
  static const int kVoiceMemberIdFieldNumber = 8;
  inline ::google::protobuf::int64 voice_member_id() const;
  inline void set_voice_member_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomInformation.Player)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_wechat();
  inline void clear_has_wechat();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_voice_member_id();
  inline void clear_has_voice_member_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int position_;
  int oper_type_;
  ::Adoter::Asset::CommonProp* common_prop_;
  ::Adoter::Asset::WechatUnion* wechat_;
  ::std::string* ip_address_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player_DistanceElement > dis_list_;
  ::google::protobuf::int64 voice_member_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomInformation_Player* default_instance_;
};
// -------------------------------------------------------------------

class RoomInformation : public ::google::protobuf::Message {
 public:
  RoomInformation();
  virtual ~RoomInformation();

  RoomInformation(const RoomInformation& from);

  inline RoomInformation& operator=(const RoomInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation& default_instance();

  void Swap(RoomInformation* other);

  // implements Message ----------------------------------------------

  RoomInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInformation& from);
  void MergeFrom(const RoomInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomInformation_Player Player;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_INFO];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.ROOM_SYNC_TYPE sync_type = 2;
  inline bool has_sync_type() const;
  inline void clear_sync_type();
  static const int kSyncTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROOM_SYNC_TYPE sync_type() const;
  inline void set_sync_type(::Adoter::Asset::ROOM_SYNC_TYPE value);

  // repeated .Adoter.Asset.RoomInformation.Player player_list = 3;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 3;
  inline const ::Adoter::Asset::RoomInformation_Player& player_list(int index) const;
  inline ::Adoter::Asset::RoomInformation_Player* mutable_player_list(int index);
  inline ::Adoter::Asset::RoomInformation_Player* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomInformation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_sync_type();
  inline void clear_has_sync_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int sync_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player > player_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomInformation* default_instance_;
};
// -------------------------------------------------------------------

class GameCalculate : public ::google::protobuf::Message {
 public:
  GameCalculate();
  virtual ~GameCalculate();

  GameCalculate(const GameCalculate& from);

  inline GameCalculate& operator=(const GameCalculate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCalculate& default_instance();

  void Swap(GameCalculate* other);

  // implements Message ----------------------------------------------

  GameCalculate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameCalculate& from);
  void MergeFrom(const GameCalculate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_CALCULATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CALCULATE_TYPE calculte_type = 2;
  inline bool has_calculte_type() const;
  inline void clear_calculte_type();
  static const int kCalculteTypeFieldNumber = 2;
  inline ::Adoter::Asset::CALCULATE_TYPE calculte_type() const;
  inline void set_calculte_type(::Adoter::Asset::CALCULATE_TYPE value);

  // optional .Adoter.Asset.POSITION_TYPE dianpao_player_position = 3;
  inline bool has_dianpao_player_position() const;
  inline void clear_dianpao_player_position();
  static const int kDianpaoPlayerPositionFieldNumber = 3;
  inline ::Adoter::Asset::POSITION_TYPE dianpao_player_position() const;
  inline void set_dianpao_player_position(::Adoter::Asset::POSITION_TYPE value);

  // optional .Adoter.Asset.PaiElement baopai = 4;
  inline bool has_baopai() const;
  inline void clear_baopai();
  static const int kBaopaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& baopai() const;
  inline ::Adoter::Asset::PaiElement* mutable_baopai();
  inline ::Adoter::Asset::PaiElement* release_baopai();
  inline void set_allocated_baopai(::Adoter::Asset::PaiElement* baopai);

  // optional .Adoter.Asset.GameRecord record = 5;
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 5;
  inline const ::Adoter::Asset::GameRecord& record() const;
  inline ::Adoter::Asset::GameRecord* mutable_record();
  inline ::Adoter::Asset::GameRecord* release_record();
  inline void set_allocated_record(::Adoter::Asset::GameRecord* record);

  // optional int32 max_fan_type = 6;
  inline bool has_max_fan_type() const;
  inline void clear_max_fan_type();
  static const int kMaxFanTypeFieldNumber = 6;
  inline ::google::protobuf::int32 max_fan_type() const;
  inline void set_max_fan_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameCalculate)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_calculte_type();
  inline void clear_has_calculte_type();
  inline void set_has_dianpao_player_position();
  inline void clear_has_dianpao_player_position();
  inline void set_has_baopai();
  inline void clear_has_baopai();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_max_fan_type();
  inline void clear_has_max_fan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int calculte_type_;
  ::Adoter::Asset::PaiElement* baopai_;
  int dianpao_player_position_;
  ::google::protobuf::int32 max_fan_type_;
  ::Adoter::Asset::GameRecord* record_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameCalculate* default_instance_;
};
// -------------------------------------------------------------------

class RoomRecord : public ::google::protobuf::Message {
 public:
  RoomRecord();
  virtual ~RoomRecord();

  RoomRecord(const RoomRecord& from);

  inline RoomRecord& operator=(const RoomRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomRecord& default_instance();

  void Swap(RoomRecord* other);

  // implements Message ----------------------------------------------

  RoomRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomRecord& from);
  void MergeFrom(const RoomRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const void* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional bytes headimgurl = 3;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 3;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const void* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // optional int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 pk_count = 5;
  inline bool has_pk_count() const;
  inline void clear_pk_count();
  static const int kPkCountFieldNumber = 5;
  inline ::google::protobuf::int32 pk_count() const;
  inline void set_pk_count(::google::protobuf::int32 value);

  // optional int32 banker_count = 6;
  inline bool has_banker_count() const;
  inline void clear_banker_count();
  static const int kBankerCountFieldNumber = 6;
  inline ::google::protobuf::int32 banker_count() const;
  inline void set_banker_count(::google::protobuf::int32 value);

  // optional int32 win_count = 7;
  inline bool has_win_count() const;
  inline void clear_win_count();
  static const int kWinCountFieldNumber = 7;
  inline ::google::protobuf::int32 win_count() const;
  inline void set_win_count(::google::protobuf::int32 value);

  // optional int32 dianpao_count = 8;
  inline bool has_dianpao_count() const;
  inline void clear_dianpao_count();
  static const int kDianpaoCountFieldNumber = 8;
  inline ::google::protobuf::int32 dianpao_count() const;
  inline void set_dianpao_count(::google::protobuf::int32 value);

  // optional int32 loubao_count = 9;
  inline bool has_loubao_count() const;
  inline void clear_loubao_count();
  static const int kLoubaoCountFieldNumber = 9;
  inline ::google::protobuf::int32 loubao_count() const;
  inline void set_loubao_count(::google::protobuf::int32 value);

  // optional int32 jinbao_count = 10;
  inline bool has_jinbao_count() const;
  inline void clear_jinbao_count();
  static const int kJinbaoCountFieldNumber = 10;
  inline ::google::protobuf::int32 jinbao_count() const;
  inline void set_jinbao_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomRecord)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_pk_count();
  inline void clear_has_pk_count();
  inline void set_has_banker_count();
  inline void clear_has_banker_count();
  inline void set_has_win_count();
  inline void clear_has_win_count();
  inline void set_has_dianpao_count();
  inline void clear_has_dianpao_count();
  inline void set_has_loubao_count();
  inline void clear_has_loubao_count();
  inline void set_has_jinbao_count();
  inline void clear_has_jinbao_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* nickname_;
  ::std::string* headimgurl_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 pk_count_;
  ::google::protobuf::int32 banker_count_;
  ::google::protobuf::int32 win_count_;
  ::google::protobuf::int32 dianpao_count_;
  ::google::protobuf::int32 loubao_count_;
  ::google::protobuf::int32 jinbao_count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomRecord* default_instance_;
};
// -------------------------------------------------------------------

class RoomCalculate : public ::google::protobuf::Message {
 public:
  RoomCalculate();
  virtual ~RoomCalculate();

  RoomCalculate(const RoomCalculate& from);

  inline RoomCalculate& operator=(const RoomCalculate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCalculate& default_instance();

  void Swap(RoomCalculate* other);

  // implements Message ----------------------------------------------

  RoomCalculate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomCalculate& from);
  void MergeFrom(const RoomCalculate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_CALCULATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CALCULATE_TYPE calculte_type = 2;
  inline bool has_calculte_type() const;
  inline void clear_calculte_type();
  static const int kCalculteTypeFieldNumber = 2;
  inline ::Adoter::Asset::CALCULATE_TYPE calculte_type() const;
  inline void set_calculte_type(::Adoter::Asset::CALCULATE_TYPE value);

  // repeated .Adoter.Asset.RoomRecord record = 3;
  inline int record_size() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 3;
  inline const ::Adoter::Asset::RoomRecord& record(int index) const;
  inline ::Adoter::Asset::RoomRecord* mutable_record(int index);
  inline ::Adoter::Asset::RoomRecord* add_record();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomRecord >&
      record() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomRecord >*
      mutable_record();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomCalculate)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_calculte_type();
  inline void clear_has_calculte_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int calculte_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomRecord > record_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomCalculate* default_instance_;
};
// -------------------------------------------------------------------

class GameInformation : public ::google::protobuf::Message {
 public:
  GameInformation();
  virtual ~GameInformation();

  GameInformation(const GameInformation& from);

  inline GameInformation& operator=(const GameInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInformation& default_instance();

  void Swap(GameInformation* other);

  // implements Message ----------------------------------------------

  GameInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInformation& from);
  void MergeFrom(const GameInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_INFO];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 banker_player_id = 2;
  inline bool has_banker_player_id() const;
  inline void clear_banker_player_id();
  static const int kBankerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 banker_player_id() const;
  inline void set_banker_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameInformation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_banker_player_id();
  inline void clear_has_banker_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 banker_player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameInformation* default_instance_;
};
// -------------------------------------------------------------------

class KickOut : public ::google::protobuf::Message {
 public:
  KickOut();
  virtual ~KickOut();

  KickOut(const KickOut& from);

  inline KickOut& operator=(const KickOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickOut& default_instance();

  void Swap(KickOut* other);

  // implements Message ----------------------------------------------

  KickOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickOut& from);
  void MergeFrom(const KickOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_KILL_OUT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.KICK_OUT_REASON reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline ::Adoter::Asset::KICK_OUT_REASON reason() const;
  inline void set_reason(::Adoter::Asset::KICK_OUT_REASON value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.KickOut)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  int reason_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static KickOut* default_instance_;
};
// -------------------------------------------------------------------

class SyncActivity_ActivityElement : public ::google::protobuf::Message {
 public:
  SyncActivity_ActivityElement();
  virtual ~SyncActivity_ActivityElement();

  SyncActivity_ActivityElement(const SyncActivity_ActivityElement& from);

  inline SyncActivity_ActivityElement& operator=(const SyncActivity_ActivityElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncActivity_ActivityElement& default_instance();

  void Swap(SyncActivity_ActivityElement* other);

  // implements Message ----------------------------------------------

  SyncActivity_ActivityElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncActivity_ActivityElement& from);
  void MergeFrom(const SyncActivity_ActivityElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 activity_id = 2;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::int64 activity_id() const;
  inline void set_activity_id(::google::protobuf::int64 value);

  // optional bool open = 3;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 3;
  inline bool open() const;
  inline void set_open(bool value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncActivity.ActivityElement)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_open();
  inline void clear_has_open();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 activity_id_;
  bool open_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncActivity_ActivityElement* default_instance_;
};
// -------------------------------------------------------------------

class SyncActivity : public ::google::protobuf::Message {
 public:
  SyncActivity();
  virtual ~SyncActivity();

  SyncActivity(const SyncActivity& from);

  inline SyncActivity& operator=(const SyncActivity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncActivity& default_instance();

  void Swap(SyncActivity* other);

  // implements Message ----------------------------------------------

  SyncActivity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncActivity& from);
  void MergeFrom(const SyncActivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SyncActivity_ActivityElement ActivityElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ACTIVITY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.SyncActivity.ActivityElement activity_list = 2;
  inline int activity_list_size() const;
  inline void clear_activity_list();
  static const int kActivityListFieldNumber = 2;
  inline const ::Adoter::Asset::SyncActivity_ActivityElement& activity_list(int index) const;
  inline ::Adoter::Asset::SyncActivity_ActivityElement* mutable_activity_list(int index);
  inline ::Adoter::Asset::SyncActivity_ActivityElement* add_activity_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SyncActivity_ActivityElement >&
      activity_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SyncActivity_ActivityElement >*
      mutable_activity_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncActivity)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SyncActivity_ActivityElement > activity_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncActivity* default_instance_;
};
// -------------------------------------------------------------------

class SystemBroadcasting : public ::google::protobuf::Message {
 public:
  SystemBroadcasting();
  virtual ~SystemBroadcasting();

  SystemBroadcasting(const SystemBroadcasting& from);

  inline SystemBroadcasting& operator=(const SystemBroadcasting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemBroadcasting& default_instance();

  void Swap(SystemBroadcasting* other);

  // implements Message ----------------------------------------------

  SystemBroadcasting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemBroadcasting& from);
  void MergeFrom(const SystemBroadcasting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_SYSTEM_BROADCAST];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.SYSTEM_BROADCAST_TYPE broad_cast_type = 2;
  inline bool has_broad_cast_type() const;
  inline void clear_broad_cast_type();
  static const int kBroadCastTypeFieldNumber = 2;
  inline ::Adoter::Asset::SYSTEM_BROADCAST_TYPE broad_cast_type() const;
  inline void set_broad_cast_type(::Adoter::Asset::SYSTEM_BROADCAST_TYPE value);

  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SystemBroadcasting)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_broad_cast_type();
  inline void clear_has_broad_cast_type();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int broad_cast_type_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SystemBroadcasting* default_instance_;
};
// -------------------------------------------------------------------

class MultiplePai : public ::google::protobuf::Message {
 public:
  MultiplePai();
  virtual ~MultiplePai();

  MultiplePai(const MultiplePai& from);

  inline MultiplePai& operator=(const MultiplePai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplePai& default_instance();

  void Swap(MultiplePai* other);

  // implements Message ----------------------------------------------

  MultiplePai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiplePai& from);
  void MergeFrom(const MultiplePai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // repeated int32 cards = 2;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline ::google::protobuf::int32 cards(int index) const;
  inline void set_cards(int index, ::google::protobuf::int32 value);
  inline void add_cards(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cards();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MultiplePai)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cards_;
  int card_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static MultiplePai* default_instance_;
};
// -------------------------------------------------------------------

class PaiPushDown_PlayerElement : public ::google::protobuf::Message {
 public:
  PaiPushDown_PlayerElement();
  virtual ~PaiPushDown_PlayerElement();

  PaiPushDown_PlayerElement(const PaiPushDown_PlayerElement& from);

  inline PaiPushDown_PlayerElement& operator=(const PaiPushDown_PlayerElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiPushDown_PlayerElement& default_instance();

  void Swap(PaiPushDown_PlayerElement* other);

  // implements Message ----------------------------------------------

  PaiPushDown_PlayerElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiPushDown_PlayerElement& from);
  void MergeFrom(const PaiPushDown_PlayerElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.POSITION_TYPE position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // repeated .Adoter.Asset.MultiplePai pai_list = 3;
  inline int pai_list_size() const;
  inline void clear_pai_list();
  static const int kPaiListFieldNumber = 3;
  inline const ::Adoter::Asset::MultiplePai& pai_list(int index) const;
  inline ::Adoter::Asset::MultiplePai* mutable_pai_list(int index);
  inline ::Adoter::Asset::MultiplePai* add_pai_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
      pai_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
      mutable_pai_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiPushDown.PlayerElement)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai > pai_list_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiPushDown_PlayerElement* default_instance_;
};
// -------------------------------------------------------------------

class PaiPushDown : public ::google::protobuf::Message {
 public:
  PaiPushDown();
  virtual ~PaiPushDown();

  PaiPushDown(const PaiPushDown& from);

  inline PaiPushDown& operator=(const PaiPushDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiPushDown& default_instance();

  void Swap(PaiPushDown* other);

  // implements Message ----------------------------------------------

  PaiPushDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiPushDown& from);
  void MergeFrom(const PaiPushDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PaiPushDown_PlayerElement PlayerElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_PUSH_DOWN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.PaiPushDown.PlayerElement player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline const ::Adoter::Asset::PaiPushDown_PlayerElement& player_list(int index) const;
  inline ::Adoter::Asset::PaiPushDown_PlayerElement* mutable_player_list(int index);
  inline ::Adoter::Asset::PaiPushDown_PlayerElement* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiPushDown_PlayerElement >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiPushDown_PlayerElement >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiPushDown)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiPushDown_PlayerElement > player_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiPushDown* default_instance_;
};
// -------------------------------------------------------------------

class GamesFull : public ::google::protobuf::Message {
 public:
  GamesFull();
  virtual ~GamesFull();

  GamesFull(const GamesFull& from);

  inline GamesFull& operator=(const GamesFull& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamesFull& default_instance();

  void Swap(GamesFull* other);

  // implements Message ----------------------------------------------

  GamesFull* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamesFull& from);
  void MergeFrom(const GamesFull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAMES_FULL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int32 rounds = 2;
  inline bool has_rounds() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 2;
  inline ::google::protobuf::int32 rounds() const;
  inline void set_rounds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GamesFull)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_rounds();
  inline void clear_has_rounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  ::google::protobuf::int32 rounds_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GamesFull* default_instance_;
};
// -------------------------------------------------------------------

class WeChatInfo : public ::google::protobuf::Message {
 public:
  WeChatInfo();
  virtual ~WeChatInfo();

  WeChatInfo(const WeChatInfo& from);

  inline WeChatInfo& operator=(const WeChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeChatInfo& default_instance();

  void Swap(WeChatInfo* other);

  // implements Message ----------------------------------------------

  WeChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeChatInfo& from);
  void MergeFrom(const WeChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_WECHAT_INFOMATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.WechatUnion wechat = 2;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 2;
  inline const ::Adoter::Asset::WechatUnion& wechat() const;
  inline ::Adoter::Asset::WechatUnion* mutable_wechat();
  inline ::Adoter::Asset::WechatUnion* release_wechat();
  inline void set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat);

  // optional .Adoter.Asset.WechatError wechat_error = 3;
  inline bool has_wechat_error() const;
  inline void clear_wechat_error();
  static const int kWechatErrorFieldNumber = 3;
  inline const ::Adoter::Asset::WechatError& wechat_error() const;
  inline ::Adoter::Asset::WechatError* mutable_wechat_error();
  inline ::Adoter::Asset::WechatError* release_wechat_error();
  inline void set_allocated_wechat_error(::Adoter::Asset::WechatError* wechat_error);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.WeChatInfo)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_wechat();
  inline void clear_has_wechat();
  inline void set_has_wechat_error();
  inline void clear_has_wechat_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::WechatUnion* wechat_;
  ::Adoter::Asset::WechatError* wechat_error_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static WeChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameStart : public ::google::protobuf::Message {
 public:
  GameStart();
  virtual ~GameStart();

  GameStart(const GameStart& from);

  inline GameStart& operator=(const GameStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStart& default_instance();

  void Swap(GameStart* other);

  // implements Message ----------------------------------------------

  GameStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStart& from);
  void MergeFrom(const GameStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_START];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int32 total_rounds = 2;
  inline bool has_total_rounds() const;
  inline void clear_total_rounds();
  static const int kTotalRoundsFieldNumber = 2;
  inline ::google::protobuf::int32 total_rounds() const;
  inline void set_total_rounds(::google::protobuf::int32 value);

  // optional int32 current_rounds = 3;
  inline bool has_current_rounds() const;
  inline void clear_current_rounds();
  static const int kCurrentRoundsFieldNumber = 3;
  inline ::google::protobuf::int32 current_rounds() const;
  inline void set_current_rounds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameStart)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_total_rounds();
  inline void clear_has_total_rounds();
  inline void set_has_current_rounds();
  inline void clear_has_current_rounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  ::google::protobuf::int32 total_rounds_;
  ::google::protobuf::int32 current_rounds_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameStart* default_instance_;
};
// -------------------------------------------------------------------

class RoomDisMiss_RoomElement : public ::google::protobuf::Message {
 public:
  RoomDisMiss_RoomElement();
  virtual ~RoomDisMiss_RoomElement();

  RoomDisMiss_RoomElement(const RoomDisMiss_RoomElement& from);

  inline RoomDisMiss_RoomElement& operator=(const RoomDisMiss_RoomElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomDisMiss_RoomElement& default_instance();

  void Swap(RoomDisMiss_RoomElement* other);

  // implements Message ----------------------------------------------

  RoomDisMiss_RoomElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomDisMiss_RoomElement& from);
  void MergeFrom(const RoomDisMiss_RoomElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.POSITION_TYPE position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 3;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomDisMiss.RoomElement)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int position_;
  int oper_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomDisMiss_RoomElement* default_instance_;
};
// -------------------------------------------------------------------

class RoomDisMiss : public ::google::protobuf::Message {
 public:
  RoomDisMiss();
  virtual ~RoomDisMiss();

  RoomDisMiss(const RoomDisMiss& from);

  inline RoomDisMiss& operator=(const RoomDisMiss& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomDisMiss& default_instance();

  void Swap(RoomDisMiss* other);

  // implements Message ----------------------------------------------

  RoomDisMiss* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomDisMiss& from);
  void MergeFrom(const RoomDisMiss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomDisMiss_RoomElement RoomElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_DISMISS];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // repeated .Adoter.Asset.RoomDisMiss.RoomElement list = 3;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 3;
  inline const ::Adoter::Asset::RoomDisMiss_RoomElement& list(int index) const;
  inline ::Adoter::Asset::RoomDisMiss_RoomElement* mutable_list(int index);
  inline ::Adoter::Asset::RoomDisMiss_RoomElement* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomDisMiss_RoomElement >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomDisMiss_RoomElement >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomDisMiss)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomDisMiss_RoomElement > list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomDisMiss* default_instance_;
};
// -------------------------------------------------------------------

class RoomState : public ::google::protobuf::Message {
 public:
  RoomState();
  virtual ~RoomState();

  RoomState(const RoomState& from);

  inline RoomState& operator=(const RoomState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomState& default_instance();

  void Swap(RoomState* other);

  // implements Message ----------------------------------------------

  RoomState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomState& from);
  void MergeFrom(const RoomState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_STATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 3;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomState)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int type_t_;
  int oper_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomState* default_instance_;
};
// -------------------------------------------------------------------

class BattleList : public ::google::protobuf::Message {
 public:
  BattleList();
  virtual ~BattleList();

  BattleList(const BattleList& from);

  inline BattleList& operator=(const BattleList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleList& default_instance();

  void Swap(BattleList* other);

  // implements Message ----------------------------------------------

  BattleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleList& from);
  void MergeFrom(const BattleList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_HISTORY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated int64 room_list = 2;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 2;
  inline ::google::protobuf::int64 room_list(int index) const;
  inline void set_room_list(int index, ::google::protobuf::int64 value);
  inline void add_room_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      room_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.BattleList)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > room_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static BattleList* default_instance_;
};
// -------------------------------------------------------------------

class RoomAll_Player : public ::google::protobuf::Message {
 public:
  RoomAll_Player();
  virtual ~RoomAll_Player();

  RoomAll_Player(const RoomAll_Player& from);

  inline RoomAll_Player& operator=(const RoomAll_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomAll_Player& default_instance();

  void Swap(RoomAll_Player* other);

  // implements Message ----------------------------------------------

  RoomAll_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomAll_Player& from);
  void MergeFrom(const RoomAll_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.POSITION_TYPE position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional int32 pai_count_inhand = 3;
  inline bool has_pai_count_inhand() const;
  inline void clear_pai_count_inhand();
  static const int kPaiCountInhandFieldNumber = 3;
  inline ::google::protobuf::int32 pai_count_inhand() const;
  inline void set_pai_count_inhand(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.MultiplePai pai_inhand = 4;
  inline int pai_inhand_size() const;
  inline void clear_pai_inhand();
  static const int kPaiInhandFieldNumber = 4;
  inline const ::Adoter::Asset::MultiplePai& pai_inhand(int index) const;
  inline ::Adoter::Asset::MultiplePai* mutable_pai_inhand(int index);
  inline ::Adoter::Asset::MultiplePai* add_pai_inhand();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
      pai_inhand() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
      mutable_pai_inhand();

  // repeated .Adoter.Asset.PaiElement pai_outhand = 5;
  inline int pai_outhand_size() const;
  inline void clear_pai_outhand();
  static const int kPaiOuthandFieldNumber = 5;
  inline const ::Adoter::Asset::PaiElement& pai_outhand(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pai_outhand(int index);
  inline ::Adoter::Asset::PaiElement* add_pai_outhand();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pai_outhand() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pai_outhand();

  // repeated .Adoter.Asset.PaiElement minggang_list = 6;
  inline int minggang_list_size() const;
  inline void clear_minggang_list();
  static const int kMinggangListFieldNumber = 6;
  inline const ::Adoter::Asset::PaiElement& minggang_list(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_minggang_list(int index);
  inline ::Adoter::Asset::PaiElement* add_minggang_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      minggang_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_minggang_list();

  // repeated .Adoter.Asset.PaiElement angang_list = 7;
  inline int angang_list_size() const;
  inline void clear_angang_list();
  static const int kAngangListFieldNumber = 7;
  inline const ::Adoter::Asset::PaiElement& angang_list(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_angang_list(int index);
  inline ::Adoter::Asset::PaiElement* add_angang_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      angang_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_angang_list();

  // optional int32 fenggang_count = 8;
  inline bool has_fenggang_count() const;
  inline void clear_fenggang_count();
  static const int kFenggangCountFieldNumber = 8;
  inline ::google::protobuf::int32 fenggang_count() const;
  inline void set_fenggang_count(::google::protobuf::int32 value);

  // optional int32 jiangang_count = 9;
  inline bool has_jiangang_count() const;
  inline void clear_jiangang_count();
  static const int kJiangangCountFieldNumber = 9;
  inline ::google::protobuf::int32 jiangang_count() const;
  inline void set_jiangang_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.PaiElement pai_pool = 10;
  inline int pai_pool_size() const;
  inline void clear_pai_pool();
  static const int kPaiPoolFieldNumber = 10;
  inline const ::Adoter::Asset::PaiElement& pai_pool(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pai_pool(int index);
  inline ::Adoter::Asset::PaiElement* add_pai_pool();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pai_pool() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pai_pool();

  // optional bool tingpai = 11;
  inline bool has_tingpai() const;
  inline void clear_tingpai();
  static const int kTingpaiFieldNumber = 11;
  inline bool tingpai() const;
  inline void set_tingpai(bool value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomAll.Player)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_pai_count_inhand();
  inline void clear_has_pai_count_inhand();
  inline void set_has_fenggang_count();
  inline void clear_has_fenggang_count();
  inline void set_has_jiangang_count();
  inline void clear_has_jiangang_count();
  inline void set_has_tingpai();
  inline void clear_has_tingpai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int position_;
  ::google::protobuf::int32 pai_count_inhand_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai > pai_inhand_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pai_outhand_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > minggang_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > angang_list_;
  ::google::protobuf::int32 fenggang_count_;
  ::google::protobuf::int32 jiangang_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pai_pool_;
  bool tingpai_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomAll_Player* default_instance_;
};
// -------------------------------------------------------------------

class RoomAll : public ::google::protobuf::Message {
 public:
  RoomAll();
  virtual ~RoomAll();

  RoomAll(const RoomAll& from);

  inline RoomAll& operator=(const RoomAll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomAll& default_instance();

  void Swap(RoomAll* other);

  // implements Message ----------------------------------------------

  RoomAll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomAll& from);
  void MergeFrom(const RoomAll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomAll_Player Player;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_ALL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int32 current_rounds = 2;
  inline bool has_current_rounds() const;
  inline void clear_current_rounds();
  static const int kCurrentRoundsFieldNumber = 2;
  inline ::google::protobuf::int32 current_rounds() const;
  inline void set_current_rounds(::google::protobuf::int32 value);

  // optional int32 remain_cards_count = 3;
  inline bool has_remain_cards_count() const;
  inline void clear_remain_cards_count();
  static const int kRemainCardsCountFieldNumber = 3;
  inline ::google::protobuf::int32 remain_cards_count() const;
  inline void set_remain_cards_count(::google::protobuf::int32 value);

  // repeated int32 saizi_random_result = 4;
  inline int saizi_random_result_size() const;
  inline void clear_saizi_random_result();
  static const int kSaiziRandomResultFieldNumber = 4;
  inline ::google::protobuf::int32 saizi_random_result(int index) const;
  inline void set_saizi_random_result(int index, ::google::protobuf::int32 value);
  inline void add_saizi_random_result(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      saizi_random_result() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_saizi_random_result();

  // optional .Adoter.Asset.PaiElement baopai = 5;
  inline bool has_baopai() const;
  inline void clear_baopai();
  static const int kBaopaiFieldNumber = 5;
  inline const ::Adoter::Asset::PaiElement& baopai() const;
  inline ::Adoter::Asset::PaiElement* mutable_baopai();
  inline ::Adoter::Asset::PaiElement* release_baopai();
  inline void set_allocated_baopai(::Adoter::Asset::PaiElement* baopai);

  // repeated .Adoter.Asset.PlayerBrief player_brief_list = 6;
  inline int player_brief_list_size() const;
  inline void clear_player_brief_list();
  static const int kPlayerBriefListFieldNumber = 6;
  inline const ::Adoter::Asset::PlayerBrief& player_brief_list(int index) const;
  inline ::Adoter::Asset::PlayerBrief* mutable_player_brief_list(int index);
  inline ::Adoter::Asset::PlayerBrief* add_player_brief_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >&
      player_brief_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >*
      mutable_player_brief_list();

  // repeated .Adoter.Asset.RoomAll.Player player_list = 7;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 7;
  inline const ::Adoter::Asset::RoomAll_Player& player_list(int index) const;
  inline ::Adoter::Asset::RoomAll_Player* mutable_player_list(int index);
  inline ::Adoter::Asset::RoomAll_Player* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomAll_Player >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomAll_Player >*
      mutable_player_list();

  // optional .Adoter.Asset.POSITION_TYPE zhuang_position = 8;
  inline bool has_zhuang_position() const;
  inline void clear_zhuang_position();
  static const int kZhuangPositionFieldNumber = 8;
  inline ::Adoter::Asset::POSITION_TYPE zhuang_position() const;
  inline void set_zhuang_position(::Adoter::Asset::POSITION_TYPE value);

  // optional .Adoter.Asset.POSITION_TYPE curr_operator_position = 9;
  inline bool has_curr_operator_position() const;
  inline void clear_curr_operator_position();
  static const int kCurrOperatorPositionFieldNumber = 9;
  inline ::Adoter::Asset::POSITION_TYPE curr_operator_position() const;
  inline void set_curr_operator_position(::Adoter::Asset::POSITION_TYPE value);

  // repeated .Adoter.Asset.GameRecord list = 10;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 10;
  inline const ::Adoter::Asset::GameRecord& list(int index) const;
  inline ::Adoter::Asset::GameRecord* mutable_list(int index);
  inline ::Adoter::Asset::GameRecord* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >*
      mutable_list();

  // optional .Adoter.Asset.PaiElement zhuapai = 11;
  inline bool has_zhuapai() const;
  inline void clear_zhuapai();
  static const int kZhuapaiFieldNumber = 11;
  inline const ::Adoter::Asset::PaiElement& zhuapai() const;
  inline ::Adoter::Asset::PaiElement* mutable_zhuapai();
  inline ::Adoter::Asset::PaiElement* release_zhuapai();
  inline void set_allocated_zhuapai(::Adoter::Asset::PaiElement* zhuapai);

  // optional .Adoter.Asset.PaiElement huipai = 12;
  inline bool has_huipai() const;
  inline void clear_huipai();
  static const int kHuipaiFieldNumber = 12;
  inline const ::Adoter::Asset::PaiElement& huipai() const;
  inline ::Adoter::Asset::PaiElement* mutable_huipai();
  inline ::Adoter::Asset::PaiElement* release_huipai();
  inline void set_allocated_huipai(::Adoter::Asset::PaiElement* huipai);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomAll)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_current_rounds();
  inline void clear_has_current_rounds();
  inline void set_has_remain_cards_count();
  inline void clear_has_remain_cards_count();
  inline void set_has_baopai();
  inline void clear_has_baopai();
  inline void set_has_zhuang_position();
  inline void clear_has_zhuang_position();
  inline void set_has_curr_operator_position();
  inline void clear_has_curr_operator_position();
  inline void set_has_zhuapai();
  inline void clear_has_zhuapai();
  inline void set_has_huipai();
  inline void clear_has_huipai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  ::google::protobuf::int32 current_rounds_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > saizi_random_result_;
  ::Adoter::Asset::PaiElement* baopai_;
  ::google::protobuf::int32 remain_cards_count_;
  int zhuang_position_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief > player_brief_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomAll_Player > player_list_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord > list_;
  ::Adoter::Asset::PaiElement* zhuapai_;
  ::Adoter::Asset::PaiElement* huipai_;
  int curr_operator_position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomAll* default_instance_;
};
// -------------------------------------------------------------------

class RoomBeenIn : public ::google::protobuf::Message {
 public:
  RoomBeenIn();
  virtual ~RoomBeenIn();

  RoomBeenIn(const RoomBeenIn& from);

  inline RoomBeenIn& operator=(const RoomBeenIn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomBeenIn& default_instance();

  void Swap(RoomBeenIn* other);

  // implements Message ----------------------------------------------

  RoomBeenIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomBeenIn& from);
  void MergeFrom(const RoomBeenIn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_IN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomBeenIn)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomBeenIn* default_instance_;
};
// -------------------------------------------------------------------

class RoomQueryResult : public ::google::protobuf::Message {
 public:
  RoomQueryResult();
  virtual ~RoomQueryResult();

  RoomQueryResult(const RoomQueryResult& from);

  inline RoomQueryResult& operator=(const RoomQueryResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomQueryResult& default_instance();

  void Swap(RoomQueryResult* other);

  // implements Message ----------------------------------------------

  RoomQueryResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomQueryResult& from);
  void MergeFrom(const RoomQueryResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_QUERY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 room_id = 2;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional int32 create_time = 3;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional .Adoter.Asset.RoomOptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::Adoter::Asset::RoomOptions& options() const;
  inline ::Adoter::Asset::RoomOptions* mutable_options();
  inline ::Adoter::Asset::RoomOptions* release_options();
  inline void set_allocated_options(::Adoter::Asset::RoomOptions* options);

  // optional .Adoter.Asset.RoomInformation information = 5;
  inline bool has_information() const;
  inline void clear_information();
  static const int kInformationFieldNumber = 5;
  inline const ::Adoter::Asset::RoomInformation& information() const;
  inline ::Adoter::Asset::RoomInformation* mutable_information();
  inline ::Adoter::Asset::RoomInformation* release_information();
  inline void set_allocated_information(::Adoter::Asset::RoomInformation* information);

  // optional int64 clan_id = 6;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 6;
  inline ::google::protobuf::int64 clan_id() const;
  inline void set_clan_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomQueryResult)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_information();
  inline void clear_has_information();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int type_t_;
  ::google::protobuf::int32 create_time_;
  ::Adoter::Asset::RoomOptions* options_;
  ::Adoter::Asset::RoomInformation* information_;
  ::google::protobuf::int64 clan_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomQueryResult* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServer : public ::google::protobuf::Message {
 public:
  RegisterServer();
  virtual ~RegisterServer();

  RegisterServer(const RegisterServer& from);

  inline RegisterServer& operator=(const RegisterServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServer& default_instance();

  void Swap(RegisterServer* other);

  // implements Message ----------------------------------------------

  RegisterServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServer& from);
  void MergeFrom(const RegisterServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_REGISTER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.ROLE_TYPE role_type = 2;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROLE_TYPE role_type() const;
  inline void set_role_type(::Adoter::Asset::ROLE_TYPE value);

  // optional int64 global_id = 3;
  inline bool has_global_id() const;
  inline void clear_global_id();
  static const int kGlobalIdFieldNumber = 3;
  inline ::google::protobuf::int64 global_id() const;
  inline void set_global_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RegisterServer)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_role_type();
  inline void clear_has_role_type();
  inline void set_has_global_id();
  inline void clear_has_global_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int role_type_;
  ::google::protobuf::int64 global_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RegisterServer* default_instance_;
};
// -------------------------------------------------------------------

class KickOutPlayer : public ::google::protobuf::Message {
 public:
  KickOutPlayer();
  virtual ~KickOutPlayer();

  KickOutPlayer(const KickOutPlayer& from);

  inline KickOutPlayer& operator=(const KickOutPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickOutPlayer& default_instance();

  void Swap(KickOutPlayer* other);

  // implements Message ----------------------------------------------

  KickOutPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickOutPlayer& from);
  void MergeFrom(const KickOutPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_KICKOUT_PLAYER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.KICK_OUT_REASON reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::Adoter::Asset::KICK_OUT_REASON reason() const;
  inline void set_reason(::Adoter::Asset::KICK_OUT_REASON value);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.KickOutPlayer)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_;
  ::google::protobuf::int64 player_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static KickOutPlayer* default_instance_;
};
// -------------------------------------------------------------------

class GmtInnerMeta : public ::google::protobuf::Message {
 public:
  GmtInnerMeta();
  virtual ~GmtInnerMeta();

  GmtInnerMeta(const GmtInnerMeta& from);

  inline GmtInnerMeta& operator=(const GmtInnerMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GmtInnerMeta& default_instance();

  void Swap(GmtInnerMeta* other);

  // implements Message ----------------------------------------------

  GmtInnerMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GmtInnerMeta& from);
  void MergeFrom(const GmtInnerMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_GMT_INNER_META];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes inner_meta = 2;
  inline bool has_inner_meta() const;
  inline void clear_inner_meta();
  static const int kInnerMetaFieldNumber = 2;
  inline const ::std::string& inner_meta() const;
  inline void set_inner_meta(const ::std::string& value);
  inline void set_inner_meta(const char* value);
  inline void set_inner_meta(const void* value, size_t size);
  inline ::std::string* mutable_inner_meta();
  inline ::std::string* release_inner_meta();
  inline void set_allocated_inner_meta(::std::string* inner_meta);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GmtInnerMeta)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_inner_meta();
  inline void clear_has_inner_meta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* inner_meta_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GmtInnerMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerState : public ::google::protobuf::Message {
 public:
  PlayerState();
  virtual ~PlayerState();

  PlayerState(const PlayerState& from);

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerState& default_instance();

  void Swap(PlayerState* other);

  // implements Message ----------------------------------------------

  PlayerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerState& from);
  void MergeFrom(const PlayerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_PLAYER_STATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerState)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerState* default_instance_;
};
// -------------------------------------------------------------------

class ClanRoomStatusChanged : public ::google::protobuf::Message {
 public:
  ClanRoomStatusChanged();
  virtual ~ClanRoomStatusChanged();

  ClanRoomStatusChanged(const ClanRoomStatusChanged& from);

  inline ClanRoomStatusChanged& operator=(const ClanRoomStatusChanged& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRoomStatusChanged& default_instance();

  void Swap(ClanRoomStatusChanged* other);

  // implements Message ----------------------------------------------

  ClanRoomStatusChanged* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRoomStatusChanged& from);
  void MergeFrom(const ClanRoomStatusChanged& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_CLAN_ROOM_START_OR_OVER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CLAN_ROOM_STATUS_TYPE status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE status() const;
  inline void set_status(::Adoter::Asset::CLAN_ROOM_STATUS_TYPE value);

  // optional .Adoter.Asset.Room room = 3;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline const ::Adoter::Asset::Room& room() const;
  inline ::Adoter::Asset::Room* mutable_room();
  inline ::Adoter::Asset::Room* release_room();
  inline void set_allocated_room(::Adoter::Asset::Room* room);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ClanRoomStatusChanged)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int status_;
  ::Adoter::Asset::Room* room_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClanRoomStatusChanged* default_instance_;
};
// -------------------------------------------------------------------

class ClanRoomSync : public ::google::protobuf::Message {
 public:
  ClanRoomSync();
  virtual ~ClanRoomSync();

  ClanRoomSync(const ClanRoomSync& from);

  inline ClanRoomSync& operator=(const ClanRoomSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRoomSync& default_instance();

  void Swap(ClanRoomSync* other);

  // implements Message ----------------------------------------------

  ClanRoomSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRoomSync& from);
  void MergeFrom(const ClanRoomSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_CLAN_ROOM_SYNC];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes room_status = 2;
  inline bool has_room_status() const;
  inline void clear_room_status();
  static const int kRoomStatusFieldNumber = 2;
  inline const ::std::string& room_status() const;
  inline void set_room_status(const ::std::string& value);
  inline void set_room_status(const char* value);
  inline void set_room_status(const void* value, size_t size);
  inline ::std::string* mutable_room_status();
  inline ::std::string* release_room_status();
  inline void set_allocated_room_status(::std::string* room_status);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ClanRoomSync)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room_status();
  inline void clear_has_room_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* room_status_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClanRoomSync* default_instance_;
};
// ===================================================================


// ===================================================================

// Account

// optional bytes username = 1;
inline bool Account::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Account::username() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Account.username)
  return *username_;
}
inline void Account::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Account.username)
}
inline void Account::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Account.username)
}
inline void Account::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Account.username)
}
inline ::std::string* Account::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Account.username)
  return username_;
}
inline ::std::string* Account::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Account.username)
}

// optional bytes password = 2;
inline bool Account::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Account::password() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Account.password)
  return *password_;
}
inline void Account::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Account.password)
}
inline void Account::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Account.password)
}
inline void Account::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Account.password)
}
inline ::std::string* Account::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Account.password)
  return password_;
}
inline ::std::string* Account::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Account.password)
}

// optional .Adoter.Asset.ACCOUNT_TYPE account_type = 3;
inline bool Account::has_account_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_account_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_account_type() {
  account_type_ = 1;
  clear_has_account_type();
}
inline ::Adoter::Asset::ACCOUNT_TYPE Account::account_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Account.account_type)
  return static_cast< ::Adoter::Asset::ACCOUNT_TYPE >(account_type_);
}
inline void Account::set_account_type(::Adoter::Asset::ACCOUNT_TYPE value) {
  assert(::Adoter::Asset::ACCOUNT_TYPE_IsValid(value));
  set_has_account_type();
  account_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Account.account_type)
}

// -------------------------------------------------------------------

// PaiElement

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiElement::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiElement::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiElement::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiElement::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiElement::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiElement::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_type)
}

// optional int32 card_value = 2;
inline bool PaiElement::has_card_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiElement::set_has_card_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiElement::clear_has_card_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiElement::clear_card_value() {
  card_value_ = 0;
  clear_has_card_value();
}
inline ::google::protobuf::int32 PaiElement::card_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_value)
  return card_value_;
}
inline void PaiElement::set_card_value(::google::protobuf::int32 value) {
  set_has_card_value();
  card_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_value)
}

// optional int32 card_index = 3;
inline bool PaiElement::has_card_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiElement::set_has_card_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiElement::clear_has_card_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiElement::clear_card_index() {
  card_index_ = 0;
  clear_has_card_index();
}
inline ::google::protobuf::int32 PaiElement::card_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_index)
  return card_index_;
}
inline void PaiElement::set_card_index(::google::protobuf::int32 value) {
  set_has_card_index();
  card_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_index)
}

// optional int64 source_player_id = 4;
inline bool PaiElement::has_source_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaiElement::set_has_source_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaiElement::clear_has_source_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaiElement::clear_source_player_id() {
  source_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_source_player_id();
}
inline ::google::protobuf::int64 PaiElement::source_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.source_player_id)
  return source_player_id_;
}
inline void PaiElement::set_source_player_id(::google::protobuf::int64 value) {
  set_has_source_player_id();
  source_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.source_player_id)
}

// -------------------------------------------------------------------

// ShunZi

// repeated .Adoter.Asset.PaiElement pai = 1;
inline int ShunZi::pai_size() const {
  return pai_.size();
}
inline void ShunZi::clear_pai() {
  pai_.Clear();
}
inline const ::Adoter::Asset::PaiElement& ShunZi::pai(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ShunZi.pai)
  return pai_.Get(index);
}
inline ::Adoter::Asset::PaiElement* ShunZi::mutable_pai(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ShunZi.pai)
  return pai_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* ShunZi::add_pai() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.ShunZi.pai)
  return pai_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
ShunZi::pai() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.ShunZi.pai)
  return pai_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
ShunZi::mutable_pai() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.ShunZi.pai)
  return &pai_;
}

// -------------------------------------------------------------------

// ItemElement

// optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
inline bool ItemElement::has_inventory_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemElement::set_has_inventory_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemElement::clear_has_inventory_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemElement::clear_inventory_type() {
  inventory_type_ = 1;
  clear_has_inventory_type();
}
inline ::Adoter::Asset::INVENTORY_TYPE ItemElement::inventory_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ItemElement.inventory_type)
  return static_cast< ::Adoter::Asset::INVENTORY_TYPE >(inventory_type_);
}
inline void ItemElement::set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value) {
  assert(::Adoter::Asset::INVENTORY_TYPE_IsValid(value));
  set_has_inventory_type();
  inventory_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ItemElement.inventory_type)
}

// optional int32 index = 2;
inline bool ItemElement::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemElement::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemElement::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemElement::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ItemElement::index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ItemElement.index)
  return index_;
}
inline void ItemElement::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ItemElement.index)
}

// optional int32 global_id = 3;
inline bool ItemElement::has_global_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemElement::set_has_global_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemElement::clear_has_global_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemElement::clear_global_id() {
  global_id_ = 0;
  clear_has_global_id();
}
inline ::google::protobuf::int32 ItemElement::global_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ItemElement.global_id)
  return global_id_;
}
inline void ItemElement::set_global_id(::google::protobuf::int32 value) {
  set_has_global_id();
  global_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ItemElement.global_id)
}

// -------------------------------------------------------------------

// User

// optional .Adoter.Asset.Account account = 1;
inline bool User::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_account() {
  if (account_ != NULL) account_->::Adoter::Asset::Account::Clear();
  clear_has_account();
}
inline const ::Adoter::Asset::Account& User::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Adoter::Asset::Account* User::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Adoter::Asset::Account;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.User.account)
  return account_;
}
inline ::Adoter::Asset::Account* User::release_account() {
  clear_has_account();
  ::Adoter::Asset::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void User::set_allocated_account(::Adoter::Asset::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.User.account)
}

// repeated int64 player_list = 2;
inline int User::player_list_size() const {
  return player_list_.size();
}
inline void User::clear_player_list() {
  player_list_.Clear();
}
inline ::google::protobuf::int64 User::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.player_list)
  return player_list_.Get(index);
}
inline void User::set_player_list(int index, ::google::protobuf::int64 value) {
  player_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.User.player_list)
}
inline void User::add_player_list(::google::protobuf::int64 value) {
  player_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.User.player_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
User::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.User.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
User::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.User.player_list)
  return &player_list_;
}

// optional .Adoter.Asset.WechatUnion wechat = 3;
inline bool User::has_wechat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_wechat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& User::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* User::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.User.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* User::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void User::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.User.wechat)
}

// optional .Adoter.Asset.ClientInfomation client_info = 4;
inline bool User::has_client_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_client_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_client_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_client_info() {
  if (client_info_ != NULL) client_info_->::Adoter::Asset::ClientInfomation::Clear();
  clear_has_client_info();
}
inline const ::Adoter::Asset::ClientInfomation& User::client_info() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.client_info)
  return client_info_ != NULL ? *client_info_ : *default_instance_->client_info_;
}
inline ::Adoter::Asset::ClientInfomation* User::mutable_client_info() {
  set_has_client_info();
  if (client_info_ == NULL) client_info_ = new ::Adoter::Asset::ClientInfomation;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.User.client_info)
  return client_info_;
}
inline ::Adoter::Asset::ClientInfomation* User::release_client_info() {
  clear_has_client_info();
  ::Adoter::Asset::ClientInfomation* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline void User::set_allocated_client_info(::Adoter::Asset::ClientInfomation* client_info) {
  delete client_info_;
  client_info_ = client_info;
  if (client_info) {
    set_has_client_info();
  } else {
    clear_has_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.User.client_info)
}

// optional int32 created_time = 5;
inline bool User::has_created_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_created_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_created_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_created_time() {
  created_time_ = 0;
  clear_has_created_time();
}
inline ::google::protobuf::int32 User::created_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.created_time)
  return created_time_;
}
inline void User::set_created_time(::google::protobuf::int32 value) {
  set_has_created_time();
  created_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.User.created_time)
}

// optional bytes daili_acount = 6;
inline bool User::has_daili_acount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_daili_acount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_daili_acount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_daili_acount() {
  if (daili_acount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daili_acount_->clear();
  }
  clear_has_daili_acount();
}
inline const ::std::string& User::daili_acount() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.daili_acount)
  return *daili_acount_;
}
inline void User::set_daili_acount(const ::std::string& value) {
  set_has_daili_acount();
  if (daili_acount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daili_acount_ = new ::std::string;
  }
  daili_acount_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.User.daili_acount)
}
inline void User::set_daili_acount(const char* value) {
  set_has_daili_acount();
  if (daili_acount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daili_acount_ = new ::std::string;
  }
  daili_acount_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.User.daili_acount)
}
inline void User::set_daili_acount(const void* value, size_t size) {
  set_has_daili_acount();
  if (daili_acount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daili_acount_ = new ::std::string;
  }
  daili_acount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.User.daili_acount)
}
inline ::std::string* User::mutable_daili_acount() {
  set_has_daili_acount();
  if (daili_acount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daili_acount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.User.daili_acount)
  return daili_acount_;
}
inline ::std::string* User::release_daili_acount() {
  clear_has_daili_acount();
  if (daili_acount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daili_acount_;
    daili_acount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_daili_acount(::std::string* daili_acount) {
  if (daili_acount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daili_acount_;
  }
  if (daili_acount) {
    set_has_daili_acount();
    daili_acount_ = daili_acount;
  } else {
    clear_has_daili_acount();
    daili_acount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.User.daili_acount)
}

// -------------------------------------------------------------------

// PlayerProp

// optional .Adoter.Asset.POSITION_TYPE position = 1;
inline bool PlayerProp::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProp::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProp::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProp::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PlayerProp::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PlayerProp::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.position)
}

// optional int64 room_id = 2;
inline bool PlayerProp::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProp::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProp::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProp::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 PlayerProp::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.room_id)
  return room_id_;
}
inline void PlayerProp::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.room_id)
}

// optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 3;
inline bool PlayerProp::has_load_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerProp::set_has_load_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerProp::clear_has_load_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerProp::clear_load_type() {
  load_type_ = 1;
  clear_has_load_type();
}
inline ::Adoter::Asset::LOAD_SCENE_TYPE PlayerProp::load_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.load_type)
  return static_cast< ::Adoter::Asset::LOAD_SCENE_TYPE >(load_type_);
}
inline void PlayerProp::set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value) {
  assert(::Adoter::Asset::LOAD_SCENE_TYPE_IsValid(value));
  set_has_load_type();
  load_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.load_type)
}

// optional .Adoter.Asset.GAME_OPER_TYPE game_oper_state = 4;
inline bool PlayerProp::has_game_oper_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerProp::set_has_game_oper_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerProp::clear_has_game_oper_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerProp::clear_game_oper_state() {
  game_oper_state_ = 1;
  clear_has_game_oper_state();
}
inline ::Adoter::Asset::GAME_OPER_TYPE PlayerProp::game_oper_state() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.game_oper_state)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(game_oper_state_);
}
inline void PlayerProp::set_game_oper_state(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_game_oper_state();
  game_oper_state_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.game_oper_state)
}

// optional int32 pai_oper_count = 5;
inline bool PlayerProp::has_pai_oper_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerProp::set_has_pai_oper_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerProp::clear_has_pai_oper_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerProp::clear_pai_oper_count() {
  pai_oper_count_ = 0;
  clear_has_pai_oper_count();
}
inline ::google::protobuf::int32 PlayerProp::pai_oper_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.pai_oper_count)
  return pai_oper_count_;
}
inline void PlayerProp::set_pai_oper_count(::google::protobuf::int32 value) {
  set_has_pai_oper_count();
  pai_oper_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.pai_oper_count)
}

// optional bool has_tinged = 6;
inline bool PlayerProp::has_has_tinged() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerProp::set_has_has_tinged() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerProp::clear_has_has_tinged() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerProp::clear_has_tinged() {
  has_tinged_ = false;
  clear_has_has_tinged();
}
inline bool PlayerProp::has_tinged() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.has_tinged)
  return has_tinged_;
}
inline void PlayerProp::set_has_tinged(bool value) {
  set_has_has_tinged();
  has_tinged_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.has_tinged)
}

// optional bool offline = 7;
inline bool PlayerProp::has_offline() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerProp::set_has_offline() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerProp::clear_has_offline() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerProp::clear_offline() {
  offline_ = false;
  clear_has_offline();
}
inline bool PlayerProp::offline() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.offline)
  return offline_;
}
inline void PlayerProp::set_offline(bool value) {
  set_has_offline();
  offline_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.offline)
}

// optional int64 voice_member_id = 8;
inline bool PlayerProp::has_voice_member_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerProp::set_has_voice_member_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerProp::clear_has_voice_member_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerProp::clear_voice_member_id() {
  voice_member_id_ = GOOGLE_LONGLONG(0);
  clear_has_voice_member_id();
}
inline ::google::protobuf::int64 PlayerProp::voice_member_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.voice_member_id)
  return voice_member_id_;
}
inline void PlayerProp::set_voice_member_id(::google::protobuf::int64 value) {
  set_has_voice_member_id();
  voice_member_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.voice_member_id)
}

// optional int32 beilv = 9;
inline bool PlayerProp::has_beilv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerProp::set_has_beilv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerProp::clear_has_beilv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerProp::clear_beilv() {
  beilv_ = 0;
  clear_has_beilv();
}
inline ::google::protobuf::int32 PlayerProp::beilv() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.beilv)
  return beilv_;
}
inline void PlayerProp::set_beilv(::google::protobuf::int32 value) {
  set_has_beilv();
  beilv_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.beilv)
}

// -------------------------------------------------------------------

// PlayerBrief

// optional int64 player_id = 1;
inline bool PlayerBrief::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerBrief::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerBrief::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerBrief::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PlayerBrief::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerBrief.player_id)
  return player_id_;
}
inline void PlayerBrief::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerBrief.player_id)
}

// optional bytes nickname = 2;
inline bool PlayerBrief::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerBrief::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerBrief::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerBrief::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& PlayerBrief::nickname() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerBrief.nickname)
  return *nickname_;
}
inline void PlayerBrief::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerBrief.nickname)
}
inline void PlayerBrief::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.PlayerBrief.nickname)
}
inline void PlayerBrief::set_nickname(const void* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.PlayerBrief.nickname)
}
inline ::std::string* PlayerBrief::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerBrief.nickname)
  return nickname_;
}
inline ::std::string* PlayerBrief::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerBrief::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayerBrief.nickname)
}

// optional bytes headimgurl = 3;
inline bool PlayerBrief::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerBrief::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerBrief::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerBrief::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& PlayerBrief::headimgurl() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerBrief.headimgurl)
  return *headimgurl_;
}
inline void PlayerBrief::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerBrief.headimgurl)
}
inline void PlayerBrief::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.PlayerBrief.headimgurl)
}
inline void PlayerBrief::set_headimgurl(const void* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.PlayerBrief.headimgurl)
}
inline ::std::string* PlayerBrief::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerBrief.headimgurl)
  return headimgurl_;
}
inline ::std::string* PlayerBrief::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerBrief::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayerBrief.headimgurl)
}

// -------------------------------------------------------------------

// GameRecord_GameElement_DetailElement

// optional int32 score = 1;
inline bool GameRecord_GameElement_DetailElement::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRecord_GameElement_DetailElement::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRecord_GameElement_DetailElement::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRecord_GameElement_DetailElement::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 GameRecord_GameElement_DetailElement::score() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.DetailElement.score)
  return score_;
}
inline void GameRecord_GameElement_DetailElement::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.DetailElement.score)
}

// optional int32 fan_type = 2;
inline bool GameRecord_GameElement_DetailElement::has_fan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRecord_GameElement_DetailElement::set_has_fan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRecord_GameElement_DetailElement::clear_has_fan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRecord_GameElement_DetailElement::clear_fan_type() {
  fan_type_ = 0;
  clear_has_fan_type();
}
inline ::google::protobuf::int32 GameRecord_GameElement_DetailElement::fan_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.DetailElement.fan_type)
  return fan_type_;
}
inline void GameRecord_GameElement_DetailElement::set_fan_type(::google::protobuf::int32 value) {
  set_has_fan_type();
  fan_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.DetailElement.fan_type)
}

// -------------------------------------------------------------------

// GameRecord_GameElement

// optional int64 player_id = 1;
inline bool GameRecord_GameElement::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRecord_GameElement::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRecord_GameElement::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRecord_GameElement::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 GameRecord_GameElement::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.player_id)
  return player_id_;
}
inline void GameRecord_GameElement::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.player_id)
}

// optional bytes nickname = 2;
inline bool GameRecord_GameElement::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRecord_GameElement::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRecord_GameElement::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRecord_GameElement::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GameRecord_GameElement::nickname() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.nickname)
  return *nickname_;
}
inline void GameRecord_GameElement::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.nickname)
}
inline void GameRecord_GameElement::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.GameRecord.GameElement.nickname)
}
inline void GameRecord_GameElement::set_nickname(const void* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.GameRecord.GameElement.nickname)
}
inline ::std::string* GameRecord_GameElement::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameRecord.GameElement.nickname)
  return nickname_;
}
inline ::std::string* GameRecord_GameElement::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameRecord_GameElement::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GameRecord.GameElement.nickname)
}

// optional bytes headimgurl = 3;
inline bool GameRecord_GameElement::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameRecord_GameElement::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameRecord_GameElement::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameRecord_GameElement::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& GameRecord_GameElement::headimgurl() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.headimgurl)
  return *headimgurl_;
}
inline void GameRecord_GameElement::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.headimgurl)
}
inline void GameRecord_GameElement::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.GameRecord.GameElement.headimgurl)
}
inline void GameRecord_GameElement::set_headimgurl(const void* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.GameRecord.GameElement.headimgurl)
}
inline ::std::string* GameRecord_GameElement::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameRecord.GameElement.headimgurl)
  return headimgurl_;
}
inline ::std::string* GameRecord_GameElement::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameRecord_GameElement::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GameRecord.GameElement.headimgurl)
}

// optional int32 score = 4;
inline bool GameRecord_GameElement::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRecord_GameElement::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRecord_GameElement::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRecord_GameElement::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 GameRecord_GameElement::score() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.score)
  return score_;
}
inline void GameRecord_GameElement::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameRecord.GameElement.score)
}

// repeated .Adoter.Asset.GameRecord.GameElement.DetailElement details = 5;
inline int GameRecord_GameElement::details_size() const {
  return details_.size();
}
inline void GameRecord_GameElement::clear_details() {
  details_.Clear();
}
inline const ::Adoter::Asset::GameRecord_GameElement_DetailElement& GameRecord_GameElement::details(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.GameElement.details)
  return details_.Get(index);
}
inline ::Adoter::Asset::GameRecord_GameElement_DetailElement* GameRecord_GameElement::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameRecord.GameElement.details)
  return details_.Mutable(index);
}
inline ::Adoter::Asset::GameRecord_GameElement_DetailElement* GameRecord_GameElement::add_details() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.GameRecord.GameElement.details)
  return details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement_DetailElement >&
GameRecord_GameElement::details() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.GameRecord.GameElement.details)
  return details_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement_DetailElement >*
GameRecord_GameElement::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.GameRecord.GameElement.details)
  return &details_;
}

// -------------------------------------------------------------------

// GameRecord

// repeated .Adoter.Asset.GameRecord.GameElement list = 1;
inline int GameRecord::list_size() const {
  return list_.size();
}
inline void GameRecord::clear_list() {
  list_.Clear();
}
inline const ::Adoter::Asset::GameRecord_GameElement& GameRecord::list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameRecord.list)
  return list_.Get(index);
}
inline ::Adoter::Asset::GameRecord_GameElement* GameRecord::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameRecord.list)
  return list_.Mutable(index);
}
inline ::Adoter::Asset::GameRecord_GameElement* GameRecord::add_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.GameRecord.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement >&
GameRecord::list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.GameRecord.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord_GameElement >*
GameRecord::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.GameRecord.list)
  return &list_;
}

// -------------------------------------------------------------------

// RoomHistory

// optional int64 room_id = 1;
inline bool RoomHistory::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomHistory::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomHistory::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomHistory::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 RoomHistory::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomHistory.room_id)
  return room_id_;
}
inline void RoomHistory::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomHistory.room_id)
}

// optional int32 create_time = 2;
inline bool RoomHistory::has_create_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomHistory::set_has_create_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomHistory::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomHistory::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 RoomHistory::create_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomHistory.create_time)
  return create_time_;
}
inline void RoomHistory::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomHistory.create_time)
}

// optional .Adoter.Asset.RoomOptions options = 3;
inline bool RoomHistory::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomHistory::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomHistory::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomHistory::clear_options() {
  if (options_ != NULL) options_->::Adoter::Asset::RoomOptions::Clear();
  clear_has_options();
}
inline const ::Adoter::Asset::RoomOptions& RoomHistory::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomHistory.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::Adoter::Asset::RoomOptions* RoomHistory::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::Adoter::Asset::RoomOptions;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomHistory.options)
  return options_;
}
inline ::Adoter::Asset::RoomOptions* RoomHistory::release_options() {
  clear_has_options();
  ::Adoter::Asset::RoomOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void RoomHistory::set_allocated_options(::Adoter::Asset::RoomOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomHistory.options)
}

// repeated .Adoter.Asset.GameRecord list = 4;
inline int RoomHistory::list_size() const {
  return list_.size();
}
inline void RoomHistory::clear_list() {
  list_.Clear();
}
inline const ::Adoter::Asset::GameRecord& RoomHistory::list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomHistory.list)
  return list_.Get(index);
}
inline ::Adoter::Asset::GameRecord* RoomHistory::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomHistory.list)
  return list_.Mutable(index);
}
inline ::Adoter::Asset::GameRecord* RoomHistory::add_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomHistory.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >&
RoomHistory::list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomHistory.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >*
RoomHistory::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomHistory.list)
  return &list_;
}

// repeated .Adoter.Asset.PlayerBrief player_brief_list = 5;
inline int RoomHistory::player_brief_list_size() const {
  return player_brief_list_.size();
}
inline void RoomHistory::clear_player_brief_list() {
  player_brief_list_.Clear();
}
inline const ::Adoter::Asset::PlayerBrief& RoomHistory::player_brief_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomHistory.player_brief_list)
  return player_brief_list_.Get(index);
}
inline ::Adoter::Asset::PlayerBrief* RoomHistory::mutable_player_brief_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomHistory.player_brief_list)
  return player_brief_list_.Mutable(index);
}
inline ::Adoter::Asset::PlayerBrief* RoomHistory::add_player_brief_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomHistory.player_brief_list)
  return player_brief_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >&
RoomHistory::player_brief_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomHistory.player_brief_list)
  return player_brief_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >*
RoomHistory::mutable_player_brief_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomHistory.player_brief_list)
  return &player_brief_list_;
}

// -------------------------------------------------------------------

// CommonProp

// optional int64 player_id = 1;
inline bool CommonProp::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonProp::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonProp::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonProp::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 CommonProp::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.player_id)
  return player_id_;
}
inline void CommonProp::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.player_id)
}

// optional int32 local_server_id = 2;
inline bool CommonProp::has_local_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonProp::set_has_local_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonProp::clear_has_local_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonProp::clear_local_server_id() {
  local_server_id_ = 0;
  clear_has_local_server_id();
}
inline ::google::protobuf::int32 CommonProp::local_server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.local_server_id)
  return local_server_id_;
}
inline void CommonProp::set_local_server_id(::google::protobuf::int32 value) {
  set_has_local_server_id();
  local_server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.local_server_id)
}

// optional bytes name = 3;
inline bool CommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommonProp::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.name)
  return *name_;
}
inline void CommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonProp.name)
}
inline ::std::string* CommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonProp.name)
  return name_;
}
inline ::std::string* CommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonProp.name)
}

// optional int32 iphoto = 4;
inline bool CommonProp::has_iphoto() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonProp::set_has_iphoto() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonProp::clear_has_iphoto() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonProp::clear_iphoto() {
  iphoto_ = 0;
  clear_has_iphoto();
}
inline ::google::protobuf::int32 CommonProp::iphoto() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.iphoto)
  return iphoto_;
}
inline void CommonProp::set_iphoto(::google::protobuf::int32 value) {
  set_has_iphoto();
  iphoto_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.iphoto)
}

// optional int32 level = 5 [default = 1];
inline bool CommonProp::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonProp::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonProp::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonProp::clear_level() {
  level_ = 1;
  clear_has_level();
}
inline ::google::protobuf::int32 CommonProp::level() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.level)
  return level_;
}
inline void CommonProp::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.level)
}

// optional .Adoter.Asset.GENDER_TYPE gender = 6 [default = GENDER_TYPE_WOMAN];
inline bool CommonProp::has_gender() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonProp::set_has_gender() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonProp::clear_has_gender() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonProp::clear_gender() {
  gender_ = 2;
  clear_has_gender();
}
inline ::Adoter::Asset::GENDER_TYPE CommonProp::gender() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.gender)
  return static_cast< ::Adoter::Asset::GENDER_TYPE >(gender_);
}
inline void CommonProp::set_gender(::Adoter::Asset::GENDER_TYPE value) {
  assert(::Adoter::Asset::GENDER_TYPE_IsValid(value));
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.gender)
}

// optional int64 diamond = 7;
inline bool CommonProp::has_diamond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonProp::set_has_diamond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonProp::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonProp::clear_diamond() {
  diamond_ = GOOGLE_LONGLONG(0);
  clear_has_diamond();
}
inline ::google::protobuf::int64 CommonProp::diamond() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.diamond)
  return diamond_;
}
inline void CommonProp::set_diamond(::google::protobuf::int64 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.diamond)
}

// optional int64 huanledou = 8 [default = 10000];
inline bool CommonProp::has_huanledou() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonProp::set_has_huanledou() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonProp::clear_has_huanledou() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonProp::clear_huanledou() {
  huanledou_ = GOOGLE_LONGLONG(10000);
  clear_has_huanledou();
}
inline ::google::protobuf::int64 CommonProp::huanledou() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.huanledou)
  return huanledou_;
}
inline void CommonProp::set_huanledou(::google::protobuf::int64 value) {
  set_has_huanledou();
  huanledou_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.huanledou)
}

// optional int64 room_card_count = 9 [default = 2];
inline bool CommonProp::has_room_card_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonProp::set_has_room_card_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonProp::clear_has_room_card_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonProp::clear_room_card_count() {
  room_card_count_ = GOOGLE_LONGLONG(2);
  clear_has_room_card_count();
}
inline ::google::protobuf::int64 CommonProp::room_card_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.room_card_count)
  return room_card_count_;
}
inline void CommonProp::set_room_card_count(::google::protobuf::int64 value) {
  set_has_room_card_count();
  room_card_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.room_card_count)
}

// optional int64 total_rounds = 10;
inline bool CommonProp::has_total_rounds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonProp::set_has_total_rounds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonProp::clear_has_total_rounds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonProp::clear_total_rounds() {
  total_rounds_ = GOOGLE_LONGLONG(0);
  clear_has_total_rounds();
}
inline ::google::protobuf::int64 CommonProp::total_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.total_rounds)
  return total_rounds_;
}
inline void CommonProp::set_total_rounds(::google::protobuf::int64 value) {
  set_has_total_rounds();
  total_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.total_rounds)
}

// optional int64 room_card_rounds = 11;
inline bool CommonProp::has_room_card_rounds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonProp::set_has_room_card_rounds() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonProp::clear_has_room_card_rounds() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonProp::clear_room_card_rounds() {
  room_card_rounds_ = GOOGLE_LONGLONG(0);
  clear_has_room_card_rounds();
}
inline ::google::protobuf::int64 CommonProp::room_card_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.room_card_rounds)
  return room_card_rounds_;
}
inline void CommonProp::set_room_card_rounds(::google::protobuf::int64 value) {
  set_has_room_card_rounds();
  room_card_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.room_card_rounds)
}

// optional int64 total_win_rounds = 12;
inline bool CommonProp::has_total_win_rounds() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonProp::set_has_total_win_rounds() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonProp::clear_has_total_win_rounds() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonProp::clear_total_win_rounds() {
  total_win_rounds_ = GOOGLE_LONGLONG(0);
  clear_has_total_win_rounds();
}
inline ::google::protobuf::int64 CommonProp::total_win_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.total_win_rounds)
  return total_win_rounds_;
}
inline void CommonProp::set_total_win_rounds(::google::protobuf::int64 value) {
  set_has_total_win_rounds();
  total_win_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.total_win_rounds)
}

// optional int64 streak_wins = 13;
inline bool CommonProp::has_streak_wins() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonProp::set_has_streak_wins() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonProp::clear_has_streak_wins() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonProp::clear_streak_wins() {
  streak_wins_ = GOOGLE_LONGLONG(0);
  clear_has_streak_wins();
}
inline ::google::protobuf::int64 CommonProp::streak_wins() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.streak_wins)
  return streak_wins_;
}
inline void CommonProp::set_streak_wins(::google::protobuf::int64 value) {
  set_has_streak_wins();
  streak_wins_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.streak_wins)
}

// optional int64 score = 14;
inline bool CommonProp::has_score() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommonProp::set_has_score() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommonProp::clear_has_score() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommonProp::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::int64 CommonProp::score() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.score)
  return score_;
}
inline void CommonProp::set_score(::google::protobuf::int64 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.score)
}

// optional int32 score_win_rounds = 15;
inline bool CommonProp::has_score_win_rounds() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommonProp::set_has_score_win_rounds() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommonProp::clear_has_score_win_rounds() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommonProp::clear_score_win_rounds() {
  score_win_rounds_ = 0;
  clear_has_score_win_rounds();
}
inline ::google::protobuf::int32 CommonProp::score_win_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.score_win_rounds)
  return score_win_rounds_;
}
inline void CommonProp::set_score_win_rounds(::google::protobuf::int32 value) {
  set_has_score_win_rounds();
  score_win_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.score_win_rounds)
}

// -------------------------------------------------------------------

// PlayerCommonLimit_Element

// optional int64 common_limit_id = 1;
inline bool PlayerCommonLimit_Element::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCommonLimit_Element::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCommonLimit_Element::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 PlayerCommonLimit_Element::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.common_limit_id)
  return common_limit_id_;
}
inline void PlayerCommonLimit_Element::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.common_limit_id)
}

// optional int32 time_stamp = 2;
inline bool PlayerCommonLimit_Element::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCommonLimit_Element::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCommonLimit_Element::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline ::google::protobuf::int32 PlayerCommonLimit_Element::time_stamp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.time_stamp)
  return time_stamp_;
}
inline void PlayerCommonLimit_Element::set_time_stamp(::google::protobuf::int32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.time_stamp)
}

// optional int32 count = 3;
inline bool PlayerCommonLimit_Element::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCommonLimit_Element::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCommonLimit_Element::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 PlayerCommonLimit_Element::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.count)
  return count_;
}
inline void PlayerCommonLimit_Element::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.count)
}

// -------------------------------------------------------------------

// PlayerCommonLimit

// repeated .Adoter.Asset.PlayerCommonLimit.Element elements = 1;
inline int PlayerCommonLimit::elements_size() const {
  return elements_.size();
}
inline void PlayerCommonLimit::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::PlayerCommonLimit_Element& PlayerCommonLimit::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::PlayerCommonLimit_Element* PlayerCommonLimit::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::PlayerCommonLimit_Element* PlayerCommonLimit::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >&
PlayerCommonLimit::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >*
PlayerCommonLimit::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerCommonLimit.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// PlayerCoolDown_Element

// optional int64 cool_down_id = 1;
inline bool PlayerCoolDown_Element::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCoolDown_Element::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCoolDown_Element::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCoolDown_Element::clear_cool_down_id() {
  cool_down_id_ = GOOGLE_LONGLONG(0);
  clear_has_cool_down_id();
}
inline ::google::protobuf::int64 PlayerCoolDown_Element::cool_down_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.Element.cool_down_id)
  return cool_down_id_;
}
inline void PlayerCoolDown_Element::set_cool_down_id(::google::protobuf::int64 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCoolDown.Element.cool_down_id)
}

// optional int32 time_stamp = 2;
inline bool PlayerCoolDown_Element::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCoolDown_Element::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCoolDown_Element::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCoolDown_Element::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline ::google::protobuf::int32 PlayerCoolDown_Element::time_stamp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.Element.time_stamp)
  return time_stamp_;
}
inline void PlayerCoolDown_Element::set_time_stamp(::google::protobuf::int32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCoolDown.Element.time_stamp)
}

// -------------------------------------------------------------------

// PlayerCoolDown

// repeated .Adoter.Asset.PlayerCoolDown.Element elements = 1;
inline int PlayerCoolDown::elements_size() const {
  return elements_.size();
}
inline void PlayerCoolDown::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::PlayerCoolDown_Element& PlayerCoolDown::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::PlayerCoolDown_Element* PlayerCoolDown::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::PlayerCoolDown_Element* PlayerCoolDown::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >&
PlayerCoolDown::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerCoolDown.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >*
PlayerCoolDown::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerCoolDown.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// Location

// optional double longitude = 1;
inline bool Location::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Location::longitude() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Location.longitude)
  return longitude_;
}
inline void Location::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Location.longitude)
}

// optional double latitude = 2;
inline bool Location::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Location::latitude() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Location.latitude)
  return latitude_;
}
inline void Location::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Location.latitude)
}

// -------------------------------------------------------------------

// ClientInfomation

// optional bytes ip_address = 1;
inline bool ClientInfomation::has_ip_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfomation::set_has_ip_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInfomation::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInfomation::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& ClientInfomation::ip_address() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.ip_address)
  return *ip_address_;
}
inline void ClientInfomation::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClientInfomation.ip_address)
}
inline void ClientInfomation::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClientInfomation.ip_address)
}
inline void ClientInfomation::set_ip_address(const void* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClientInfomation.ip_address)
}
inline ::std::string* ClientInfomation::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClientInfomation.ip_address)
  return ip_address_;
}
inline ::std::string* ClientInfomation::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfomation::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClientInfomation.ip_address)
}

// optional bytes system = 2;
inline bool ClientInfomation::has_system() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfomation::set_has_system() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInfomation::clear_has_system() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInfomation::clear_system() {
  if (system_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_->clear();
  }
  clear_has_system();
}
inline const ::std::string& ClientInfomation::system() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.system)
  return *system_;
}
inline void ClientInfomation::set_system(const ::std::string& value) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_ = new ::std::string;
  }
  system_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClientInfomation.system)
}
inline void ClientInfomation::set_system(const char* value) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_ = new ::std::string;
  }
  system_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClientInfomation.system)
}
inline void ClientInfomation::set_system(const void* value, size_t size) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_ = new ::std::string;
  }
  system_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClientInfomation.system)
}
inline ::std::string* ClientInfomation::mutable_system() {
  set_has_system();
  if (system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClientInfomation.system)
  return system_;
}
inline ::std::string* ClientInfomation::release_system() {
  clear_has_system();
  if (system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = system_;
    system_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfomation::set_allocated_system(::std::string* system) {
  if (system_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete system_;
  }
  if (system) {
    set_has_system();
    system_ = system;
  } else {
    clear_has_system();
    system_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClientInfomation.system)
}

// optional bytes phone_type = 3;
inline bool ClientInfomation::has_phone_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientInfomation::set_has_phone_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientInfomation::clear_has_phone_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientInfomation::clear_phone_type() {
  if (phone_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_type_->clear();
  }
  clear_has_phone_type();
}
inline const ::std::string& ClientInfomation::phone_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.phone_type)
  return *phone_type_;
}
inline void ClientInfomation::set_phone_type(const ::std::string& value) {
  set_has_phone_type();
  if (phone_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_type_ = new ::std::string;
  }
  phone_type_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClientInfomation.phone_type)
}
inline void ClientInfomation::set_phone_type(const char* value) {
  set_has_phone_type();
  if (phone_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_type_ = new ::std::string;
  }
  phone_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClientInfomation.phone_type)
}
inline void ClientInfomation::set_phone_type(const void* value, size_t size) {
  set_has_phone_type();
  if (phone_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_type_ = new ::std::string;
  }
  phone_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClientInfomation.phone_type)
}
inline ::std::string* ClientInfomation::mutable_phone_type() {
  set_has_phone_type();
  if (phone_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClientInfomation.phone_type)
  return phone_type_;
}
inline ::std::string* ClientInfomation::release_phone_type() {
  clear_has_phone_type();
  if (phone_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_type_;
    phone_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfomation::set_allocated_phone_type(::std::string* phone_type) {
  if (phone_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_type_;
  }
  if (phone_type) {
    set_has_phone_type();
    phone_type_ = phone_type;
  } else {
    clear_has_phone_type();
    phone_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClientInfomation.phone_type)
}

// optional .Adoter.Asset.Location location = 4;
inline bool ClientInfomation::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientInfomation::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientInfomation::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientInfomation::clear_location() {
  if (location_ != NULL) location_->::Adoter::Asset::Location::Clear();
  clear_has_location();
}
inline const ::Adoter::Asset::Location& ClientInfomation::location() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Adoter::Asset::Location* ClientInfomation::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::Adoter::Asset::Location;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClientInfomation.location)
  return location_;
}
inline ::Adoter::Asset::Location* ClientInfomation::release_location() {
  clear_has_location();
  ::Adoter::Asset::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void ClientInfomation::set_allocated_location(::Adoter::Asset::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClientInfomation.location)
}

// optional int32 version = 5;
inline bool ClientInfomation::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientInfomation::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientInfomation::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientInfomation::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 ClientInfomation::version() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.version)
  return version_;
}
inline void ClientInfomation::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClientInfomation.version)
}

// optional bytes imei = 6;
inline bool ClientInfomation::has_imei() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientInfomation::set_has_imei() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientInfomation::clear_has_imei() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientInfomation::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ClientInfomation::imei() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClientInfomation.imei)
  return *imei_;
}
inline void ClientInfomation::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClientInfomation.imei)
}
inline void ClientInfomation::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClientInfomation.imei)
}
inline void ClientInfomation::set_imei(const void* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClientInfomation.imei)
}
inline ::std::string* ClientInfomation::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClientInfomation.imei)
  return imei_;
}
inline ::std::string* ClientInfomation::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfomation::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClientInfomation.imei)
}

// -------------------------------------------------------------------

// Mail

// optional bytes title = 1;
inline bool Mail::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mail::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mail::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mail::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Mail::title() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.title)
  return *title_;
}
inline void Mail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.title)
}
inline void Mail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.title)
}
inline void Mail::set_title(const void* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.title)
}
inline ::std::string* Mail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.title)
  return title_;
}
inline ::std::string* Mail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.title)
}

// optional bytes send_player = 2 [default = "\347\263\273\347\273\237\351\202\256\344\273\266"];
inline bool Mail::has_send_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mail::set_has_send_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mail::clear_has_send_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mail::clear_send_player() {
  if (send_player_ != _default_send_player_) {
    send_player_->assign(*_default_send_player_);
  }
  clear_has_send_player();
}
inline const ::std::string& Mail::send_player() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.send_player)
  return *send_player_;
}
inline void Mail::set_send_player(const ::std::string& value) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.send_player)
}
inline void Mail::set_send_player(const char* value) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.send_player)
}
inline void Mail::set_send_player(const void* value, size_t size) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.send_player)
}
inline ::std::string* Mail::mutable_send_player() {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string(*_default_send_player_);
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.send_player)
  return send_player_;
}
inline ::std::string* Mail::release_send_player() {
  clear_has_send_player();
  if (send_player_ == _default_send_player_) {
    return NULL;
  } else {
    ::std::string* temp = send_player_;
    send_player_ = const_cast< ::std::string*>(_default_send_player_);
    return temp;
  }
}
inline void Mail::set_allocated_send_player(::std::string* send_player) {
  if (send_player_ != _default_send_player_) {
    delete send_player_;
  }
  if (send_player) {
    set_has_send_player();
    send_player_ = send_player;
  } else {
    clear_has_send_player();
    send_player_ = const_cast< ::std::string*>(_default_send_player_);
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.send_player)
}

// optional bytes content = 3;
inline bool Mail::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mail::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mail::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mail::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Mail::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.content)
  return *content_;
}
inline void Mail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.content)
}
inline void Mail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.content)
}
inline void Mail::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.content)
}
inline ::std::string* Mail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.content)
  return content_;
}
inline ::std::string* Mail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.content)
}

// optional int32 send_time = 4;
inline bool Mail::has_send_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mail::set_has_send_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mail::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mail::clear_send_time() {
  send_time_ = 0;
  clear_has_send_time();
}
inline ::google::protobuf::int32 Mail::send_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.send_time)
  return send_time_;
}
inline void Mail::set_send_time(::google::protobuf::int32 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.send_time)
}

// optional bool readed = 5;
inline bool Mail::has_readed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mail::set_has_readed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mail::clear_has_readed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mail::clear_readed() {
  readed_ = false;
  clear_has_readed();
}
inline bool Mail::readed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.readed)
  return readed_;
}
inline void Mail::set_readed(bool value) {
  set_has_readed();
  readed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.readed)
}

// repeated .Adoter.Asset.MailAttachment attachments = 6;
inline int Mail::attachments_size() const {
  return attachments_.size();
}
inline void Mail::clear_attachments() {
  attachments_.Clear();
}
inline const ::Adoter::Asset::MailAttachment& Mail::attachments(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.attachments)
  return attachments_.Get(index);
}
inline ::Adoter::Asset::MailAttachment* Mail::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.attachments)
  return attachments_.Mutable(index);
}
inline ::Adoter::Asset::MailAttachment* Mail::add_attachments() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Mail.attachments)
  return attachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MailAttachment >&
Mail::attachments() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Mail.attachments)
  return attachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MailAttachment >*
Mail::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Mail.attachments)
  return &attachments_;
}

// -------------------------------------------------------------------

// Player

// optional .Adoter.Asset.CommonProp common_prop = 1;
inline bool Player::has_common_prop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_common_prop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& Player::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* Player::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* Player::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Player::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.common_prop)
}

// optional bytes account = 2;
inline bool Player::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& Player::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.account)
  return *account_;
}
inline void Player::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.account)
}
inline void Player::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Player.account)
}
inline void Player::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Player.account)
}
inline ::std::string* Player::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.account)
  return account_;
}
inline ::std::string* Player::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Player::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.account)
}

// optional int64 server_id = 3;
inline bool Player::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player::clear_server_id() {
  server_id_ = GOOGLE_LONGLONG(0);
  clear_has_server_id();
}
inline ::google::protobuf::int64 Player::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.server_id)
  return server_id_;
}
inline void Player::set_server_id(::google::protobuf::int64 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.server_id)
}

// optional .Adoter.Asset.Inventory inventory = 4;
inline bool Player::has_inventory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_inventory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_inventory() {
  if (inventory_ != NULL) inventory_->::Adoter::Asset::Inventory::Clear();
  clear_has_inventory();
}
inline const ::Adoter::Asset::Inventory& Player::inventory() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.inventory)
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::Adoter::Asset::Inventory* Player::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) inventory_ = new ::Adoter::Asset::Inventory;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.inventory)
  return inventory_;
}
inline ::Adoter::Asset::Inventory* Player::release_inventory() {
  clear_has_inventory();
  ::Adoter::Asset::Inventory* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void Player::set_allocated_inventory(::Adoter::Asset::Inventory* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.inventory)
}

// optional .Adoter.Asset.PlayerCommonLimit common_limit = 5;
inline bool Player::has_common_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player::set_has_common_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player::clear_has_common_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player::clear_common_limit() {
  if (common_limit_ != NULL) common_limit_->::Adoter::Asset::PlayerCommonLimit::Clear();
  clear_has_common_limit();
}
inline const ::Adoter::Asset::PlayerCommonLimit& Player::common_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.common_limit)
  return common_limit_ != NULL ? *common_limit_ : *default_instance_->common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* Player::mutable_common_limit() {
  set_has_common_limit();
  if (common_limit_ == NULL) common_limit_ = new ::Adoter::Asset::PlayerCommonLimit;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.common_limit)
  return common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* Player::release_common_limit() {
  clear_has_common_limit();
  ::Adoter::Asset::PlayerCommonLimit* temp = common_limit_;
  common_limit_ = NULL;
  return temp;
}
inline void Player::set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit) {
  delete common_limit_;
  common_limit_ = common_limit;
  if (common_limit) {
    set_has_common_limit();
  } else {
    clear_has_common_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.common_limit)
}

// optional .Adoter.Asset.PlayerCoolDown cool_down = 6;
inline bool Player::has_cool_down() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player::set_has_cool_down() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player::clear_has_cool_down() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player::clear_cool_down() {
  if (cool_down_ != NULL) cool_down_->::Adoter::Asset::PlayerCoolDown::Clear();
  clear_has_cool_down();
}
inline const ::Adoter::Asset::PlayerCoolDown& Player::cool_down() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.cool_down)
  return cool_down_ != NULL ? *cool_down_ : *default_instance_->cool_down_;
}
inline ::Adoter::Asset::PlayerCoolDown* Player::mutable_cool_down() {
  set_has_cool_down();
  if (cool_down_ == NULL) cool_down_ = new ::Adoter::Asset::PlayerCoolDown;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.cool_down)
  return cool_down_;
}
inline ::Adoter::Asset::PlayerCoolDown* Player::release_cool_down() {
  clear_has_cool_down();
  ::Adoter::Asset::PlayerCoolDown* temp = cool_down_;
  cool_down_ = NULL;
  return temp;
}
inline void Player::set_allocated_cool_down(::Adoter::Asset::PlayerCoolDown* cool_down) {
  delete cool_down_;
  cool_down_ = cool_down;
  if (cool_down) {
    set_has_cool_down();
  } else {
    clear_has_cool_down();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.cool_down)
}

// optional int32 login_time = 7;
inline bool Player::has_login_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player::set_has_login_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player::clear_login_time() {
  login_time_ = 0;
  clear_has_login_time();
}
inline ::google::protobuf::int32 Player::login_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.login_time)
  return login_time_;
}
inline void Player::set_login_time(::google::protobuf::int32 value) {
  set_has_login_time();
  login_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.login_time)
}

// optional int32 logout_time = 8;
inline bool Player::has_logout_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player::set_has_logout_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player::clear_has_logout_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player::clear_logout_time() {
  logout_time_ = 0;
  clear_has_logout_time();
}
inline ::google::protobuf::int32 Player::logout_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.logout_time)
  return logout_time_;
}
inline void Player::set_logout_time(::google::protobuf::int32 value) {
  set_has_logout_time();
  logout_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.logout_time)
}

// repeated int32 sign_time = 9;
inline int Player::sign_time_size() const {
  return sign_time_.size();
}
inline void Player::clear_sign_time() {
  sign_time_.Clear();
}
inline ::google::protobuf::int32 Player::sign_time(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.sign_time)
  return sign_time_.Get(index);
}
inline void Player::set_sign_time(int index, ::google::protobuf::int32 value) {
  sign_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.sign_time)
}
inline void Player::add_sign_time(::google::protobuf::int32 value) {
  sign_time_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.sign_time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Player::sign_time() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.sign_time)
  return sign_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Player::mutable_sign_time() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.sign_time)
  return &sign_time_;
}

// repeated int64 mail_list_system = 10;
inline int Player::mail_list_system_size() const {
  return mail_list_system_.size();
}
inline void Player::clear_mail_list_system() {
  mail_list_system_.Clear();
}
inline ::google::protobuf::int64 Player::mail_list_system(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.mail_list_system)
  return mail_list_system_.Get(index);
}
inline void Player::set_mail_list_system(int index, ::google::protobuf::int64 value) {
  mail_list_system_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.mail_list_system)
}
inline void Player::add_mail_list_system(::google::protobuf::int64 value) {
  mail_list_system_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.mail_list_system)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Player::mail_list_system() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.mail_list_system)
  return mail_list_system_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Player::mutable_mail_list_system() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.mail_list_system)
  return &mail_list_system_;
}

// repeated .Adoter.Asset.Mail mail_list_customized = 11;
inline int Player::mail_list_customized_size() const {
  return mail_list_customized_.size();
}
inline void Player::clear_mail_list_customized() {
  mail_list_customized_.Clear();
}
inline const ::Adoter::Asset::Mail& Player::mail_list_customized(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.mail_list_customized)
  return mail_list_customized_.Get(index);
}
inline ::Adoter::Asset::Mail* Player::mutable_mail_list_customized(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.mail_list_customized)
  return mail_list_customized_.Mutable(index);
}
inline ::Adoter::Asset::Mail* Player::add_mail_list_customized() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.mail_list_customized)
  return mail_list_customized_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >&
Player::mail_list_customized() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.mail_list_customized)
  return mail_list_customized_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >*
Player::mutable_mail_list_customized() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.mail_list_customized)
  return &mail_list_customized_;
}

// optional .Adoter.Asset.PlayerSetting game_setting = 12;
inline bool Player::has_game_setting() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Player::set_has_game_setting() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Player::clear_has_game_setting() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Player::clear_game_setting() {
  if (game_setting_ != NULL) game_setting_->::Adoter::Asset::PlayerSetting::Clear();
  clear_has_game_setting();
}
inline const ::Adoter::Asset::PlayerSetting& Player::game_setting() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.game_setting)
  return game_setting_ != NULL ? *game_setting_ : *default_instance_->game_setting_;
}
inline ::Adoter::Asset::PlayerSetting* Player::mutable_game_setting() {
  set_has_game_setting();
  if (game_setting_ == NULL) game_setting_ = new ::Adoter::Asset::PlayerSetting;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.game_setting)
  return game_setting_;
}
inline ::Adoter::Asset::PlayerSetting* Player::release_game_setting() {
  clear_has_game_setting();
  ::Adoter::Asset::PlayerSetting* temp = game_setting_;
  game_setting_ = NULL;
  return temp;
}
inline void Player::set_allocated_game_setting(::Adoter::Asset::PlayerSetting* game_setting) {
  delete game_setting_;
  game_setting_ = game_setting;
  if (game_setting) {
    set_has_game_setting();
  } else {
    clear_has_game_setting();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.game_setting)
}

// repeated int64 room_history = 13;
inline int Player::room_history_size() const {
  return room_history_.size();
}
inline void Player::clear_room_history() {
  room_history_.Clear();
}
inline ::google::protobuf::int64 Player::room_history(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.room_history)
  return room_history_.Get(index);
}
inline void Player::set_room_history(int index, ::google::protobuf::int64 value) {
  room_history_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.room_history)
}
inline void Player::add_room_history(::google::protobuf::int64 value) {
  room_history_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.room_history)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Player::room_history() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.room_history)
  return room_history_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Player::mutable_room_history() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.room_history)
  return &room_history_;
}

// optional int64 room_id = 14;
inline bool Player::has_room_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Player::set_has_room_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Player::clear_has_room_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Player::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 Player::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.room_id)
  return room_id_;
}
inline void Player::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.room_id)
}

// optional bool card_count_changed = 15 [default = false];
inline bool Player::has_card_count_changed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Player::set_has_card_count_changed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Player::clear_has_card_count_changed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Player::clear_card_count_changed() {
  card_count_changed_ = false;
  clear_has_card_count_changed();
}
inline bool Player::card_count_changed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.card_count_changed)
  return card_count_changed_;
}
inline void Player::set_card_count_changed(bool value) {
  set_has_card_count_changed();
  card_count_changed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.card_count_changed)
}

// optional .Adoter.Asset.ROOM_TYPE matching_room_type = 16;
inline bool Player::has_matching_room_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Player::set_has_matching_room_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Player::clear_has_matching_room_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Player::clear_matching_room_type() {
  matching_room_type_ = 1;
  clear_has_matching_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE Player::matching_room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.matching_room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(matching_room_type_);
}
inline void Player::set_matching_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_matching_room_type();
  matching_room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.matching_room_type)
}

// repeated int64 clan_hosters = 17;
inline int Player::clan_hosters_size() const {
  return clan_hosters_.size();
}
inline void Player::clear_clan_hosters() {
  clan_hosters_.Clear();
}
inline ::google::protobuf::int64 Player::clan_hosters(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.clan_hosters)
  return clan_hosters_.Get(index);
}
inline void Player::set_clan_hosters(int index, ::google::protobuf::int64 value) {
  clan_hosters_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.clan_hosters)
}
inline void Player::add_clan_hosters(::google::protobuf::int64 value) {
  clan_hosters_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.clan_hosters)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Player::clan_hosters() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.clan_hosters)
  return clan_hosters_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Player::mutable_clan_hosters() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.clan_hosters)
  return &clan_hosters_;
}

// repeated int64 clan_joiners = 18;
inline int Player::clan_joiners_size() const {
  return clan_joiners_.size();
}
inline void Player::clear_clan_joiners() {
  clan_joiners_.Clear();
}
inline ::google::protobuf::int64 Player::clan_joiners(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.clan_joiners)
  return clan_joiners_.Get(index);
}
inline void Player::set_clan_joiners(int index, ::google::protobuf::int64 value) {
  clan_joiners_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.clan_joiners)
}
inline void Player::add_clan_joiners(::google::protobuf::int64 value) {
  clan_joiners_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.clan_joiners)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Player::clan_joiners() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.clan_joiners)
  return clan_joiners_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Player::mutable_clan_joiners() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.clan_joiners)
  return &clan_joiners_;
}

// -------------------------------------------------------------------

// Inventory_Element

// optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
inline bool Inventory_Element::has_inventory_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Inventory_Element::set_has_inventory_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Inventory_Element::clear_has_inventory_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Inventory_Element::clear_inventory_type() {
  inventory_type_ = 1;
  clear_has_inventory_type();
}
inline ::Adoter::Asset::INVENTORY_TYPE Inventory_Element::inventory_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.Element.inventory_type)
  return static_cast< ::Adoter::Asset::INVENTORY_TYPE >(inventory_type_);
}
inline void Inventory_Element::set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value) {
  assert(::Adoter::Asset::INVENTORY_TYPE_IsValid(value));
  set_has_inventory_type();
  inventory_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Inventory.Element.inventory_type)
}

// repeated .Adoter.Asset.Item_Item items = 2;
inline int Inventory_Element::items_size() const {
  return items_.size();
}
inline void Inventory_Element::clear_items() {
  items_.Clear();
}
inline const ::Adoter::Asset::Item_Item& Inventory_Element::items(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.Element.items)
  return items_.Get(index);
}
inline ::Adoter::Asset::Item_Item* Inventory_Element::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Inventory.Element.items)
  return items_.Mutable(index);
}
inline ::Adoter::Asset::Item_Item* Inventory_Element::add_items() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Inventory.Element.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >&
Inventory_Element::items() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Inventory.Element.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >*
Inventory_Element::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Inventory.Element.items)
  return &items_;
}

// -------------------------------------------------------------------

// Inventory

// repeated .Adoter.Asset.Inventory.Element inventory = 1;
inline int Inventory::inventory_size() const {
  return inventory_.size();
}
inline void Inventory::clear_inventory() {
  inventory_.Clear();
}
inline const ::Adoter::Asset::Inventory_Element& Inventory::inventory(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.inventory)
  return inventory_.Get(index);
}
inline ::Adoter::Asset::Inventory_Element* Inventory::mutable_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Inventory.inventory)
  return inventory_.Mutable(index);
}
inline ::Adoter::Asset::Inventory_Element* Inventory::add_inventory() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Inventory.inventory)
  return inventory_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >&
Inventory::inventory() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Inventory.inventory)
  return inventory_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >*
Inventory::mutable_inventory() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Inventory.inventory)
  return &inventory_;
}

// -------------------------------------------------------------------

// SystemMessage

// optional int64 player_id = 1;
inline bool SystemMessage::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemMessage::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemMessage::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemMessage::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 SystemMessage::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemMessage.player_id)
  return player_id_;
}
inline void SystemMessage::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemMessage.player_id)
}

// optional bytes name = 2;
inline bool SystemMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SystemMessage::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemMessage.name)
  return *name_;
}
inline void SystemMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemMessage.name)
}
inline void SystemMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SystemMessage.name)
}
inline void SystemMessage::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SystemMessage.name)
}
inline ::std::string* SystemMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SystemMessage.name)
  return name_;
}
inline ::std::string* SystemMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemMessage::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SystemMessage.name)
}

// optional int32 oper_time = 3;
inline bool SystemMessage::has_oper_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemMessage::set_has_oper_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemMessage::clear_has_oper_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemMessage::clear_oper_time() {
  oper_time_ = 0;
  clear_has_oper_time();
}
inline ::google::protobuf::int32 SystemMessage::oper_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemMessage.oper_time)
  return oper_time_;
}
inline void SystemMessage::set_oper_time(::google::protobuf::int32 value) {
  set_has_oper_time();
  oper_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemMessage.oper_time)
}

// optional .Adoter.Asset.CLAN_OPER_TYPE oper_type = 4;
inline bool SystemMessage::has_oper_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemMessage::set_has_oper_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemMessage::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemMessage::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::CLAN_OPER_TYPE SystemMessage::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemMessage.oper_type)
  return static_cast< ::Adoter::Asset::CLAN_OPER_TYPE >(oper_type_);
}
inline void SystemMessage::set_oper_type(::Adoter::Asset::CLAN_OPER_TYPE value) {
  assert(::Adoter::Asset::CLAN_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemMessage.oper_type)
}

// -------------------------------------------------------------------

// Clan_Member

// optional int64 player_id = 1;
inline bool Clan_Member::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan_Member::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan_Member::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan_Member::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 Clan_Member::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.Member.player_id)
  return player_id_;
}
inline void Clan_Member::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.Member.player_id)
}

// optional bytes name = 2;
inline bool Clan_Member::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clan_Member::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clan_Member::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clan_Member::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Clan_Member::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.Member.name)
  return *name_;
}
inline void Clan_Member::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.Member.name)
}
inline void Clan_Member::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Clan.Member.name)
}
inline void Clan_Member::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Clan.Member.name)
}
inline ::std::string* Clan_Member::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.Member.name)
  return name_;
}
inline ::std::string* Clan_Member::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Clan_Member::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Clan.Member.name)
}

// optional .Adoter.Asset.CLAN_MEM_STATUS_TYPE status = 3;
inline bool Clan_Member::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clan_Member::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clan_Member::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clan_Member::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::Adoter::Asset::CLAN_MEM_STATUS_TYPE Clan_Member::status() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.Member.status)
  return static_cast< ::Adoter::Asset::CLAN_MEM_STATUS_TYPE >(status_);
}
inline void Clan_Member::set_status(::Adoter::Asset::CLAN_MEM_STATUS_TYPE value) {
  assert(::Adoter::Asset::CLAN_MEM_STATUS_TYPE_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.Member.status)
}

// -------------------------------------------------------------------

// Clan_RoomHistory

// optional int64 room_id = 1;
inline bool Clan_RoomHistory::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan_RoomHistory::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan_RoomHistory::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan_RoomHistory::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 Clan_RoomHistory::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.RoomHistory.room_id)
  return room_id_;
}
inline void Clan_RoomHistory::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.RoomHistory.room_id)
}

// optional int32 battle_time = 2;
inline bool Clan_RoomHistory::has_battle_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clan_RoomHistory::set_has_battle_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clan_RoomHistory::clear_has_battle_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clan_RoomHistory::clear_battle_time() {
  battle_time_ = 0;
  clear_has_battle_time();
}
inline ::google::protobuf::int32 Clan_RoomHistory::battle_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.RoomHistory.battle_time)
  return battle_time_;
}
inline void Clan_RoomHistory::set_battle_time(::google::protobuf::int32 value) {
  set_has_battle_time();
  battle_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.RoomHistory.battle_time)
}

// -------------------------------------------------------------------

// Clan

// optional int64 clan_id = 1;
inline bool Clan::has_clan_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan::set_has_clan_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan::clear_clan_id() {
  clan_id_ = GOOGLE_LONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::int64 Clan::clan_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.clan_id)
  return clan_id_;
}
inline void Clan::set_clan_id(::google::protobuf::int64 value) {
  set_has_clan_id();
  clan_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.clan_id)
}

// optional bytes name = 2;
inline bool Clan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clan::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Clan::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.name)
  return *name_;
}
inline void Clan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.name)
}
inline void Clan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Clan.name)
}
inline void Clan::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Clan.name)
}
inline ::std::string* Clan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.name)
  return name_;
}
inline ::std::string* Clan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Clan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Clan.name)
}

// optional int32 created_time = 3;
inline bool Clan::has_created_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clan::set_has_created_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clan::clear_has_created_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clan::clear_created_time() {
  created_time_ = 0;
  clear_has_created_time();
}
inline ::google::protobuf::int32 Clan::created_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.created_time)
  return created_time_;
}
inline void Clan::set_created_time(::google::protobuf::int32 value) {
  set_has_created_time();
  created_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.created_time)
}

// optional int64 hoster_id = 4;
inline bool Clan::has_hoster_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Clan::set_has_hoster_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Clan::clear_has_hoster_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Clan::clear_hoster_id() {
  hoster_id_ = GOOGLE_LONGLONG(0);
  clear_has_hoster_id();
}
inline ::google::protobuf::int64 Clan::hoster_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.hoster_id)
  return hoster_id_;
}
inline void Clan::set_hoster_id(::google::protobuf::int64 value) {
  set_has_hoster_id();
  hoster_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.hoster_id)
}

// optional bytes hoster_name = 5;
inline bool Clan::has_hoster_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Clan::set_has_hoster_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Clan::clear_has_hoster_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Clan::clear_hoster_name() {
  if (hoster_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoster_name_->clear();
  }
  clear_has_hoster_name();
}
inline const ::std::string& Clan::hoster_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.hoster_name)
  return *hoster_name_;
}
inline void Clan::set_hoster_name(const ::std::string& value) {
  set_has_hoster_name();
  if (hoster_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoster_name_ = new ::std::string;
  }
  hoster_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.hoster_name)
}
inline void Clan::set_hoster_name(const char* value) {
  set_has_hoster_name();
  if (hoster_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoster_name_ = new ::std::string;
  }
  hoster_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Clan.hoster_name)
}
inline void Clan::set_hoster_name(const void* value, size_t size) {
  set_has_hoster_name();
  if (hoster_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoster_name_ = new ::std::string;
  }
  hoster_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Clan.hoster_name)
}
inline ::std::string* Clan::mutable_hoster_name() {
  set_has_hoster_name();
  if (hoster_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoster_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.hoster_name)
  return hoster_name_;
}
inline ::std::string* Clan::release_hoster_name() {
  clear_has_hoster_name();
  if (hoster_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hoster_name_;
    hoster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Clan::set_allocated_hoster_name(::std::string* hoster_name) {
  if (hoster_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hoster_name_;
  }
  if (hoster_name) {
    set_has_hoster_name();
    hoster_name_ = hoster_name;
  } else {
    clear_has_hoster_name();
    hoster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Clan.hoster_name)
}

// optional int64 room_card_count = 6;
inline bool Clan::has_room_card_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Clan::set_has_room_card_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Clan::clear_has_room_card_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Clan::clear_room_card_count() {
  room_card_count_ = GOOGLE_LONGLONG(0);
  clear_has_room_card_count();
}
inline ::google::protobuf::int64 Clan::room_card_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.room_card_count)
  return room_card_count_;
}
inline void Clan::set_room_card_count(::google::protobuf::int64 value) {
  set_has_room_card_count();
  room_card_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.room_card_count)
}

// optional bytes announcement = 7;
inline bool Clan::has_announcement() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Clan::set_has_announcement() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Clan::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Clan::clear_announcement() {
  if (announcement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_->clear();
  }
  clear_has_announcement();
}
inline const ::std::string& Clan::announcement() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.announcement)
  return *announcement_;
}
inline void Clan::set_announcement(const ::std::string& value) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.announcement)
}
inline void Clan::set_announcement(const char* value) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Clan.announcement)
}
inline void Clan::set_announcement(const void* value, size_t size) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Clan.announcement)
}
inline ::std::string* Clan::mutable_announcement() {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.announcement)
  return announcement_;
}
inline ::std::string* Clan::release_announcement() {
  clear_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = announcement_;
    announcement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Clan::set_allocated_announcement(::std::string* announcement) {
  if (announcement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete announcement_;
  }
  if (announcement) {
    set_has_announcement();
    announcement_ = announcement;
  } else {
    clear_has_announcement();
    announcement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Clan.announcement)
}

// repeated .Adoter.Asset.Clan.Member member_list = 8;
inline int Clan::member_list_size() const {
  return member_list_.size();
}
inline void Clan::clear_member_list() {
  member_list_.Clear();
}
inline const ::Adoter::Asset::Clan_Member& Clan::member_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.member_list)
  return member_list_.Get(index);
}
inline ::Adoter::Asset::Clan_Member* Clan::mutable_member_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.member_list)
  return member_list_.Mutable(index);
}
inline ::Adoter::Asset::Clan_Member* Clan::add_member_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Clan.member_list)
  return member_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_Member >&
Clan::member_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Clan.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_Member >*
Clan::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Clan.member_list)
  return &member_list_;
}

// optional bool dismiss = 9;
inline bool Clan::has_dismiss() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Clan::set_has_dismiss() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Clan::clear_has_dismiss() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Clan::clear_dismiss() {
  dismiss_ = false;
  clear_has_dismiss();
}
inline bool Clan::dismiss() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.dismiss)
  return dismiss_;
}
inline void Clan::set_dismiss(bool value) {
  set_has_dismiss();
  dismiss_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.dismiss)
}

// repeated .Adoter.Asset.Clan.RoomHistory battle_history = 10;
inline int Clan::battle_history_size() const {
  return battle_history_.size();
}
inline void Clan::clear_battle_history() {
  battle_history_.Clear();
}
inline const ::Adoter::Asset::Clan_RoomHistory& Clan::battle_history(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.battle_history)
  return battle_history_.Get(index);
}
inline ::Adoter::Asset::Clan_RoomHistory* Clan::mutable_battle_history(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.battle_history)
  return battle_history_.Mutable(index);
}
inline ::Adoter::Asset::Clan_RoomHistory* Clan::add_battle_history() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Clan.battle_history)
  return battle_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_RoomHistory >&
Clan::battle_history() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Clan.battle_history)
  return battle_history_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Clan_RoomHistory >*
Clan::mutable_battle_history() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Clan.battle_history)
  return &battle_history_;
}

// repeated .Adoter.Asset.SystemMessage message_list = 11;
inline int Clan::message_list_size() const {
  return message_list_.size();
}
inline void Clan::clear_message_list() {
  message_list_.Clear();
}
inline const ::Adoter::Asset::SystemMessage& Clan::message_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.message_list)
  return message_list_.Get(index);
}
inline ::Adoter::Asset::SystemMessage* Clan::mutable_message_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Clan.message_list)
  return message_list_.Mutable(index);
}
inline ::Adoter::Asset::SystemMessage* Clan::add_message_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Clan.message_list)
  return message_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SystemMessage >&
Clan::message_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Clan.message_list)
  return message_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SystemMessage >*
Clan::mutable_message_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Clan.message_list)
  return &message_list_;
}

// repeated int64 room_list = 12;
inline int Clan::room_list_size() const {
  return room_list_.size();
}
inline void Clan::clear_room_list() {
  room_list_.Clear();
}
inline ::google::protobuf::int64 Clan::room_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Clan.room_list)
  return room_list_.Get(index);
}
inline void Clan::set_room_list(int index, ::google::protobuf::int64 value) {
  room_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Clan.room_list)
}
inline void Clan::add_room_list(::google::protobuf::int64 value) {
  room_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Clan.room_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Clan::room_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Clan.room_list)
  return room_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Clan::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Clan.room_list)
  return &room_list_;
}

// -------------------------------------------------------------------

// ItemEquipment

// optional int32 star = 1;
inline bool ItemEquipment::has_star() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemEquipment::set_has_star() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemEquipment::clear_has_star() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemEquipment::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 ItemEquipment::star() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ItemEquipment.star)
  return star_;
}
inline void ItemEquipment::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ItemEquipment.star)
}

// -------------------------------------------------------------------

// Meta

// optional .Adoter.Asset.META_TYPE type_t = 1;
inline bool Meta::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Meta::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Meta::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Meta::clear_type_t() {
  type_t_ = 1;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Meta::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Meta.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Meta::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Meta.type_t)
}

// optional bytes stuff = 2;
inline bool Meta::has_stuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Meta::set_has_stuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Meta::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Meta::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& Meta::stuff() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Meta.stuff)
  return *stuff_;
}
inline void Meta::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Meta.stuff)
}
inline void Meta::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Meta.stuff)
}
inline void Meta::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Meta.stuff)
}
inline ::std::string* Meta::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Meta.stuff)
  return stuff_;
}
inline ::std::string* Meta::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Meta::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Meta.stuff)
}

// optional int64 player_id = 3;
inline bool Meta::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Meta::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Meta::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Meta::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 Meta::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Meta.player_id)
  return player_id_;
}
inline void Meta::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Meta.player_id)
}

// -------------------------------------------------------------------

// CreatePlayer

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_PLAYER];
inline bool CreatePlayer::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePlayer::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePlayer::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePlayer::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CreatePlayer::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreatePlayer.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CreatePlayer::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreatePlayer.type_t)
}

// optional int64 player_id = 2;
inline bool CreatePlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePlayer::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 CreatePlayer::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreatePlayer.player_id)
  return player_id_;
}
inline void CreatePlayer::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreatePlayer.player_id)
}

// -------------------------------------------------------------------

// Login

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGIN];
inline bool Login::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_type_t() {
  type_t_ = 52;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Login::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Login.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Login::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Login.type_t)
}

// optional .Adoter.Asset.Account account = 2;
inline bool Login::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_account() {
  if (account_ != NULL) account_->::Adoter::Asset::Account::Clear();
  clear_has_account();
}
inline const ::Adoter::Asset::Account& Login::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Login.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Adoter::Asset::Account* Login::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Adoter::Asset::Account;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Login.account)
  return account_;
}
inline ::Adoter::Asset::Account* Login::release_account() {
  clear_has_account();
  ::Adoter::Asset::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Login::set_allocated_account(::Adoter::Asset::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Login.account)
}

// -------------------------------------------------------------------

// WechatAccessToken

// optional bytes access_token = 1;
inline bool WechatAccessToken::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WechatAccessToken::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WechatAccessToken::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WechatAccessToken::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& WechatAccessToken::access_token() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.access_token)
  return *access_token_;
}
inline void WechatAccessToken::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.access_token)
}
inline void WechatAccessToken::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatAccessToken.access_token)
}
inline void WechatAccessToken::set_access_token(const void* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatAccessToken.access_token)
}
inline ::std::string* WechatAccessToken::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatAccessToken.access_token)
  return access_token_;
}
inline ::std::string* WechatAccessToken::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatAccessToken::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatAccessToken.access_token)
}

// optional int32 expires_in = 2;
inline bool WechatAccessToken::has_expires_in() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WechatAccessToken::set_has_expires_in() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WechatAccessToken::clear_has_expires_in() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WechatAccessToken::clear_expires_in() {
  expires_in_ = 0;
  clear_has_expires_in();
}
inline ::google::protobuf::int32 WechatAccessToken::expires_in() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.expires_in)
  return expires_in_;
}
inline void WechatAccessToken::set_expires_in(::google::protobuf::int32 value) {
  set_has_expires_in();
  expires_in_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.expires_in)
}

// optional bytes refresh_token = 3;
inline bool WechatAccessToken::has_refresh_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WechatAccessToken::set_has_refresh_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WechatAccessToken::clear_has_refresh_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WechatAccessToken::clear_refresh_token() {
  if (refresh_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_->clear();
  }
  clear_has_refresh_token();
}
inline const ::std::string& WechatAccessToken::refresh_token() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.refresh_token)
  return *refresh_token_;
}
inline void WechatAccessToken::set_refresh_token(const ::std::string& value) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.refresh_token)
}
inline void WechatAccessToken::set_refresh_token(const char* value) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatAccessToken.refresh_token)
}
inline void WechatAccessToken::set_refresh_token(const void* value, size_t size) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatAccessToken.refresh_token)
}
inline ::std::string* WechatAccessToken::mutable_refresh_token() {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatAccessToken.refresh_token)
  return refresh_token_;
}
inline ::std::string* WechatAccessToken::release_refresh_token() {
  clear_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = refresh_token_;
    refresh_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatAccessToken::set_allocated_refresh_token(::std::string* refresh_token) {
  if (refresh_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete refresh_token_;
  }
  if (refresh_token) {
    set_has_refresh_token();
    refresh_token_ = refresh_token;
  } else {
    clear_has_refresh_token();
    refresh_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatAccessToken.refresh_token)
}

// optional bytes openid = 4;
inline bool WechatAccessToken::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WechatAccessToken::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WechatAccessToken::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WechatAccessToken::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& WechatAccessToken::openid() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.openid)
  return *openid_;
}
inline void WechatAccessToken::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.openid)
}
inline void WechatAccessToken::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatAccessToken.openid)
}
inline void WechatAccessToken::set_openid(const void* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatAccessToken.openid)
}
inline ::std::string* WechatAccessToken::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatAccessToken.openid)
  return openid_;
}
inline ::std::string* WechatAccessToken::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatAccessToken::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatAccessToken.openid)
}

// optional bytes scope = 5;
inline bool WechatAccessToken::has_scope() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WechatAccessToken::set_has_scope() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WechatAccessToken::clear_has_scope() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WechatAccessToken::clear_scope() {
  if (scope_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scope_->clear();
  }
  clear_has_scope();
}
inline const ::std::string& WechatAccessToken::scope() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.scope)
  return *scope_;
}
inline void WechatAccessToken::set_scope(const ::std::string& value) {
  set_has_scope();
  if (scope_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scope_ = new ::std::string;
  }
  scope_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.scope)
}
inline void WechatAccessToken::set_scope(const char* value) {
  set_has_scope();
  if (scope_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scope_ = new ::std::string;
  }
  scope_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatAccessToken.scope)
}
inline void WechatAccessToken::set_scope(const void* value, size_t size) {
  set_has_scope();
  if (scope_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scope_ = new ::std::string;
  }
  scope_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatAccessToken.scope)
}
inline ::std::string* WechatAccessToken::mutable_scope() {
  set_has_scope();
  if (scope_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scope_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatAccessToken.scope)
  return scope_;
}
inline ::std::string* WechatAccessToken::release_scope() {
  clear_has_scope();
  if (scope_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scope_;
    scope_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatAccessToken::set_allocated_scope(::std::string* scope) {
  if (scope_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scope_;
  }
  if (scope) {
    set_has_scope();
    scope_ = scope;
  } else {
    clear_has_scope();
    scope_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatAccessToken.scope)
}

// optional bytes unionid = 6;
inline bool WechatAccessToken::has_unionid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WechatAccessToken::set_has_unionid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WechatAccessToken::clear_has_unionid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WechatAccessToken::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& WechatAccessToken::unionid() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatAccessToken.unionid)
  return *unionid_;
}
inline void WechatAccessToken::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatAccessToken.unionid)
}
inline void WechatAccessToken::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatAccessToken.unionid)
}
inline void WechatAccessToken::set_unionid(const void* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatAccessToken.unionid)
}
inline ::std::string* WechatAccessToken::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatAccessToken.unionid)
  return unionid_;
}
inline ::std::string* WechatAccessToken::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatAccessToken::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatAccessToken.unionid)
}

// -------------------------------------------------------------------

// WechatError

// optional int32 errcode = 1;
inline bool WechatError::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WechatError::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WechatError::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WechatError::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 WechatError::errcode() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatError.errcode)
  return errcode_;
}
inline void WechatError::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatError.errcode)
}

// optional bytes errmsg = 2;
inline bool WechatError::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WechatError::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WechatError::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WechatError::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& WechatError::errmsg() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatError.errmsg)
  return *errmsg_;
}
inline void WechatError::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatError.errmsg)
}
inline void WechatError::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatError.errmsg)
}
inline void WechatError::set_errmsg(const void* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatError.errmsg)
}
inline ::std::string* WechatError::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatError.errmsg)
  return errmsg_;
}
inline ::std::string* WechatError::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatError::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatError.errmsg)
}

// -------------------------------------------------------------------

// WechatLogin

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_WECHAT_LOGIN];
inline bool WechatLogin::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WechatLogin::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WechatLogin::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WechatLogin::clear_type_t() {
  type_t_ = 59;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE WechatLogin::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatLogin.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void WechatLogin::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatLogin.type_t)
}

// optional .Adoter.Asset.WechatUnion wechat = 2;
inline bool WechatLogin::has_wechat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WechatLogin::set_has_wechat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WechatLogin::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WechatLogin::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& WechatLogin::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatLogin.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* WechatLogin::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatLogin.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* WechatLogin::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void WechatLogin::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatLogin.wechat)
}

// -------------------------------------------------------------------

// SwitchAccount

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_SWITCH_ACCOUNT];
inline bool SwitchAccount::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchAccount::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchAccount::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchAccount::clear_type_t() {
  type_t_ = 60;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SwitchAccount::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SwitchAccount.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SwitchAccount::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SwitchAccount.type_t)
}

// optional bytes account_name = 2;
inline bool SwitchAccount::has_account_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchAccount::set_has_account_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchAccount::clear_has_account_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchAccount::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& SwitchAccount::account_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SwitchAccount.account_name)
  return *account_name_;
}
inline void SwitchAccount::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SwitchAccount.account_name)
}
inline void SwitchAccount::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SwitchAccount.account_name)
}
inline void SwitchAccount::set_account_name(const void* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SwitchAccount.account_name)
}
inline ::std::string* SwitchAccount::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SwitchAccount.account_name)
  return account_name_;
}
inline ::std::string* SwitchAccount::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SwitchAccount::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SwitchAccount.account_name)
}

// optional int64 player_id = 3;
inline bool SwitchAccount::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchAccount::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchAccount::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchAccount::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 SwitchAccount::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SwitchAccount.player_id)
  return player_id_;
}
inline void SwitchAccount::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SwitchAccount.player_id)
}

// -------------------------------------------------------------------

// GetRoomData

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_ROOM_DATA];
inline bool GetRoomData::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomData::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomData::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomData::clear_type_t() {
  type_t_ = 61;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GetRoomData::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetRoomData.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GetRoomData::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetRoomData.type_t)
}

// optional int64 room_id = 2;
inline bool GetRoomData::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRoomData::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRoomData::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRoomData::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 GetRoomData::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetRoomData.room_id)
  return room_id_;
}
inline void GetRoomData::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetRoomData.room_id)
}

// optional .Adoter.Asset.ROOM_SYNC_TYPE reason = 3;
inline bool GetRoomData::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetRoomData::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetRoomData::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetRoomData::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::Adoter::Asset::ROOM_SYNC_TYPE GetRoomData::reason() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetRoomData.reason)
  return static_cast< ::Adoter::Asset::ROOM_SYNC_TYPE >(reason_);
}
inline void GetRoomData::set_reason(::Adoter::Asset::ROOM_SYNC_TYPE value) {
  assert(::Adoter::Asset::ROOM_SYNC_TYPE_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetRoomData.reason)
}

// -------------------------------------------------------------------

// UpdateRoom

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_UPDATE_ROOM];
inline bool UpdateRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRoom::clear_type_t() {
  type_t_ = 62;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE UpdateRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UpdateRoom.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void UpdateRoom::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UpdateRoom.type_t)
}

// optional int64 voice_member_id = 2;
inline bool UpdateRoom::has_voice_member_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateRoom::set_has_voice_member_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateRoom::clear_has_voice_member_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateRoom::clear_voice_member_id() {
  voice_member_id_ = GOOGLE_LONGLONG(0);
  clear_has_voice_member_id();
}
inline ::google::protobuf::int64 UpdateRoom::voice_member_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UpdateRoom.voice_member_id)
  return voice_member_id_;
}
inline void UpdateRoom::set_voice_member_id(::google::protobuf::int64 value) {
  set_has_voice_member_id();
  voice_member_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UpdateRoom.voice_member_id)
}

// -------------------------------------------------------------------

// WechatUnion

// optional bytes openid = 1;
inline bool WechatUnion::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WechatUnion::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WechatUnion::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WechatUnion::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& WechatUnion::openid() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.openid)
  return *openid_;
}
inline void WechatUnion::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.openid)
}
inline void WechatUnion::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.openid)
}
inline void WechatUnion::set_openid(const void* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.openid)
}
inline ::std::string* WechatUnion::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.openid)
  return openid_;
}
inline ::std::string* WechatUnion::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.openid)
}

// optional bytes nickname = 2;
inline bool WechatUnion::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WechatUnion::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WechatUnion::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WechatUnion::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& WechatUnion::nickname() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.nickname)
  return *nickname_;
}
inline void WechatUnion::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.nickname)
}
inline void WechatUnion::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.nickname)
}
inline void WechatUnion::set_nickname(const void* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.nickname)
}
inline ::std::string* WechatUnion::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.nickname)
  return nickname_;
}
inline ::std::string* WechatUnion::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.nickname)
}

// optional int32 sex = 3;
inline bool WechatUnion::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WechatUnion::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WechatUnion::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WechatUnion::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 WechatUnion::sex() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.sex)
  return sex_;
}
inline void WechatUnion::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.sex)
}

// optional bytes province = 4;
inline bool WechatUnion::has_province() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WechatUnion::set_has_province() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WechatUnion::clear_has_province() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WechatUnion::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& WechatUnion::province() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.province)
  return *province_;
}
inline void WechatUnion::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.province)
}
inline void WechatUnion::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.province)
}
inline void WechatUnion::set_province(const void* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.province)
}
inline ::std::string* WechatUnion::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.province)
  return province_;
}
inline ::std::string* WechatUnion::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.province)
}

// optional bytes city = 5;
inline bool WechatUnion::has_city() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WechatUnion::set_has_city() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WechatUnion::clear_has_city() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WechatUnion::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& WechatUnion::city() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.city)
  return *city_;
}
inline void WechatUnion::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.city)
}
inline void WechatUnion::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.city)
}
inline void WechatUnion::set_city(const void* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.city)
}
inline ::std::string* WechatUnion::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.city)
  return city_;
}
inline ::std::string* WechatUnion::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.city)
}

// optional bytes country = 6;
inline bool WechatUnion::has_country() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WechatUnion::set_has_country() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WechatUnion::clear_has_country() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WechatUnion::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& WechatUnion::country() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.country)
  return *country_;
}
inline void WechatUnion::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.country)
}
inline void WechatUnion::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.country)
}
inline void WechatUnion::set_country(const void* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.country)
}
inline ::std::string* WechatUnion::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.country)
  return country_;
}
inline ::std::string* WechatUnion::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.country)
}

// optional bytes headimgurl = 7;
inline bool WechatUnion::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WechatUnion::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WechatUnion::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WechatUnion::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& WechatUnion::headimgurl() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.headimgurl)
  return *headimgurl_;
}
inline void WechatUnion::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.headimgurl)
}
inline void WechatUnion::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.headimgurl)
}
inline void WechatUnion::set_headimgurl(const void* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.headimgurl)
}
inline ::std::string* WechatUnion::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.headimgurl)
  return headimgurl_;
}
inline ::std::string* WechatUnion::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.headimgurl)
}

// repeated bytes privilege = 8;
inline int WechatUnion::privilege_size() const {
  return privilege_.size();
}
inline void WechatUnion::clear_privilege() {
  privilege_.Clear();
}
inline const ::std::string& WechatUnion::privilege(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.privilege)
  return privilege_.Get(index);
}
inline ::std::string* WechatUnion::mutable_privilege(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.privilege)
  return privilege_.Mutable(index);
}
inline void WechatUnion::set_privilege(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.privilege)
  privilege_.Mutable(index)->assign(value);
}
inline void WechatUnion::set_privilege(int index, const char* value) {
  privilege_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.privilege)
}
inline void WechatUnion::set_privilege(int index, const void* value, size_t size) {
  privilege_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.privilege)
}
inline ::std::string* WechatUnion::add_privilege() {
  return privilege_.Add();
}
inline void WechatUnion::add_privilege(const ::std::string& value) {
  privilege_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.WechatUnion.privilege)
}
inline void WechatUnion::add_privilege(const char* value) {
  privilege_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.WechatUnion.privilege)
}
inline void WechatUnion::add_privilege(const void* value, size_t size) {
  privilege_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.WechatUnion.privilege)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WechatUnion::privilege() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.WechatUnion.privilege)
  return privilege_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WechatUnion::mutable_privilege() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.WechatUnion.privilege)
  return &privilege_;
}

// optional bytes unionid = 9;
inline bool WechatUnion::has_unionid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WechatUnion::set_has_unionid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WechatUnion::clear_has_unionid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WechatUnion::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& WechatUnion::unionid() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WechatUnion.unionid)
  return *unionid_;
}
inline void WechatUnion::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.WechatUnion.unionid)
}
inline void WechatUnion::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.WechatUnion.unionid)
}
inline void WechatUnion::set_unionid(const void* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.WechatUnion.unionid)
}
inline ::std::string* WechatUnion::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WechatUnion.unionid)
  return unionid_;
}
inline ::std::string* WechatUnion::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WechatUnion::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WechatUnion.unionid)
}

// -------------------------------------------------------------------

// Logout

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGOUT];
inline bool Logout::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logout::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logout::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logout::clear_type_t() {
  type_t_ = 53;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Logout::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Logout.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Logout::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Logout.type_t)
}

// -------------------------------------------------------------------

// EnterGame

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_ENTER_GAME];
inline bool EnterGame::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGame::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGame::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGame::clear_type_t() {
  type_t_ = 55;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE EnterGame::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterGame.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void EnterGame::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterGame.type_t)
}

// optional int64 player_id = 2;
inline bool EnterGame::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGame::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGame::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGame::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 EnterGame::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterGame.player_id)
  return player_id_;
}
inline void EnterGame::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterGame.player_id)
}

// -------------------------------------------------------------------

// UpdateClientData

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_UPDATE_CLIENT_DATA];
inline bool UpdateClientData::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateClientData::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateClientData::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateClientData::clear_type_t() {
  type_t_ = 15;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE UpdateClientData::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UpdateClientData.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void UpdateClientData::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UpdateClientData.type_t)
}

// optional .Adoter.Asset.ClientInfomation client_info = 2;
inline bool UpdateClientData::has_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateClientData::set_has_client_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateClientData::clear_has_client_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateClientData::clear_client_info() {
  if (client_info_ != NULL) client_info_->::Adoter::Asset::ClientInfomation::Clear();
  clear_has_client_info();
}
inline const ::Adoter::Asset::ClientInfomation& UpdateClientData::client_info() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UpdateClientData.client_info)
  return client_info_ != NULL ? *client_info_ : *default_instance_->client_info_;
}
inline ::Adoter::Asset::ClientInfomation* UpdateClientData::mutable_client_info() {
  set_has_client_info();
  if (client_info_ == NULL) client_info_ = new ::Adoter::Asset::ClientInfomation;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.UpdateClientData.client_info)
  return client_info_;
}
inline ::Adoter::Asset::ClientInfomation* UpdateClientData::release_client_info() {
  clear_has_client_info();
  ::Adoter::Asset::ClientInfomation* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline void UpdateClientData::set_allocated_client_info(::Adoter::Asset::ClientInfomation* client_info) {
  delete client_info_;
  client_info_ = client_info;
  if (client_info) {
    set_has_client_info();
  } else {
    clear_has_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.UpdateClientData.client_info)
}

// -------------------------------------------------------------------

// SystemChat

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SYSTEM_CHAT];
inline bool SystemChat::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemChat::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemChat::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemChat::clear_type_t() {
  type_t_ = 16;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SystemChat::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemChat.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SystemChat::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemChat.type_t)
}

// optional .Adoter.Asset.CHAT_TYPE chat_type = 2;
inline bool SystemChat::has_chat_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemChat::set_has_chat_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemChat::clear_has_chat_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemChat::clear_chat_type() {
  chat_type_ = 1;
  clear_has_chat_type();
}
inline ::Adoter::Asset::CHAT_TYPE SystemChat::chat_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemChat.chat_type)
  return static_cast< ::Adoter::Asset::CHAT_TYPE >(chat_type_);
}
inline void SystemChat::set_chat_type(::Adoter::Asset::CHAT_TYPE value) {
  assert(::Adoter::Asset::CHAT_TYPE_IsValid(value));
  set_has_chat_type();
  chat_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemChat.chat_type)
}

// optional .Adoter.Asset.POSITION_TYPE position = 3;
inline bool SystemChat::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemChat::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemChat::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemChat::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE SystemChat::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemChat.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void SystemChat::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemChat.position)
}

// optional int32 index = 4;
inline bool SystemChat::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemChat::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemChat::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemChat::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 SystemChat::index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemChat.index)
  return index_;
}
inline void SystemChat::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemChat.index)
}

// -------------------------------------------------------------------

// Room

// optional int64 room_id = 1;
inline bool Room::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 Room::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.room_id)
  return room_id_;
}
inline void Room::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.room_id)
}

// optional .Adoter.Asset.ROOM_TYPE room_type = 2;
inline bool Room::has_room_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room::set_has_room_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room::clear_room_type() {
  room_type_ = 1;
  clear_has_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE Room::room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(room_type_);
}
inline void Room::set_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.room_type)
}

// optional bytes enter_password = 3;
inline bool Room::has_enter_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room::set_has_enter_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room::clear_has_enter_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room::clear_enter_password() {
  if (enter_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_->clear();
  }
  clear_has_enter_password();
}
inline const ::std::string& Room::enter_password() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.enter_password)
  return *enter_password_;
}
inline void Room::set_enter_password(const ::std::string& value) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.enter_password)
}
inline void Room::set_enter_password(const char* value) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Room.enter_password)
}
inline void Room::set_enter_password(const void* value, size_t size) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Room.enter_password)
}
inline ::std::string* Room::mutable_enter_password() {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Room.enter_password)
  return enter_password_;
}
inline ::std::string* Room::release_enter_password() {
  clear_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enter_password_;
    enter_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Room::set_allocated_enter_password(::std::string* enter_password) {
  if (enter_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enter_password_;
  }
  if (enter_password) {
    set_has_enter_password();
    enter_password_ = enter_password;
  } else {
    clear_has_enter_password();
    enter_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Room.enter_password)
}

// optional .Adoter.Asset.RoomOptions options = 4;
inline bool Room::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room::clear_options() {
  if (options_ != NULL) options_->::Adoter::Asset::RoomOptions::Clear();
  clear_has_options();
}
inline const ::Adoter::Asset::RoomOptions& Room::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::Adoter::Asset::RoomOptions* Room::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::Adoter::Asset::RoomOptions;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Room.options)
  return options_;
}
inline ::Adoter::Asset::RoomOptions* Room::release_options() {
  clear_has_options();
  ::Adoter::Asset::RoomOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void Room::set_allocated_options(::Adoter::Asset::RoomOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Room.options)
}

// optional int64 clan_id = 5;
inline bool Room::has_clan_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room::set_has_clan_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room::clear_clan_id() {
  clan_id_ = GOOGLE_LONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::int64 Room::clan_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.clan_id)
  return clan_id_;
}
inline void Room::set_clan_id(::google::protobuf::int64 value) {
  set_has_clan_id();
  clan_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.clan_id)
}

// -------------------------------------------------------------------

// CreateRoom

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_ROOM];
inline bool CreateRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CreateRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreateRoom.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CreateRoom::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreateRoom.type_t)
}

// optional .Adoter.Asset.Room room = 2;
inline bool CreateRoom::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom::clear_room() {
  if (room_ != NULL) room_->::Adoter::Asset::Room::Clear();
  clear_has_room();
}
inline const ::Adoter::Asset::Room& CreateRoom::room() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreateRoom.room)
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::Adoter::Asset::Room* CreateRoom::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::Adoter::Asset::Room;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CreateRoom.room)
  return room_;
}
inline ::Adoter::Asset::Room* CreateRoom::release_room() {
  clear_has_room();
  ::Adoter::Asset::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline void CreateRoom::set_allocated_room(::Adoter::Asset::Room* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CreateRoom.room)
}

// -------------------------------------------------------------------

// EnterRoom

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ENTER_ROOM];
inline bool EnterRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoom::clear_type_t() {
  type_t_ = 8;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE EnterRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void EnterRoom::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.type_t)
}

// optional .Adoter.Asset.Room room = 2;
inline bool EnterRoom::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoom::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoom::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoom::clear_room() {
  if (room_ != NULL) room_->::Adoter::Asset::Room::Clear();
  clear_has_room();
}
inline const ::Adoter::Asset::Room& EnterRoom::room() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.room)
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::Adoter::Asset::Room* EnterRoom::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::Adoter::Asset::Room;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.EnterRoom.room)
  return room_;
}
inline ::Adoter::Asset::Room* EnterRoom::release_room() {
  clear_has_room();
  ::Adoter::Asset::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline void EnterRoom::set_allocated_room(::Adoter::Asset::Room* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.EnterRoom.room)
}

// optional .Adoter.Asset.ERROR_CODE error_code = 3;
inline bool EnterRoom::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoom::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoom::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoom::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::ERROR_CODE EnterRoom::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.error_code)
  return static_cast< ::Adoter::Asset::ERROR_CODE >(error_code_);
}
inline void EnterRoom::set_error_code(::Adoter::Asset::ERROR_CODE value) {
  assert(::Adoter::Asset::ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.error_code)
}

// optional .Adoter.Asset.EnterRoom.ENTER_TYPE enter_type = 4;
inline bool EnterRoom::has_enter_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoom::set_has_enter_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoom::clear_has_enter_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoom::clear_enter_type() {
  enter_type_ = 1;
  clear_has_enter_type();
}
inline ::Adoter::Asset::EnterRoom_ENTER_TYPE EnterRoom::enter_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.enter_type)
  return static_cast< ::Adoter::Asset::EnterRoom_ENTER_TYPE >(enter_type_);
}
inline void EnterRoom::set_enter_type(::Adoter::Asset::EnterRoom_ENTER_TYPE value) {
  assert(::Adoter::Asset::EnterRoom_ENTER_TYPE_IsValid(value));
  set_has_enter_type();
  enter_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.enter_type)
}

// -------------------------------------------------------------------

// Sign

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SIGN];
inline bool Sign::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sign::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sign::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sign::clear_type_t() {
  type_t_ = 9;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Sign::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Sign.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Sign::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Sign.type_t)
}

// optional bool success = 2;
inline bool Sign::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sign::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sign::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sign::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Sign::success() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Sign.success)
  return success_;
}
inline void Sign::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Sign.success)
}

// -------------------------------------------------------------------

// PlayerLuckyPlate

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_LUCKY_PLATE];
inline bool PlayerLuckyPlate::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerLuckyPlate::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerLuckyPlate::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerLuckyPlate::clear_type_t() {
  type_t_ = 10;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerLuckyPlate::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerLuckyPlate::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.type_t)
}

// optional int64 plate_id = 2;
inline bool PlayerLuckyPlate::has_plate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerLuckyPlate::set_has_plate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerLuckyPlate::clear_has_plate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerLuckyPlate::clear_plate_id() {
  plate_id_ = GOOGLE_LONGLONG(0);
  clear_has_plate_id();
}
inline ::google::protobuf::int64 PlayerLuckyPlate::plate_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.plate_id)
  return plate_id_;
}
inline void PlayerLuckyPlate::set_plate_id(::google::protobuf::int64 value) {
  set_has_plate_id();
  plate_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.plate_id)
}

// optional int32 result = 3;
inline bool PlayerLuckyPlate::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerLuckyPlate::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerLuckyPlate::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerLuckyPlate::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlayerLuckyPlate::result() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.result)
  return result_;
}
inline void PlayerLuckyPlate::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.result)
}

// -------------------------------------------------------------------

// RandomSaizi

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_RANDOM_SAIZI];
inline bool RandomSaizi::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomSaizi::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomSaizi::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomSaizi::clear_type_t() {
  type_t_ = 11;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RandomSaizi::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RandomSaizi.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RandomSaizi::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RandomSaizi.type_t)
}

// optional .Adoter.Asset.RandomSaizi.REASON_TYPE reason_type = 2;
inline bool RandomSaizi::has_reason_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomSaizi::set_has_reason_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomSaizi::clear_has_reason_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomSaizi::clear_reason_type() {
  reason_type_ = 1;
  clear_has_reason_type();
}
inline ::Adoter::Asset::RandomSaizi_REASON_TYPE RandomSaizi::reason_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RandomSaizi.reason_type)
  return static_cast< ::Adoter::Asset::RandomSaizi_REASON_TYPE >(reason_type_);
}
inline void RandomSaizi::set_reason_type(::Adoter::Asset::RandomSaizi_REASON_TYPE value) {
  assert(::Adoter::Asset::RandomSaizi_REASON_TYPE_IsValid(value));
  set_has_reason_type();
  reason_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RandomSaizi.reason_type)
}

// repeated int32 random_result = 3;
inline int RandomSaizi::random_result_size() const {
  return random_result_.size();
}
inline void RandomSaizi::clear_random_result() {
  random_result_.Clear();
}
inline ::google::protobuf::int32 RandomSaizi::random_result(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RandomSaizi.random_result)
  return random_result_.Get(index);
}
inline void RandomSaizi::set_random_result(int index, ::google::protobuf::int32 value) {
  random_result_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RandomSaizi.random_result)
}
inline void RandomSaizi::add_random_result(::google::protobuf::int32 value) {
  random_result_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.RandomSaizi.random_result)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RandomSaizi::random_result() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RandomSaizi.random_result)
  return random_result_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RandomSaizi::mutable_random_result() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RandomSaizi.random_result)
  return &random_result_;
}

// optional .Adoter.Asset.PaiElement pai = 4;
inline bool RandomSaizi::has_pai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RandomSaizi::set_has_pai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RandomSaizi::clear_has_pai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RandomSaizi::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& RandomSaizi::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RandomSaizi.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* RandomSaizi::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RandomSaizi.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* RandomSaizi::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void RandomSaizi::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RandomSaizi.pai)
}

// optional bool has_rand_saizi = 5;
inline bool RandomSaizi::has_has_rand_saizi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RandomSaizi::set_has_has_rand_saizi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RandomSaizi::clear_has_has_rand_saizi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RandomSaizi::clear_has_rand_saizi() {
  has_rand_saizi_ = false;
  clear_has_has_rand_saizi();
}
inline bool RandomSaizi::has_rand_saizi() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RandomSaizi.has_rand_saizi)
  return has_rand_saizi_;
}
inline void RandomSaizi::set_has_rand_saizi(bool value) {
  set_has_has_rand_saizi();
  has_rand_saizi_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RandomSaizi.has_rand_saizi)
}

// -------------------------------------------------------------------

// SayHi

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SAY_HI];
inline bool SayHi::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SayHi::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SayHi::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SayHi::clear_type_t() {
  type_t_ = 12;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SayHi::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SayHi.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SayHi::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SayHi.type_t)
}

// optional int32 heart_count = 2;
inline bool SayHi::has_heart_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SayHi::set_has_heart_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SayHi::clear_has_heart_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SayHi::clear_heart_count() {
  heart_count_ = 0;
  clear_has_heart_count();
}
inline ::google::protobuf::int32 SayHi::heart_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SayHi.heart_count)
  return heart_count_;
}
inline void SayHi::set_heart_count(::google::protobuf::int32 value) {
  set_has_heart_count();
  heart_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SayHi.heart_count)
}

// -------------------------------------------------------------------

// GuestLogin

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GUEST_LOGIN];
inline bool GuestLogin::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuestLogin::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuestLogin::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuestLogin::clear_type_t() {
  type_t_ = 13;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GuestLogin::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GuestLogin.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GuestLogin::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GuestLogin.type_t)
}

// optional bytes account = 2;
inline bool GuestLogin::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuestLogin::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuestLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuestLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& GuestLogin::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GuestLogin.account)
  return *account_;
}
inline void GuestLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.GuestLogin.account)
}
inline void GuestLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.GuestLogin.account)
}
inline void GuestLogin::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.GuestLogin.account)
}
inline ::std::string* GuestLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GuestLogin.account)
  return account_;
}
inline ::std::string* GuestLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GuestLogin.account)
}

// -------------------------------------------------------------------

// PlayerSetting

// optional bool music = 1 [default = true];
inline bool PlayerSetting::has_music() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSetting::set_has_music() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSetting::clear_has_music() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSetting::clear_music() {
  music_ = true;
  clear_has_music();
}
inline bool PlayerSetting::music() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.music)
  return music_;
}
inline void PlayerSetting::set_music(bool value) {
  set_has_music();
  music_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.music)
}

// optional bool voice = 2 [default = true];
inline bool PlayerSetting::has_voice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSetting::set_has_voice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSetting::clear_has_voice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSetting::clear_voice() {
  voice_ = true;
  clear_has_voice();
}
inline bool PlayerSetting::voice() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.voice)
  return voice_;
}
inline void PlayerSetting::set_voice(bool value) {
  set_has_voice();
  voice_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.voice)
}

// optional bool audio = 3 [default = true];
inline bool PlayerSetting::has_audio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSetting::set_has_audio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSetting::clear_has_audio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSetting::clear_audio() {
  audio_ = true;
  clear_has_audio();
}
inline bool PlayerSetting::audio() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.audio)
  return audio_;
}
inline void PlayerSetting::set_audio(bool value) {
  set_has_audio();
  audio_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.audio)
}

// optional bool click_push = 4;
inline bool PlayerSetting::has_click_push() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerSetting::set_has_click_push() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerSetting::clear_has_click_push() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerSetting::clear_click_push() {
  click_push_ = false;
  clear_has_click_push();
}
inline bool PlayerSetting::click_push() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.click_push)
  return click_push_;
}
inline void PlayerSetting::set_click_push(bool value) {
  set_has_click_push();
  click_push_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.click_push)
}

// optional .Adoter.Asset.ZHUOBU_TYPE zhuobu_type = 5;
inline bool PlayerSetting::has_zhuobu_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerSetting::set_has_zhuobu_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerSetting::clear_has_zhuobu_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerSetting::clear_zhuobu_type() {
  zhuobu_type_ = 1;
  clear_has_zhuobu_type();
}
inline ::Adoter::Asset::ZHUOBU_TYPE PlayerSetting::zhuobu_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.zhuobu_type)
  return static_cast< ::Adoter::Asset::ZHUOBU_TYPE >(zhuobu_type_);
}
inline void PlayerSetting::set_zhuobu_type(::Adoter::Asset::ZHUOBU_TYPE value) {
  assert(::Adoter::Asset::ZHUOBU_TYPE_IsValid(value));
  set_has_zhuobu_type();
  zhuobu_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.zhuobu_type)
}

// optional .Adoter.Asset.CARD_COLOR_TYPE card_color_type = 6;
inline bool PlayerSetting::has_card_color_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerSetting::set_has_card_color_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerSetting::clear_has_card_color_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerSetting::clear_card_color_type() {
  card_color_type_ = 1;
  clear_has_card_color_type();
}
inline ::Adoter::Asset::CARD_COLOR_TYPE PlayerSetting::card_color_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerSetting.card_color_type)
  return static_cast< ::Adoter::Asset::CARD_COLOR_TYPE >(card_color_type_);
}
inline void PlayerSetting::set_card_color_type(::Adoter::Asset::CARD_COLOR_TYPE value) {
  assert(::Adoter::Asset::CARD_COLOR_TYPE_IsValid(value));
  set_has_card_color_type();
  card_color_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerSetting.card_color_type)
}

// -------------------------------------------------------------------

// GameSetting

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_SETTING];
inline bool GameSetting::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSetting::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSetting::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSetting::clear_type_t() {
  type_t_ = 14;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameSetting::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameSetting.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameSetting::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameSetting.type_t)
}

// optional .Adoter.Asset.PlayerSetting game_setting = 2;
inline bool GameSetting::has_game_setting() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSetting::set_has_game_setting() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSetting::clear_has_game_setting() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSetting::clear_game_setting() {
  if (game_setting_ != NULL) game_setting_->::Adoter::Asset::PlayerSetting::Clear();
  clear_has_game_setting();
}
inline const ::Adoter::Asset::PlayerSetting& GameSetting::game_setting() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameSetting.game_setting)
  return game_setting_ != NULL ? *game_setting_ : *default_instance_->game_setting_;
}
inline ::Adoter::Asset::PlayerSetting* GameSetting::mutable_game_setting() {
  set_has_game_setting();
  if (game_setting_ == NULL) game_setting_ = new ::Adoter::Asset::PlayerSetting;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameSetting.game_setting)
  return game_setting_;
}
inline ::Adoter::Asset::PlayerSetting* GameSetting::release_game_setting() {
  clear_has_game_setting();
  ::Adoter::Asset::PlayerSetting* temp = game_setting_;
  game_setting_ = NULL;
  return temp;
}
inline void GameSetting::set_allocated_game_setting(::Adoter::Asset::PlayerSetting* game_setting) {
  delete game_setting_;
  game_setting_ = game_setting;
  if (game_setting) {
    set_has_game_setting();
  } else {
    clear_has_game_setting();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GameSetting.game_setting)
}

// -------------------------------------------------------------------

// BattleHistory

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ROOM_HISTORY];
inline bool BattleHistory::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleHistory::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleHistory::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleHistory::clear_type_t() {
  type_t_ = 17;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE BattleHistory::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleHistory.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void BattleHistory::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BattleHistory.type_t)
}

// optional int32 start_index = 2;
inline bool BattleHistory::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleHistory::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleHistory::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleHistory::clear_start_index() {
  start_index_ = 0;
  clear_has_start_index();
}
inline ::google::protobuf::int32 BattleHistory::start_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleHistory.start_index)
  return start_index_;
}
inline void BattleHistory::set_start_index(::google::protobuf::int32 value) {
  set_has_start_index();
  start_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BattleHistory.start_index)
}

// optional int32 end_index = 3;
inline bool BattleHistory::has_end_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleHistory::set_has_end_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleHistory::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleHistory::clear_end_index() {
  end_index_ = 0;
  clear_has_end_index();
}
inline ::google::protobuf::int32 BattleHistory::end_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleHistory.end_index)
  return end_index_;
}
inline void BattleHistory::set_end_index(::google::protobuf::int32 value) {
  set_has_end_index();
  end_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BattleHistory.end_index)
}

// repeated .Adoter.Asset.RoomHistory history_list = 4;
inline int BattleHistory::history_list_size() const {
  return history_list_.size();
}
inline void BattleHistory::clear_history_list() {
  history_list_.Clear();
}
inline const ::Adoter::Asset::RoomHistory& BattleHistory::history_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleHistory.history_list)
  return history_list_.Get(index);
}
inline ::Adoter::Asset::RoomHistory* BattleHistory::mutable_history_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.BattleHistory.history_list)
  return history_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomHistory* BattleHistory::add_history_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.BattleHistory.history_list)
  return history_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomHistory >&
BattleHistory::history_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.BattleHistory.history_list)
  return history_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomHistory >*
BattleHistory::mutable_history_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.BattleHistory.history_list)
  return &history_list_;
}

// -------------------------------------------------------------------

// UserRecharge

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_RECHARGE];
inline bool UserRecharge::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRecharge::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRecharge::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRecharge::clear_type_t() {
  type_t_ = 18;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE UserRecharge::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UserRecharge.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void UserRecharge::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UserRecharge.type_t)
}

// optional .Adoter.Asset.RECHARGE_TYPE recharge_type = 2;
inline bool UserRecharge::has_recharge_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRecharge::set_has_recharge_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRecharge::clear_has_recharge_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRecharge::clear_recharge_type() {
  recharge_type_ = 1;
  clear_has_recharge_type();
}
inline ::Adoter::Asset::RECHARGE_TYPE UserRecharge::recharge_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UserRecharge.recharge_type)
  return static_cast< ::Adoter::Asset::RECHARGE_TYPE >(recharge_type_);
}
inline void UserRecharge::set_recharge_type(::Adoter::Asset::RECHARGE_TYPE value) {
  assert(::Adoter::Asset::RECHARGE_TYPE_IsValid(value));
  set_has_recharge_type();
  recharge_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UserRecharge.recharge_type)
}

// optional bytes product_id = 3;
inline bool UserRecharge::has_product_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRecharge::set_has_product_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRecharge::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRecharge::clear_product_id() {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_->clear();
  }
  clear_has_product_id();
}
inline const ::std::string& UserRecharge::product_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UserRecharge.product_id)
  return *product_id_;
}
inline void UserRecharge::set_product_id(const ::std::string& value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.UserRecharge.product_id)
}
inline void UserRecharge::set_product_id(const char* value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.UserRecharge.product_id)
}
inline void UserRecharge::set_product_id(const void* value, size_t size) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.UserRecharge.product_id)
}
inline ::std::string* UserRecharge::mutable_product_id() {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.UserRecharge.product_id)
  return product_id_;
}
inline ::std::string* UserRecharge::release_product_id() {
  clear_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_id_;
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserRecharge::set_allocated_product_id(::std::string* product_id) {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_id_;
  }
  if (product_id) {
    set_has_product_id();
    product_id_ = product_id;
  } else {
    clear_has_product_id();
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.UserRecharge.product_id)
}

// optional int32 price = 4;
inline bool UserRecharge::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRecharge::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRecharge::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRecharge::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 UserRecharge::price() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.UserRecharge.price)
  return price_;
}
inline void UserRecharge::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.UserRecharge.price)
}

// -------------------------------------------------------------------

// PlayBack_PlayerElement

// optional int64 player_id = 1;
inline bool PlayBack_PlayerElement::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayBack_PlayerElement::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayBack_PlayerElement::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayBack_PlayerElement::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PlayBack_PlayerElement::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.PlayerElement.player_id)
  return player_id_;
}
inline void PlayBack_PlayerElement::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayBack.PlayerElement.player_id)
}

// optional .Adoter.Asset.POSITION_TYPE position = 2;
inline bool PlayBack_PlayerElement::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayBack_PlayerElement::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayBack_PlayerElement::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayBack_PlayerElement::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PlayBack_PlayerElement::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.PlayerElement.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PlayBack_PlayerElement::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayBack.PlayerElement.position)
}

// optional .Adoter.Asset.CommonProp common_prop = 3;
inline bool PlayBack_PlayerElement::has_common_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayBack_PlayerElement::set_has_common_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayBack_PlayerElement::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayBack_PlayerElement::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& PlayBack_PlayerElement::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.PlayerElement.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* PlayBack_PlayerElement::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.PlayerElement.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* PlayBack_PlayerElement::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void PlayBack_PlayerElement::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayBack.PlayerElement.common_prop)
}

// optional .Adoter.Asset.WechatUnion wechat = 4;
inline bool PlayBack_PlayerElement::has_wechat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayBack_PlayerElement::set_has_wechat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayBack_PlayerElement::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayBack_PlayerElement::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& PlayBack_PlayerElement::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.PlayerElement.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* PlayBack_PlayerElement::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.PlayerElement.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* PlayBack_PlayerElement::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void PlayBack_PlayerElement::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayBack.PlayerElement.wechat)
}

// repeated .Adoter.Asset.MultiplePai pai_list = 5;
inline int PlayBack_PlayerElement::pai_list_size() const {
  return pai_list_.size();
}
inline void PlayBack_PlayerElement::clear_pai_list() {
  pai_list_.Clear();
}
inline const ::Adoter::Asset::MultiplePai& PlayBack_PlayerElement::pai_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.PlayerElement.pai_list)
  return pai_list_.Get(index);
}
inline ::Adoter::Asset::MultiplePai* PlayBack_PlayerElement::mutable_pai_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.PlayerElement.pai_list)
  return pai_list_.Mutable(index);
}
inline ::Adoter::Asset::MultiplePai* PlayBack_PlayerElement::add_pai_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayBack.PlayerElement.pai_list)
  return pai_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
PlayBack_PlayerElement::pai_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayBack.PlayerElement.pai_list)
  return pai_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
PlayBack_PlayerElement::mutable_pai_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayBack.PlayerElement.pai_list)
  return &pai_list_;
}

// -------------------------------------------------------------------

// PlayBack

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PLAY_BACK];
inline bool PlayBack::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayBack::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayBack::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayBack::clear_type_t() {
  type_t_ = 19;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayBack::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayBack::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayBack.type_t)
}

// optional int64 room_id = 2;
inline bool PlayBack::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayBack::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayBack::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayBack::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 PlayBack::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.room_id)
  return room_id_;
}
inline void PlayBack::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayBack.room_id)
}

// optional .Adoter.Asset.RoomOptions options = 3;
inline bool PlayBack::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayBack::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayBack::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayBack::clear_options() {
  if (options_ != NULL) options_->::Adoter::Asset::RoomOptions::Clear();
  clear_has_options();
}
inline const ::Adoter::Asset::RoomOptions& PlayBack::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::Adoter::Asset::RoomOptions* PlayBack::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::Adoter::Asset::RoomOptions;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.options)
  return options_;
}
inline ::Adoter::Asset::RoomOptions* PlayBack::release_options() {
  clear_has_options();
  ::Adoter::Asset::RoomOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void PlayBack::set_allocated_options(::Adoter::Asset::RoomOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayBack.options)
}

// optional int32 game_index = 4;
inline bool PlayBack::has_game_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayBack::set_has_game_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayBack::clear_has_game_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayBack::clear_game_index() {
  game_index_ = 0;
  clear_has_game_index();
}
inline ::google::protobuf::int32 PlayBack::game_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.game_index)
  return game_index_;
}
inline void PlayBack::set_game_index(::google::protobuf::int32 value) {
  set_has_game_index();
  game_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayBack.game_index)
}

// repeated .Adoter.Asset.PlayBack.PlayerElement player_list = 5;
inline int PlayBack::player_list_size() const {
  return player_list_.size();
}
inline void PlayBack::clear_player_list() {
  player_list_.Clear();
}
inline const ::Adoter::Asset::PlayBack_PlayerElement& PlayBack::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.player_list)
  return player_list_.Get(index);
}
inline ::Adoter::Asset::PlayBack_PlayerElement* PlayBack::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.player_list)
  return player_list_.Mutable(index);
}
inline ::Adoter::Asset::PlayBack_PlayerElement* PlayBack::add_player_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayBack.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayBack_PlayerElement >&
PlayBack::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayBack.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayBack_PlayerElement >*
PlayBack::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayBack.player_list)
  return &player_list_;
}

// repeated .Adoter.Asset.PaiOperation oper_list = 6;
inline int PlayBack::oper_list_size() const {
  return oper_list_.size();
}
inline void PlayBack::clear_oper_list() {
  oper_list_.Clear();
}
inline const ::Adoter::Asset::PaiOperation& PlayBack::oper_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayBack.oper_list)
  return oper_list_.Get(index);
}
inline ::Adoter::Asset::PaiOperation* PlayBack::mutable_oper_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayBack.oper_list)
  return oper_list_.Mutable(index);
}
inline ::Adoter::Asset::PaiOperation* PlayBack::add_oper_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayBack.oper_list)
  return oper_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperation >&
PlayBack::oper_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayBack.oper_list)
  return oper_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperation >*
PlayBack::mutable_oper_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayBack.oper_list)
  return &oper_list_;
}

// -------------------------------------------------------------------

// GetReward

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_REWARD];
inline bool GetReward::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetReward::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetReward::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetReward::clear_type_t() {
  type_t_ = 56;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GetReward::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GetReward::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.type_t)
}

// optional .Adoter.Asset.GetReward.GET_REWARD_REASON reason = 2;
inline bool GetReward::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetReward::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetReward::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetReward::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::Adoter::Asset::GetReward_GET_REWARD_REASON GetReward::reason() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.reason)
  return static_cast< ::Adoter::Asset::GetReward_GET_REWARD_REASON >(reason_);
}
inline void GetReward::set_reason(::Adoter::Asset::GetReward_GET_REWARD_REASON value) {
  assert(::Adoter::Asset::GetReward_GET_REWARD_REASON_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.reason)
}

// optional int64 reward_id = 3;
inline bool GetReward::has_reward_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetReward::set_has_reward_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetReward::clear_has_reward_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetReward::clear_reward_id() {
  reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_reward_id();
}
inline ::google::protobuf::int64 GetReward::reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.reward_id)
  return reward_id_;
}
inline void GetReward::set_reward_id(::google::protobuf::int64 value) {
  set_has_reward_id();
  reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.reward_id)
}

// -------------------------------------------------------------------

// PaiOperationCache

// optional int64 player_id = 1;
inline bool PaiOperationCache::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationCache::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationCache::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationCache::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PaiOperationCache::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.player_id)
  return player_id_;
}
inline void PaiOperationCache::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationCache.player_id)
}

// optional int64 source_player_id = 2;
inline bool PaiOperationCache::has_source_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiOperationCache::set_has_source_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiOperationCache::clear_has_source_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiOperationCache::clear_source_player_id() {
  source_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_source_player_id();
}
inline ::google::protobuf::int64 PaiOperationCache::source_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.source_player_id)
  return source_player_id_;
}
inline void PaiOperationCache::set_source_player_id(::google::protobuf::int64 value) {
  set_has_source_player_id();
  source_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationCache.source_player_id)
}

// optional int32 time_out = 3;
inline bool PaiOperationCache::has_time_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperationCache::set_has_time_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperationCache::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperationCache::clear_time_out() {
  time_out_ = 0;
  clear_has_time_out();
}
inline ::google::protobuf::int32 PaiOperationCache::time_out() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.time_out)
  return time_out_;
}
inline void PaiOperationCache::set_time_out(::google::protobuf::int32 value) {
  set_has_time_out();
  time_out_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationCache.time_out)
}

// optional .Adoter.Asset.PaiElement pai = 4;
inline bool PaiOperationCache::has_pai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaiOperationCache::set_has_pai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaiOperationCache::clear_has_pai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaiOperationCache::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationCache::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationCache::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationCache.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationCache::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperationCache::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperationCache.pai)
}

// repeated .Adoter.Asset.PAI_OPER_TYPE oper_list = 5;
inline int PaiOperationCache::oper_list_size() const {
  return oper_list_.size();
}
inline void PaiOperationCache::clear_oper_list() {
  oper_list_.Clear();
}
inline ::Adoter::Asset::PAI_OPER_TYPE PaiOperationCache::oper_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.oper_list)
  return static_cast< ::Adoter::Asset::PAI_OPER_TYPE >(oper_list_.Get(index));
}
inline void PaiOperationCache::set_oper_list(int index, ::Adoter::Asset::PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PAI_OPER_TYPE_IsValid(value));
  oper_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationCache.oper_list)
}
inline void PaiOperationCache::add_oper_list(::Adoter::Asset::PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PAI_OPER_TYPE_IsValid(value));
  oper_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationCache.oper_list)
}
inline const ::google::protobuf::RepeatedField<int>&
PaiOperationCache::oper_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationCache.oper_list)
  return oper_list_;
}
inline ::google::protobuf::RepeatedField<int>*
PaiOperationCache::mutable_oper_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationCache.oper_list)
  return &oper_list_;
}

// repeated .Adoter.Asset.PaiElement ting_pais = 6;
inline int PaiOperationCache::ting_pais_size() const {
  return ting_pais_.size();
}
inline void PaiOperationCache::clear_ting_pais() {
  ting_pais_.Clear();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationCache::ting_pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationCache.ting_pais)
  return ting_pais_.Get(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperationCache::mutable_ting_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationCache.ting_pais)
  return ting_pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperationCache::add_ting_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationCache.ting_pais)
  return ting_pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
PaiOperationCache::ting_pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationCache.ting_pais)
  return ting_pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
PaiOperationCache::mutable_ting_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationCache.ting_pais)
  return &ting_pais_;
}

// -------------------------------------------------------------------

// PaiOperation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PAI_OPERATION];
inline bool PaiOperation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperation::clear_type_t() {
  type_t_ = 4;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiOperation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiOperation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.type_t)
}

// optional .Adoter.Asset.PAI_OPER_TYPE oper_type = 2;
inline bool PaiOperation::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiOperation::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiOperation::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiOperation::clear_oper_type() {
  oper_type_ = 0;
  clear_has_oper_type();
}
inline ::Adoter::Asset::PAI_OPER_TYPE PaiOperation::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.oper_type)
  return static_cast< ::Adoter::Asset::PAI_OPER_TYPE >(oper_type_);
}
inline void PaiOperation::set_oper_type(::Adoter::Asset::PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PAI_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.oper_type)
}

// optional .Adoter.Asset.POSITION_TYPE position = 3;
inline bool PaiOperation::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperation::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperation::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperation::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PaiOperation::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PaiOperation::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.position)
}

// repeated .Adoter.Asset.PaiElement pais = 4;
inline int PaiOperation::pais_size() const {
  return pais_.size();
}
inline void PaiOperation::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiElement& PaiOperation::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperation::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperation.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperation::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperation.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
PaiOperation::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperation.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
PaiOperation::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperation.pais)
  return &pais_;
}

// optional .Adoter.Asset.PaiElement pai = 5;
inline bool PaiOperation::has_pai() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaiOperation::set_has_pai() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaiOperation::clear_has_pai() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaiOperation::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperation::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperation::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperation.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperation::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperation::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperation.pai)
}

// -------------------------------------------------------------------

// GameOperation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_OPERATION];
inline bool GameOperation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameOperation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameOperation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameOperation::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameOperation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameOperation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.type_t)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
inline bool GameOperation::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameOperation::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameOperation::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameOperation::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE GameOperation::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void GameOperation::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.oper_type)
}

// optional int64 source_player_id = 3;
inline bool GameOperation::has_source_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameOperation::set_has_source_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameOperation::clear_has_source_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameOperation::clear_source_player_id() {
  source_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_source_player_id();
}
inline ::google::protobuf::int64 GameOperation::source_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.source_player_id)
  return source_player_id_;
}
inline void GameOperation::set_source_player_id(::google::protobuf::int64 value) {
  set_has_source_player_id();
  source_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.source_player_id)
}

// optional int64 destination_player_id = 4;
inline bool GameOperation::has_destination_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameOperation::set_has_destination_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameOperation::clear_has_destination_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameOperation::clear_destination_player_id() {
  destination_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_destination_player_id();
}
inline ::google::protobuf::int64 GameOperation::destination_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.destination_player_id)
  return destination_player_id_;
}
inline void GameOperation::set_destination_player_id(::google::protobuf::int64 value) {
  set_has_destination_player_id();
  destination_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.destination_player_id)
}

// optional .Adoter.Asset.ERROR_CODE error_code = 5;
inline bool GameOperation::has_error_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameOperation::set_has_error_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameOperation::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameOperation::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::ERROR_CODE GameOperation::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.error_code)
  return static_cast< ::Adoter::Asset::ERROR_CODE >(error_code_);
}
inline void GameOperation::set_error_code(::Adoter::Asset::ERROR_CODE value) {
  assert(::Adoter::Asset::ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.error_code)
}

// optional int32 beilv = 6;
inline bool GameOperation::has_beilv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameOperation::set_has_beilv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameOperation::clear_has_beilv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameOperation::clear_beilv() {
  beilv_ = 0;
  clear_has_beilv();
}
inline ::google::protobuf::int32 GameOperation::beilv() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.beilv)
  return beilv_;
}
inline void GameOperation::set_beilv(::google::protobuf::int32 value) {
  set_has_beilv();
  beilv_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.beilv)
}

// -------------------------------------------------------------------

// BuySomething

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_BUY_SOMETHING];
inline bool BuySomething::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuySomething::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuySomething::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuySomething::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE BuySomething::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void BuySomething::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.type_t)
}

// optional int64 mall_id = 2;
inline bool BuySomething::has_mall_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuySomething::set_has_mall_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuySomething::clear_has_mall_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuySomething::clear_mall_id() {
  mall_id_ = GOOGLE_LONGLONG(0);
  clear_has_mall_id();
}
inline ::google::protobuf::int64 BuySomething::mall_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.mall_id)
  return mall_id_;
}
inline void BuySomething::set_mall_id(::google::protobuf::int64 value) {
  set_has_mall_id();
  mall_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.mall_id)
}

// optional .Adoter.Asset.ERROR_CODE result = 3;
inline bool BuySomething::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuySomething::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuySomething::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuySomething::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::Adoter::Asset::ERROR_CODE BuySomething::result() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.result)
  return static_cast< ::Adoter::Asset::ERROR_CODE >(result_);
}
inline void BuySomething::set_result(::Adoter::Asset::ERROR_CODE value) {
  assert(::Adoter::Asset::ERROR_CODE_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.result)
}

// -------------------------------------------------------------------

// LoadScene

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOAD_SCENE];
inline bool LoadScene::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadScene::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadScene::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadScene::clear_type_t() {
  type_t_ = 57;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE LoadScene::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void LoadScene::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.type_t)
}

// optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 2;
inline bool LoadScene::has_load_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadScene::set_has_load_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadScene::clear_has_load_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadScene::clear_load_type() {
  load_type_ = 1;
  clear_has_load_type();
}
inline ::Adoter::Asset::LOAD_SCENE_TYPE LoadScene::load_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.load_type)
  return static_cast< ::Adoter::Asset::LOAD_SCENE_TYPE >(load_type_);
}
inline void LoadScene::set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value) {
  assert(::Adoter::Asset::LOAD_SCENE_TYPE_IsValid(value));
  set_has_load_type();
  load_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.load_type)
}

// optional int64 scene_id = 3;
inline bool LoadScene::has_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadScene::set_has_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadScene::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadScene::clear_scene_id() {
  scene_id_ = GOOGLE_LONGLONG(0);
  clear_has_scene_id();
}
inline ::google::protobuf::int64 LoadScene::scene_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.scene_id)
  return scene_id_;
}
inline void LoadScene::set_scene_id(::google::protobuf::int64 value) {
  set_has_scene_id();
  scene_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.scene_id)
}

// -------------------------------------------------------------------

// ReConnect

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_RECONNECT];
inline bool ReConnect::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReConnect::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReConnect::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReConnect::clear_type_t() {
  type_t_ = 58;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE ReConnect::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ReConnect.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void ReConnect::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ReConnect.type_t)
}

// optional int64 player_id = 2;
inline bool ReConnect::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReConnect::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReConnect::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReConnect::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 ReConnect::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ReConnect.player_id)
  return player_id_;
}
inline void ReConnect::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ReConnect.player_id)
}

// optional .Adoter.Asset.Account account = 3;
inline bool ReConnect::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReConnect::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReConnect::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReConnect::clear_account() {
  if (account_ != NULL) account_->::Adoter::Asset::Account::Clear();
  clear_has_account();
}
inline const ::Adoter::Asset::Account& ReConnect::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ReConnect.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Adoter::Asset::Account* ReConnect::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Adoter::Asset::Account;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ReConnect.account)
  return account_;
}
inline ::Adoter::Asset::Account* ReConnect::release_account() {
  clear_has_account();
  ::Adoter::Asset::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void ReConnect::set_allocated_account(::Adoter::Asset::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ReConnect.account)
}

// -------------------------------------------------------------------

// MatchStats_MatchingRoom

// optional .Adoter.Asset.ROOM_TYPE room_type = 1;
inline bool MatchStats_MatchingRoom::has_room_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStats_MatchingRoom::set_has_room_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStats_MatchingRoom::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStats_MatchingRoom::clear_room_type() {
  room_type_ = 1;
  clear_has_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE MatchStats_MatchingRoom::room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStats.MatchingRoom.room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(room_type_);
}
inline void MatchStats_MatchingRoom::set_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStats.MatchingRoom.room_type)
}

// optional int32 player_count = 2;
inline bool MatchStats_MatchingRoom::has_player_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchStats_MatchingRoom::set_has_player_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchStats_MatchingRoom::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchStats_MatchingRoom::clear_player_count() {
  player_count_ = 0;
  clear_has_player_count();
}
inline ::google::protobuf::int32 MatchStats_MatchingRoom::player_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStats.MatchingRoom.player_count)
  return player_count_;
}
inline void MatchStats_MatchingRoom::set_player_count(::google::protobuf::int32 value) {
  set_has_player_count();
  player_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStats.MatchingRoom.player_count)
}

// -------------------------------------------------------------------

// MatchStats

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_MATCHING_STATS];
inline bool MatchStats::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStats::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStats::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStats::clear_type_t() {
  type_t_ = 20;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE MatchStats::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStats.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void MatchStats::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MatchStats.type_t)
}

// repeated .Adoter.Asset.MatchStats.MatchingRoom room_list = 2;
inline int MatchStats::room_list_size() const {
  return room_list_.size();
}
inline void MatchStats::clear_room_list() {
  room_list_.Clear();
}
inline const ::Adoter::Asset::MatchStats_MatchingRoom& MatchStats::room_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MatchStats.room_list)
  return room_list_.Get(index);
}
inline ::Adoter::Asset::MatchStats_MatchingRoom* MatchStats::mutable_room_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MatchStats.room_list)
  return room_list_.Mutable(index);
}
inline ::Adoter::Asset::MatchStats_MatchingRoom* MatchStats::add_room_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.MatchStats.room_list)
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStats_MatchingRoom >&
MatchStats::room_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MatchStats.room_list)
  return room_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MatchStats_MatchingRoom >*
MatchStats::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MatchStats.room_list)
  return &room_list_;
}

// -------------------------------------------------------------------

// ClanOperation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CLAN_OPERATION];
inline bool ClanOperation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanOperation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanOperation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanOperation::clear_type_t() {
  type_t_ = 21;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE ClanOperation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void ClanOperation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.type_t)
}

// optional .Adoter.Asset.CLAN_OPER_TYPE oper_type = 2;
inline bool ClanOperation::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanOperation::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanOperation::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanOperation::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::CLAN_OPER_TYPE ClanOperation::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.oper_type)
  return static_cast< ::Adoter::Asset::CLAN_OPER_TYPE >(oper_type_);
}
inline void ClanOperation::set_oper_type(::Adoter::Asset::CLAN_OPER_TYPE value) {
  assert(::Adoter::Asset::CLAN_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.oper_type)
}

// optional int64 clan_id = 3;
inline bool ClanOperation::has_clan_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanOperation::set_has_clan_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanOperation::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanOperation::clear_clan_id() {
  clan_id_ = GOOGLE_LONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::int64 ClanOperation::clan_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.clan_id)
  return clan_id_;
}
inline void ClanOperation::set_clan_id(::google::protobuf::int64 value) {
  set_has_clan_id();
  clan_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.clan_id)
}

// optional int32 oper_result = 4;
inline bool ClanOperation::has_oper_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanOperation::set_has_oper_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanOperation::clear_has_oper_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanOperation::clear_oper_result() {
  oper_result_ = 0;
  clear_has_oper_result();
}
inline ::google::protobuf::int32 ClanOperation::oper_result() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.oper_result)
  return oper_result_;
}
inline void ClanOperation::set_oper_result(::google::protobuf::int32 value) {
  set_has_oper_result();
  oper_result_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.oper_result)
}

// optional bytes name = 5;
inline bool ClanOperation::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanOperation::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanOperation::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanOperation::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanOperation::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.name)
  return *name_;
}
inline void ClanOperation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.name)
}
inline void ClanOperation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClanOperation.name)
}
inline void ClanOperation::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClanOperation.name)
}
inline ::std::string* ClanOperation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanOperation.name)
  return name_;
}
inline ::std::string* ClanOperation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClanOperation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClanOperation.name)
}

// optional bytes announcement = 6;
inline bool ClanOperation::has_announcement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanOperation::set_has_announcement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanOperation::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanOperation::clear_announcement() {
  if (announcement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_->clear();
  }
  clear_has_announcement();
}
inline const ::std::string& ClanOperation::announcement() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.announcement)
  return *announcement_;
}
inline void ClanOperation::set_announcement(const ::std::string& value) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.announcement)
}
inline void ClanOperation::set_announcement(const char* value) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClanOperation.announcement)
}
inline void ClanOperation::set_announcement(const void* value, size_t size) {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  announcement_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClanOperation.announcement)
}
inline ::std::string* ClanOperation::mutable_announcement() {
  set_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    announcement_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanOperation.announcement)
  return announcement_;
}
inline ::std::string* ClanOperation::release_announcement() {
  clear_has_announcement();
  if (announcement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = announcement_;
    announcement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClanOperation::set_allocated_announcement(::std::string* announcement) {
  if (announcement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete announcement_;
  }
  if (announcement) {
    set_has_announcement();
    announcement_ = announcement;
  } else {
    clear_has_announcement();
    announcement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClanOperation.announcement)
}

// optional int64 dest_player_id = 7;
inline bool ClanOperation::has_dest_player_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanOperation::set_has_dest_player_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanOperation::clear_has_dest_player_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanOperation::clear_dest_player_id() {
  dest_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_dest_player_id();
}
inline ::google::protobuf::int64 ClanOperation::dest_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.dest_player_id)
  return dest_player_id_;
}
inline void ClanOperation::set_dest_player_id(::google::protobuf::int64 value) {
  set_has_dest_player_id();
  dest_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.dest_player_id)
}

// optional int32 recharge_count = 8;
inline bool ClanOperation::has_recharge_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClanOperation::set_has_recharge_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClanOperation::clear_has_recharge_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClanOperation::clear_recharge_count() {
  recharge_count_ = 0;
  clear_has_recharge_count();
}
inline ::google::protobuf::int32 ClanOperation::recharge_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.recharge_count)
  return recharge_count_;
}
inline void ClanOperation::set_recharge_count(::google::protobuf::int32 value) {
  set_has_recharge_count();
  recharge_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.recharge_count)
}

// optional .Adoter.Asset.Clan clan = 9;
inline bool ClanOperation::has_clan() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClanOperation::set_has_clan() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClanOperation::clear_has_clan() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClanOperation::clear_clan() {
  if (clan_ != NULL) clan_->::Adoter::Asset::Clan::Clear();
  clear_has_clan();
}
inline const ::Adoter::Asset::Clan& ClanOperation::clan() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.clan)
  return clan_ != NULL ? *clan_ : *default_instance_->clan_;
}
inline ::Adoter::Asset::Clan* ClanOperation::mutable_clan() {
  set_has_clan();
  if (clan_ == NULL) clan_ = new ::Adoter::Asset::Clan;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanOperation.clan)
  return clan_;
}
inline ::Adoter::Asset::Clan* ClanOperation::release_clan() {
  clear_has_clan();
  ::Adoter::Asset::Clan* temp = clan_;
  clan_ = NULL;
  return temp;
}
inline void ClanOperation::set_allocated_clan(::Adoter::Asset::Clan* clan) {
  delete clan_;
  clan_ = clan;
  if (clan) {
    set_has_clan();
  } else {
    clear_has_clan();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClanOperation.clan)
}

// optional int32 room_query_start_index = 10;
inline bool ClanOperation::has_room_query_start_index() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClanOperation::set_has_room_query_start_index() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClanOperation::clear_has_room_query_start_index() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClanOperation::clear_room_query_start_index() {
  room_query_start_index_ = 0;
  clear_has_room_query_start_index();
}
inline ::google::protobuf::int32 ClanOperation::room_query_start_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.room_query_start_index)
  return room_query_start_index_;
}
inline void ClanOperation::set_room_query_start_index(::google::protobuf::int32 value) {
  set_has_room_query_start_index();
  room_query_start_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.room_query_start_index)
}

// optional int32 room_query_end_index = 11;
inline bool ClanOperation::has_room_query_end_index() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClanOperation::set_has_room_query_end_index() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClanOperation::clear_has_room_query_end_index() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClanOperation::clear_room_query_end_index() {
  room_query_end_index_ = 0;
  clear_has_room_query_end_index();
}
inline ::google::protobuf::int32 ClanOperation::room_query_end_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.room_query_end_index)
  return room_query_end_index_;
}
inline void ClanOperation::set_room_query_end_index(::google::protobuf::int32 value) {
  set_has_room_query_end_index();
  room_query_end_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanOperation.room_query_end_index)
}

// repeated .Adoter.Asset.RoomQueryResult room_list = 12;
inline int ClanOperation::room_list_size() const {
  return room_list_.size();
}
inline void ClanOperation::clear_room_list() {
  room_list_.Clear();
}
inline const ::Adoter::Asset::RoomQueryResult& ClanOperation::room_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanOperation.room_list)
  return room_list_.Get(index);
}
inline ::Adoter::Asset::RoomQueryResult* ClanOperation::mutable_room_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanOperation.room_list)
  return room_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomQueryResult* ClanOperation::add_room_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.ClanOperation.room_list)
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomQueryResult >&
ClanOperation::room_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.ClanOperation.room_list)
  return room_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomQueryResult >*
ClanOperation::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.ClanOperation.room_list)
  return &room_list_;
}

// -------------------------------------------------------------------

// PlayerList

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYERS];
inline bool PlayerList::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerList::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerList::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerList::clear_type_t() {
  type_t_ = 504;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerList::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerList.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerList::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerList.type_t)
}

// repeated int64 player_list = 2;
inline int PlayerList::player_list_size() const {
  return player_list_.size();
}
inline void PlayerList::clear_player_list() {
  player_list_.Clear();
}
inline ::google::protobuf::int64 PlayerList::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerList.player_list)
  return player_list_.Get(index);
}
inline void PlayerList::set_player_list(int index, ::google::protobuf::int64 value) {
  player_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerList.player_list)
}
inline void PlayerList::add_player_list(::google::protobuf::int64 value) {
  player_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerList.player_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerList::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerList.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerList::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerList.player_list)
  return &player_list_;
}

// optional .Adoter.Asset.WechatUnion wechat = 3;
inline bool PlayerList::has_wechat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerList::set_has_wechat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerList::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerList::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& PlayerList::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerList.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* PlayerList::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerList.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* PlayerList::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void PlayerList::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayerList.wechat)
}

// -------------------------------------------------------------------

// PlayerInformation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYER_INFO];
inline bool PlayerInformation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInformation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInformation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInformation::clear_type_t() {
  type_t_ = 505;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerInformation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerInformation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerInformation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerInformation.type_t)
}

// optional .Adoter.Asset.Player player = 2;
inline bool PlayerInformation::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInformation::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInformation::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInformation::clear_player() {
  if (player_ != NULL) player_->::Adoter::Asset::Player::Clear();
  clear_has_player();
}
inline const ::Adoter::Asset::Player& PlayerInformation::player() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerInformation.player)
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::Adoter::Asset::Player* PlayerInformation::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::Adoter::Asset::Player;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerInformation.player)
  return player_;
}
inline ::Adoter::Asset::Player* PlayerInformation::release_player() {
  clear_has_player();
  ::Adoter::Asset::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline void PlayerInformation::set_allocated_player(::Adoter::Asset::Player* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayerInformation.player)
}

// -------------------------------------------------------------------

// AlertMessage

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ALERT_ERROR];
inline bool AlertMessage::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertMessage::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertMessage::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertMessage::clear_type_t() {
  type_t_ = 507;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE AlertMessage::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void AlertMessage::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.type_t)
}

// optional .Adoter.Asset.ERROR_TYPE error_type = 2;
inline bool AlertMessage::has_error_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertMessage::set_has_error_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertMessage::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertMessage::clear_error_type() {
  error_type_ = 1;
  clear_has_error_type();
}
inline ::Adoter::Asset::ERROR_TYPE AlertMessage::error_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_type)
  return static_cast< ::Adoter::Asset::ERROR_TYPE >(error_type_);
}
inline void AlertMessage::set_error_type(::Adoter::Asset::ERROR_TYPE value) {
  assert(::Adoter::Asset::ERROR_TYPE_IsValid(value));
  set_has_error_type();
  error_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_type)
}

// optional .Adoter.Asset.ERROR_SHOW_TYPE error_show_type = 3;
inline bool AlertMessage::has_error_show_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlertMessage::set_has_error_show_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlertMessage::clear_has_error_show_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlertMessage::clear_error_show_type() {
  error_show_type_ = 1;
  clear_has_error_show_type();
}
inline ::Adoter::Asset::ERROR_SHOW_TYPE AlertMessage::error_show_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_show_type)
  return static_cast< ::Adoter::Asset::ERROR_SHOW_TYPE >(error_show_type_);
}
inline void AlertMessage::set_error_show_type(::Adoter::Asset::ERROR_SHOW_TYPE value) {
  assert(::Adoter::Asset::ERROR_SHOW_TYPE_IsValid(value));
  set_has_error_show_type();
  error_show_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_show_type)
}

// optional int32 error_code = 4;
inline bool AlertMessage::has_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlertMessage::set_has_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlertMessage::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlertMessage::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 AlertMessage::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_code)
  return error_code_;
}
inline void AlertMessage::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_code)
}

// -------------------------------------------------------------------

// LiuJu_LJElement

// optional int64 player_id = 2;
inline bool LiuJu_LJElement::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LiuJu_LJElement::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LiuJu_LJElement::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LiuJu_LJElement::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 LiuJu_LJElement::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LiuJu.LJElement.player_id)
  return player_id_;
}
inline void LiuJu_LJElement::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LiuJu.LJElement.player_id)
}

// optional .Adoter.Asset.PaiElement pai = 3;
inline bool LiuJu_LJElement::has_pai() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LiuJu_LJElement::set_has_pai() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LiuJu_LJElement::clear_has_pai() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LiuJu_LJElement::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& LiuJu_LJElement::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LiuJu.LJElement.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* LiuJu_LJElement::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LiuJu.LJElement.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* LiuJu_LJElement::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void LiuJu_LJElement::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.LiuJu.LJElement.pai)
}

// -------------------------------------------------------------------

// LiuJu

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_LIUJU];
inline bool LiuJu::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LiuJu::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LiuJu::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LiuJu::clear_type_t() {
  type_t_ = 508;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE LiuJu::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LiuJu.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void LiuJu::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LiuJu.type_t)
}

// repeated .Adoter.Asset.LiuJu.LJElement elements = 2;
inline int LiuJu::elements_size() const {
  return elements_.size();
}
inline void LiuJu::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::LiuJu_LJElement& LiuJu::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LiuJu.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::LiuJu_LJElement* LiuJu::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LiuJu.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::LiuJu_LJElement* LiuJu::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.LiuJu.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LiuJu_LJElement >&
LiuJu::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.LiuJu.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LiuJu_LJElement >*
LiuJu::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.LiuJu.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// PaiNotify_MutiPai

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiNotify_MutiPai::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify_MutiPai::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify_MutiPai::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify_MutiPai::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiNotify_MutiPai::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.MutiPai.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiNotify_MutiPai::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.MutiPai.card_type)
}

// repeated int32 cards = 2;
inline int PaiNotify_MutiPai::cards_size() const {
  return cards_.size();
}
inline void PaiNotify_MutiPai::clear_cards() {
  cards_.Clear();
}
inline ::google::protobuf::int32 PaiNotify_MutiPai::cards(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.MutiPai.cards)
  return cards_.Get(index);
}
inline void PaiNotify_MutiPai::set_cards(int index, ::google::protobuf::int32 value) {
  cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.MutiPai.cards)
}
inline void PaiNotify_MutiPai::add_cards(::google::protobuf::int32 value) {
  cards_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiNotify.MutiPai.cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PaiNotify_MutiPai::cards() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiNotify.MutiPai.cards)
  return cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PaiNotify_MutiPai::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiNotify.MutiPai.cards)
  return &cards_;
}

// -------------------------------------------------------------------

// PaiNotify_SinglePai

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiNotify_SinglePai::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify_SinglePai::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify_SinglePai::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify_SinglePai::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiNotify_SinglePai::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.SinglePai.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiNotify_SinglePai::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.SinglePai.card_type)
}

// optional int32 card_value = 2;
inline bool PaiNotify_SinglePai::has_card_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiNotify_SinglePai::set_has_card_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiNotify_SinglePai::clear_has_card_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiNotify_SinglePai::clear_card_value() {
  card_value_ = 0;
  clear_has_card_value();
}
inline ::google::protobuf::int32 PaiNotify_SinglePai::card_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.SinglePai.card_value)
  return card_value_;
}
inline void PaiNotify_SinglePai::set_card_value(::google::protobuf::int32 value) {
  set_has_card_value();
  card_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.SinglePai.card_value)
}

// -------------------------------------------------------------------

// PaiNotify

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_NOTIFY];
inline bool PaiNotify::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify::clear_type_t() {
  type_t_ = 509;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiNotify::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiNotify::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.type_t)
}

// optional int64 player_id = 2;
inline bool PaiNotify::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiNotify::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiNotify::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiNotify::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PaiNotify::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.player_id)
  return player_id_;
}
inline void PaiNotify::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.player_id)
}

// optional .Adoter.Asset.PaiNotify.CARDS_DATA_TYPE data_type = 3;
inline bool PaiNotify::has_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiNotify::set_has_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiNotify::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiNotify::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE PaiNotify::data_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.data_type)
  return static_cast< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE >(data_type_);
}
inline void PaiNotify::set_data_type(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE value) {
  assert(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.data_type)
}

// repeated .Adoter.Asset.PaiNotify.MutiPai pais = 4;
inline int PaiNotify::pais_size() const {
  return pais_.size();
}
inline void PaiNotify::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiNotify_MutiPai& PaiNotify::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiNotify_MutiPai* PaiNotify::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiNotify.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiNotify_MutiPai* PaiNotify::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiNotify.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >&
PaiNotify::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiNotify.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >*
PaiNotify::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiNotify.pais)
  return &pais_;
}

// optional .Adoter.Asset.PaiNotify.SinglePai pai = 5;
inline bool PaiNotify::has_pai() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaiNotify::set_has_pai() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaiNotify::clear_has_pai() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaiNotify::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiNotify_SinglePai::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiNotify_SinglePai& PaiNotify::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiNotify_SinglePai* PaiNotify::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiNotify_SinglePai;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiNotify.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiNotify_SinglePai* PaiNotify::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiNotify_SinglePai* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiNotify::set_allocated_pai(::Adoter::Asset::PaiNotify_SinglePai* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiNotify.pai)
}

// optional int32 cards_remain = 6;
inline bool PaiNotify::has_cards_remain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PaiNotify::set_has_cards_remain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PaiNotify::clear_has_cards_remain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PaiNotify::clear_cards_remain() {
  cards_remain_ = 0;
  clear_has_cards_remain();
}
inline ::google::protobuf::int32 PaiNotify::cards_remain() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.cards_remain)
  return cards_remain_;
}
inline void PaiNotify::set_cards_remain(::google::protobuf::int32 value) {
  set_has_cards_remain();
  cards_remain_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.cards_remain)
}

// -------------------------------------------------------------------

// SyncCommonProperty

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_COMMON_PROPERTY];
inline bool SyncCommonProperty::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCommonProperty::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCommonProperty::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCommonProperty::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncCommonProperty::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonProperty.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncCommonProperty::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonProperty.type_t)
}

// optional .Adoter.Asset.SyncCommonProperty.SYNC_REASON_TYPE reason_type = 2;
inline bool SyncCommonProperty::has_reason_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCommonProperty::set_has_reason_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCommonProperty::clear_has_reason_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCommonProperty::clear_reason_type() {
  reason_type_ = 1;
  clear_has_reason_type();
}
inline ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE SyncCommonProperty::reason_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonProperty.reason_type)
  return static_cast< ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE >(reason_type_);
}
inline void SyncCommonProperty::set_reason_type(::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE value) {
  assert(::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE_IsValid(value));
  set_has_reason_type();
  reason_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonProperty.reason_type)
}

// optional int64 player_id = 3;
inline bool SyncCommonProperty::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncCommonProperty::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncCommonProperty::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncCommonProperty::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 SyncCommonProperty::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonProperty.player_id)
  return player_id_;
}
inline void SyncCommonProperty::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonProperty.player_id)
}

// optional .Adoter.Asset.CommonProp common_prop = 4;
inline bool SyncCommonProperty::has_common_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncCommonProperty::set_has_common_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncCommonProperty::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncCommonProperty::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& SyncCommonProperty::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonProperty.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* SyncCommonProperty::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SyncCommonProperty.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* SyncCommonProperty::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void SyncCommonProperty::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SyncCommonProperty.common_prop)
}

// -------------------------------------------------------------------

// PaiOperationAlert_AlertElement

// optional .Adoter.Asset.PaiElement pai = 1;
inline bool PaiOperationAlert_AlertElement::has_pai() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationAlert_AlertElement::set_has_pai() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationAlert_AlertElement::clear_has_pai() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationAlert_AlertElement::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationAlert_AlertElement::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.AlertElement.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert_AlertElement::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationAlert.AlertElement.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert_AlertElement::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperationAlert_AlertElement::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperationAlert.AlertElement.pai)
}

// repeated .Adoter.Asset.PAI_OPER_TYPE oper_list = 2;
inline int PaiOperationAlert_AlertElement::oper_list_size() const {
  return oper_list_.size();
}
inline void PaiOperationAlert_AlertElement::clear_oper_list() {
  oper_list_.Clear();
}
inline ::Adoter::Asset::PAI_OPER_TYPE PaiOperationAlert_AlertElement::oper_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.AlertElement.oper_list)
  return static_cast< ::Adoter::Asset::PAI_OPER_TYPE >(oper_list_.Get(index));
}
inline void PaiOperationAlert_AlertElement::set_oper_list(int index, ::Adoter::Asset::PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PAI_OPER_TYPE_IsValid(value));
  oper_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationAlert.AlertElement.oper_list)
}
inline void PaiOperationAlert_AlertElement::add_oper_list(::Adoter::Asset::PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PAI_OPER_TYPE_IsValid(value));
  oper_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationAlert.AlertElement.oper_list)
}
inline const ::google::protobuf::RepeatedField<int>&
PaiOperationAlert_AlertElement::oper_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationAlert.AlertElement.oper_list)
  return oper_list_;
}
inline ::google::protobuf::RepeatedField<int>*
PaiOperationAlert_AlertElement::mutable_oper_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationAlert.AlertElement.oper_list)
  return &oper_list_;
}

// -------------------------------------------------------------------

// PaiOperationAlert

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_OPERATION_ALERT];
inline bool PaiOperationAlert::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationAlert::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationAlert::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationAlert::clear_type_t() {
  type_t_ = 510;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiOperationAlert::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiOperationAlert::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationAlert.type_t)
}

// repeated .Adoter.Asset.PaiOperationAlert.AlertElement pais = 2;
inline int PaiOperationAlert::pais_size() const {
  return pais_.size();
}
inline void PaiOperationAlert::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiOperationAlert_AlertElement& PaiOperationAlert::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiOperationAlert_AlertElement* PaiOperationAlert::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiOperationAlert_AlertElement* PaiOperationAlert::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperationAlert_AlertElement >&
PaiOperationAlert::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationAlert.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiOperationAlert_AlertElement >*
PaiOperationAlert::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationAlert.pais)
  return &pais_;
}

// -------------------------------------------------------------------

// SyncCommonLimit

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_LIMIT];
inline bool SyncCommonLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCommonLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCommonLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCommonLimit::clear_type_t() {
  type_t_ = 511;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncCommonLimit::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonLimit.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncCommonLimit::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonLimit.type_t)
}

// optional .Adoter.Asset.PlayerCommonLimit common_limit = 2;
inline bool SyncCommonLimit::has_common_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCommonLimit::set_has_common_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCommonLimit::clear_has_common_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCommonLimit::clear_common_limit() {
  if (common_limit_ != NULL) common_limit_->::Adoter::Asset::PlayerCommonLimit::Clear();
  clear_has_common_limit();
}
inline const ::Adoter::Asset::PlayerCommonLimit& SyncCommonLimit::common_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonLimit.common_limit)
  return common_limit_ != NULL ? *common_limit_ : *default_instance_->common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* SyncCommonLimit::mutable_common_limit() {
  set_has_common_limit();
  if (common_limit_ == NULL) common_limit_ = new ::Adoter::Asset::PlayerCommonLimit;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SyncCommonLimit.common_limit)
  return common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* SyncCommonLimit::release_common_limit() {
  clear_has_common_limit();
  ::Adoter::Asset::PlayerCommonLimit* temp = common_limit_;
  common_limit_ = NULL;
  return temp;
}
inline void SyncCommonLimit::set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit) {
  delete common_limit_;
  common_limit_ = common_limit;
  if (common_limit) {
    set_has_common_limit();
  } else {
    clear_has_common_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SyncCommonLimit.common_limit)
}

// -------------------------------------------------------------------

// SyncCommonReward

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_REWARD];
inline bool SyncCommonReward::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCommonReward::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCommonReward::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCommonReward::clear_type_t() {
  type_t_ = 512;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncCommonReward::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonReward.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncCommonReward::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonReward.type_t)
}

// optional int64 common_reward_id = 2;
inline bool SyncCommonReward::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCommonReward::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCommonReward::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCommonReward::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 SyncCommonReward::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonReward.common_reward_id)
  return common_reward_id_;
}
inline void SyncCommonReward::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonReward.common_reward_id)
}

// optional int32 error_code = 3;
inline bool SyncCommonReward::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncCommonReward::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncCommonReward::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncCommonReward::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 SyncCommonReward::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonReward.error_code)
  return error_code_;
}
inline void SyncCommonReward::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonReward.error_code)
}

// -------------------------------------------------------------------

// RoomInformation_Player_DistanceElement

// optional .Adoter.Asset.POSITION_TYPE position = 1;
inline bool RoomInformation_Player_DistanceElement::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation_Player_DistanceElement::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation_Player_DistanceElement::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation_Player_DistanceElement::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomInformation_Player_DistanceElement::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.DistanceElement.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void RoomInformation_Player_DistanceElement::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.DistanceElement.position)
}

// optional double distance = 2;
inline bool RoomInformation_Player_DistanceElement::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInformation_Player_DistanceElement::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInformation_Player_DistanceElement::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInformation_Player_DistanceElement::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double RoomInformation_Player_DistanceElement::distance() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.DistanceElement.distance)
  return distance_;
}
inline void RoomInformation_Player_DistanceElement::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.DistanceElement.distance)
}

// -------------------------------------------------------------------

// RoomInformation_Player

// optional .Adoter.Asset.POSITION_TYPE position = 1;
inline bool RoomInformation_Player::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation_Player::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation_Player::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation_Player::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomInformation_Player::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void RoomInformation_Player::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.position)
}

// optional int64 player_id = 2;
inline bool RoomInformation_Player::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInformation_Player::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInformation_Player::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInformation_Player::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 RoomInformation_Player::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.player_id)
  return player_id_;
}
inline void RoomInformation_Player::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.player_id)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
inline bool RoomInformation_Player::has_oper_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInformation_Player::set_has_oper_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInformation_Player::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInformation_Player::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE RoomInformation_Player::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void RoomInformation_Player::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.oper_type)
}

// optional .Adoter.Asset.CommonProp common_prop = 4;
inline bool RoomInformation_Player::has_common_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInformation_Player::set_has_common_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInformation_Player::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInformation_Player::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& RoomInformation_Player::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* RoomInformation_Player::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.Player.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* RoomInformation_Player::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomInformation_Player::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomInformation.Player.common_prop)
}

// optional .Adoter.Asset.WechatUnion wechat = 5;
inline bool RoomInformation_Player::has_wechat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInformation_Player::set_has_wechat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInformation_Player::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInformation_Player::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& RoomInformation_Player::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* RoomInformation_Player::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.Player.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* RoomInformation_Player::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void RoomInformation_Player::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomInformation.Player.wechat)
}

// optional bytes ip_address = 6;
inline bool RoomInformation_Player::has_ip_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInformation_Player::set_has_ip_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInformation_Player::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInformation_Player::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& RoomInformation_Player::ip_address() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.ip_address)
  return *ip_address_;
}
inline void RoomInformation_Player::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.ip_address)
}
inline void RoomInformation_Player::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.RoomInformation.Player.ip_address)
}
inline void RoomInformation_Player::set_ip_address(const void* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.RoomInformation.Player.ip_address)
}
inline ::std::string* RoomInformation_Player::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.Player.ip_address)
  return ip_address_;
}
inline ::std::string* RoomInformation_Player::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomInformation_Player::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomInformation.Player.ip_address)
}

// repeated .Adoter.Asset.RoomInformation.Player.DistanceElement dis_list = 7;
inline int RoomInformation_Player::dis_list_size() const {
  return dis_list_.size();
}
inline void RoomInformation_Player::clear_dis_list() {
  dis_list_.Clear();
}
inline const ::Adoter::Asset::RoomInformation_Player_DistanceElement& RoomInformation_Player::dis_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.dis_list)
  return dis_list_.Get(index);
}
inline ::Adoter::Asset::RoomInformation_Player_DistanceElement* RoomInformation_Player::mutable_dis_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.Player.dis_list)
  return dis_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomInformation_Player_DistanceElement* RoomInformation_Player::add_dis_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomInformation.Player.dis_list)
  return dis_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player_DistanceElement >&
RoomInformation_Player::dis_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomInformation.Player.dis_list)
  return dis_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player_DistanceElement >*
RoomInformation_Player::mutable_dis_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomInformation.Player.dis_list)
  return &dis_list_;
}

// optional int64 voice_member_id = 8;
inline bool RoomInformation_Player::has_voice_member_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInformation_Player::set_has_voice_member_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInformation_Player::clear_has_voice_member_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInformation_Player::clear_voice_member_id() {
  voice_member_id_ = GOOGLE_LONGLONG(0);
  clear_has_voice_member_id();
}
inline ::google::protobuf::int64 RoomInformation_Player::voice_member_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.voice_member_id)
  return voice_member_id_;
}
inline void RoomInformation_Player::set_voice_member_id(::google::protobuf::int64 value) {
  set_has_voice_member_id();
  voice_member_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.voice_member_id)
}

// -------------------------------------------------------------------

// RoomInformation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_INFO];
inline bool RoomInformation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation::clear_type_t() {
  type_t_ = 513;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomInformation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomInformation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.type_t)
}

// optional .Adoter.Asset.ROOM_SYNC_TYPE sync_type = 2;
inline bool RoomInformation::has_sync_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInformation::set_has_sync_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInformation::clear_has_sync_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInformation::clear_sync_type() {
  sync_type_ = 1;
  clear_has_sync_type();
}
inline ::Adoter::Asset::ROOM_SYNC_TYPE RoomInformation::sync_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.sync_type)
  return static_cast< ::Adoter::Asset::ROOM_SYNC_TYPE >(sync_type_);
}
inline void RoomInformation::set_sync_type(::Adoter::Asset::ROOM_SYNC_TYPE value) {
  assert(::Adoter::Asset::ROOM_SYNC_TYPE_IsValid(value));
  set_has_sync_type();
  sync_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.sync_type)
}

// repeated .Adoter.Asset.RoomInformation.Player player_list = 3;
inline int RoomInformation::player_list_size() const {
  return player_list_.size();
}
inline void RoomInformation::clear_player_list() {
  player_list_.Clear();
}
inline const ::Adoter::Asset::RoomInformation_Player& RoomInformation::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Get(index);
}
inline ::Adoter::Asset::RoomInformation_Player* RoomInformation::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomInformation_Player* RoomInformation::add_player_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >&
RoomInformation::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomInformation.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >*
RoomInformation::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomInformation.player_list)
  return &player_list_;
}

// -------------------------------------------------------------------

// GameCalculate

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_CALCULATE];
inline bool GameCalculate::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCalculate::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCalculate::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCalculate::clear_type_t() {
  type_t_ = 514;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameCalculate::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameCalculate::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameCalculate.type_t)
}

// optional .Adoter.Asset.CALCULATE_TYPE calculte_type = 2;
inline bool GameCalculate::has_calculte_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameCalculate::set_has_calculte_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameCalculate::clear_has_calculte_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameCalculate::clear_calculte_type() {
  calculte_type_ = 1;
  clear_has_calculte_type();
}
inline ::Adoter::Asset::CALCULATE_TYPE GameCalculate::calculte_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.calculte_type)
  return static_cast< ::Adoter::Asset::CALCULATE_TYPE >(calculte_type_);
}
inline void GameCalculate::set_calculte_type(::Adoter::Asset::CALCULATE_TYPE value) {
  assert(::Adoter::Asset::CALCULATE_TYPE_IsValid(value));
  set_has_calculte_type();
  calculte_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameCalculate.calculte_type)
}

// optional .Adoter.Asset.POSITION_TYPE dianpao_player_position = 3;
inline bool GameCalculate::has_dianpao_player_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameCalculate::set_has_dianpao_player_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameCalculate::clear_has_dianpao_player_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameCalculate::clear_dianpao_player_position() {
  dianpao_player_position_ = 0;
  clear_has_dianpao_player_position();
}
inline ::Adoter::Asset::POSITION_TYPE GameCalculate::dianpao_player_position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.dianpao_player_position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(dianpao_player_position_);
}
inline void GameCalculate::set_dianpao_player_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_dianpao_player_position();
  dianpao_player_position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameCalculate.dianpao_player_position)
}

// optional .Adoter.Asset.PaiElement baopai = 4;
inline bool GameCalculate::has_baopai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameCalculate::set_has_baopai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameCalculate::clear_has_baopai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameCalculate::clear_baopai() {
  if (baopai_ != NULL) baopai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_baopai();
}
inline const ::Adoter::Asset::PaiElement& GameCalculate::baopai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.baopai)
  return baopai_ != NULL ? *baopai_ : *default_instance_->baopai_;
}
inline ::Adoter::Asset::PaiElement* GameCalculate::mutable_baopai() {
  set_has_baopai();
  if (baopai_ == NULL) baopai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameCalculate.baopai)
  return baopai_;
}
inline ::Adoter::Asset::PaiElement* GameCalculate::release_baopai() {
  clear_has_baopai();
  ::Adoter::Asset::PaiElement* temp = baopai_;
  baopai_ = NULL;
  return temp;
}
inline void GameCalculate::set_allocated_baopai(::Adoter::Asset::PaiElement* baopai) {
  delete baopai_;
  baopai_ = baopai;
  if (baopai) {
    set_has_baopai();
  } else {
    clear_has_baopai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GameCalculate.baopai)
}

// optional .Adoter.Asset.GameRecord record = 5;
inline bool GameCalculate::has_record() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameCalculate::set_has_record() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameCalculate::clear_has_record() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameCalculate::clear_record() {
  if (record_ != NULL) record_->::Adoter::Asset::GameRecord::Clear();
  clear_has_record();
}
inline const ::Adoter::Asset::GameRecord& GameCalculate::record() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.record)
  return record_ != NULL ? *record_ : *default_instance_->record_;
}
inline ::Adoter::Asset::GameRecord* GameCalculate::mutable_record() {
  set_has_record();
  if (record_ == NULL) record_ = new ::Adoter::Asset::GameRecord;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GameCalculate.record)
  return record_;
}
inline ::Adoter::Asset::GameRecord* GameCalculate::release_record() {
  clear_has_record();
  ::Adoter::Asset::GameRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void GameCalculate::set_allocated_record(::Adoter::Asset::GameRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GameCalculate.record)
}

// optional int32 max_fan_type = 6;
inline bool GameCalculate::has_max_fan_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameCalculate::set_has_max_fan_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameCalculate::clear_has_max_fan_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameCalculate::clear_max_fan_type() {
  max_fan_type_ = 0;
  clear_has_max_fan_type();
}
inline ::google::protobuf::int32 GameCalculate::max_fan_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameCalculate.max_fan_type)
  return max_fan_type_;
}
inline void GameCalculate::set_max_fan_type(::google::protobuf::int32 value) {
  set_has_max_fan_type();
  max_fan_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameCalculate.max_fan_type)
}

// -------------------------------------------------------------------

// RoomRecord

// optional int64 player_id = 1;
inline bool RoomRecord::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomRecord::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomRecord::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomRecord::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 RoomRecord::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.player_id)
  return player_id_;
}
inline void RoomRecord::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.player_id)
}

// optional bytes nickname = 2;
inline bool RoomRecord::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomRecord::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomRecord::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomRecord::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RoomRecord::nickname() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.nickname)
  return *nickname_;
}
inline void RoomRecord::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.nickname)
}
inline void RoomRecord::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.RoomRecord.nickname)
}
inline void RoomRecord::set_nickname(const void* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.RoomRecord.nickname)
}
inline ::std::string* RoomRecord::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomRecord.nickname)
  return nickname_;
}
inline ::std::string* RoomRecord::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomRecord::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomRecord.nickname)
}

// optional bytes headimgurl = 3;
inline bool RoomRecord::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomRecord::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomRecord::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomRecord::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& RoomRecord::headimgurl() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.headimgurl)
  return *headimgurl_;
}
inline void RoomRecord::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.headimgurl)
}
inline void RoomRecord::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.RoomRecord.headimgurl)
}
inline void RoomRecord::set_headimgurl(const void* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.RoomRecord.headimgurl)
}
inline ::std::string* RoomRecord::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomRecord.headimgurl)
  return headimgurl_;
}
inline ::std::string* RoomRecord::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomRecord::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomRecord.headimgurl)
}

// optional int32 score = 4;
inline bool RoomRecord::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomRecord::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomRecord::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomRecord::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 RoomRecord::score() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.score)
  return score_;
}
inline void RoomRecord::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.score)
}

// optional int32 pk_count = 5;
inline bool RoomRecord::has_pk_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomRecord::set_has_pk_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomRecord::clear_has_pk_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomRecord::clear_pk_count() {
  pk_count_ = 0;
  clear_has_pk_count();
}
inline ::google::protobuf::int32 RoomRecord::pk_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.pk_count)
  return pk_count_;
}
inline void RoomRecord::set_pk_count(::google::protobuf::int32 value) {
  set_has_pk_count();
  pk_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.pk_count)
}

// optional int32 banker_count = 6;
inline bool RoomRecord::has_banker_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomRecord::set_has_banker_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomRecord::clear_has_banker_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomRecord::clear_banker_count() {
  banker_count_ = 0;
  clear_has_banker_count();
}
inline ::google::protobuf::int32 RoomRecord::banker_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.banker_count)
  return banker_count_;
}
inline void RoomRecord::set_banker_count(::google::protobuf::int32 value) {
  set_has_banker_count();
  banker_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.banker_count)
}

// optional int32 win_count = 7;
inline bool RoomRecord::has_win_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomRecord::set_has_win_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomRecord::clear_has_win_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomRecord::clear_win_count() {
  win_count_ = 0;
  clear_has_win_count();
}
inline ::google::protobuf::int32 RoomRecord::win_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.win_count)
  return win_count_;
}
inline void RoomRecord::set_win_count(::google::protobuf::int32 value) {
  set_has_win_count();
  win_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.win_count)
}

// optional int32 dianpao_count = 8;
inline bool RoomRecord::has_dianpao_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomRecord::set_has_dianpao_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomRecord::clear_has_dianpao_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomRecord::clear_dianpao_count() {
  dianpao_count_ = 0;
  clear_has_dianpao_count();
}
inline ::google::protobuf::int32 RoomRecord::dianpao_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.dianpao_count)
  return dianpao_count_;
}
inline void RoomRecord::set_dianpao_count(::google::protobuf::int32 value) {
  set_has_dianpao_count();
  dianpao_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.dianpao_count)
}

// optional int32 loubao_count = 9;
inline bool RoomRecord::has_loubao_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomRecord::set_has_loubao_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomRecord::clear_has_loubao_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomRecord::clear_loubao_count() {
  loubao_count_ = 0;
  clear_has_loubao_count();
}
inline ::google::protobuf::int32 RoomRecord::loubao_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.loubao_count)
  return loubao_count_;
}
inline void RoomRecord::set_loubao_count(::google::protobuf::int32 value) {
  set_has_loubao_count();
  loubao_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.loubao_count)
}

// optional int32 jinbao_count = 10;
inline bool RoomRecord::has_jinbao_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomRecord::set_has_jinbao_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomRecord::clear_has_jinbao_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomRecord::clear_jinbao_count() {
  jinbao_count_ = 0;
  clear_has_jinbao_count();
}
inline ::google::protobuf::int32 RoomRecord::jinbao_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomRecord.jinbao_count)
  return jinbao_count_;
}
inline void RoomRecord::set_jinbao_count(::google::protobuf::int32 value) {
  set_has_jinbao_count();
  jinbao_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomRecord.jinbao_count)
}

// -------------------------------------------------------------------

// RoomCalculate

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_CALCULATE];
inline bool RoomCalculate::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomCalculate::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomCalculate::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomCalculate::clear_type_t() {
  type_t_ = 523;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomCalculate::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomCalculate.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomCalculate::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomCalculate.type_t)
}

// optional .Adoter.Asset.CALCULATE_TYPE calculte_type = 2;
inline bool RoomCalculate::has_calculte_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomCalculate::set_has_calculte_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomCalculate::clear_has_calculte_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomCalculate::clear_calculte_type() {
  calculte_type_ = 1;
  clear_has_calculte_type();
}
inline ::Adoter::Asset::CALCULATE_TYPE RoomCalculate::calculte_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomCalculate.calculte_type)
  return static_cast< ::Adoter::Asset::CALCULATE_TYPE >(calculte_type_);
}
inline void RoomCalculate::set_calculte_type(::Adoter::Asset::CALCULATE_TYPE value) {
  assert(::Adoter::Asset::CALCULATE_TYPE_IsValid(value));
  set_has_calculte_type();
  calculte_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomCalculate.calculte_type)
}

// repeated .Adoter.Asset.RoomRecord record = 3;
inline int RoomCalculate::record_size() const {
  return record_.size();
}
inline void RoomCalculate::clear_record() {
  record_.Clear();
}
inline const ::Adoter::Asset::RoomRecord& RoomCalculate::record(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomCalculate.record)
  return record_.Get(index);
}
inline ::Adoter::Asset::RoomRecord* RoomCalculate::mutable_record(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomCalculate.record)
  return record_.Mutable(index);
}
inline ::Adoter::Asset::RoomRecord* RoomCalculate::add_record() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomCalculate.record)
  return record_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomRecord >&
RoomCalculate::record() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomCalculate.record)
  return record_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomRecord >*
RoomCalculate::mutable_record() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomCalculate.record)
  return &record_;
}

// -------------------------------------------------------------------

// GameInformation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_INFO];
inline bool GameInformation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInformation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInformation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInformation::clear_type_t() {
  type_t_ = 515;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameInformation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameInformation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameInformation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameInformation.type_t)
}

// optional int64 banker_player_id = 2;
inline bool GameInformation::has_banker_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInformation::set_has_banker_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInformation::clear_has_banker_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInformation::clear_banker_player_id() {
  banker_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_banker_player_id();
}
inline ::google::protobuf::int64 GameInformation::banker_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameInformation.banker_player_id)
  return banker_player_id_;
}
inline void GameInformation::set_banker_player_id(::google::protobuf::int64 value) {
  set_has_banker_player_id();
  banker_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameInformation.banker_player_id)
}

// -------------------------------------------------------------------

// KickOut

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_KILL_OUT];
inline bool KickOut::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickOut::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickOut::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickOut::clear_type_t() {
  type_t_ = 516;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE KickOut::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOut.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void KickOut::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOut.type_t)
}

// optional int64 player_id = 2;
inline bool KickOut::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickOut::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickOut::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickOut::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 KickOut::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOut.player_id)
  return player_id_;
}
inline void KickOut::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOut.player_id)
}

// optional .Adoter.Asset.KICK_OUT_REASON reason = 3;
inline bool KickOut::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickOut::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickOut::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickOut::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::Adoter::Asset::KICK_OUT_REASON KickOut::reason() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOut.reason)
  return static_cast< ::Adoter::Asset::KICK_OUT_REASON >(reason_);
}
inline void KickOut::set_reason(::Adoter::Asset::KICK_OUT_REASON value) {
  assert(::Adoter::Asset::KICK_OUT_REASON_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOut.reason)
}

// -------------------------------------------------------------------

// SyncActivity_ActivityElement

// optional int64 activity_id = 2;
inline bool SyncActivity_ActivityElement::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncActivity_ActivityElement::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncActivity_ActivityElement::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncActivity_ActivityElement::clear_activity_id() {
  activity_id_ = GOOGLE_LONGLONG(0);
  clear_has_activity_id();
}
inline ::google::protobuf::int64 SyncActivity_ActivityElement::activity_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncActivity.ActivityElement.activity_id)
  return activity_id_;
}
inline void SyncActivity_ActivityElement::set_activity_id(::google::protobuf::int64 value) {
  set_has_activity_id();
  activity_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncActivity.ActivityElement.activity_id)
}

// optional bool open = 3;
inline bool SyncActivity_ActivityElement::has_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncActivity_ActivityElement::set_has_open() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncActivity_ActivityElement::clear_has_open() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncActivity_ActivityElement::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool SyncActivity_ActivityElement::open() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncActivity.ActivityElement.open)
  return open_;
}
inline void SyncActivity_ActivityElement::set_open(bool value) {
  set_has_open();
  open_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncActivity.ActivityElement.open)
}

// -------------------------------------------------------------------

// SyncActivity

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ACTIVITY];
inline bool SyncActivity::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncActivity::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncActivity::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncActivity::clear_type_t() {
  type_t_ = 517;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncActivity::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncActivity.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncActivity::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncActivity.type_t)
}

// repeated .Adoter.Asset.SyncActivity.ActivityElement activity_list = 2;
inline int SyncActivity::activity_list_size() const {
  return activity_list_.size();
}
inline void SyncActivity::clear_activity_list() {
  activity_list_.Clear();
}
inline const ::Adoter::Asset::SyncActivity_ActivityElement& SyncActivity::activity_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncActivity.activity_list)
  return activity_list_.Get(index);
}
inline ::Adoter::Asset::SyncActivity_ActivityElement* SyncActivity::mutable_activity_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SyncActivity.activity_list)
  return activity_list_.Mutable(index);
}
inline ::Adoter::Asset::SyncActivity_ActivityElement* SyncActivity::add_activity_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.SyncActivity.activity_list)
  return activity_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SyncActivity_ActivityElement >&
SyncActivity::activity_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.SyncActivity.activity_list)
  return activity_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::SyncActivity_ActivityElement >*
SyncActivity::mutable_activity_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.SyncActivity.activity_list)
  return &activity_list_;
}

// -------------------------------------------------------------------

// SystemBroadcasting

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_SYSTEM_BROADCAST];
inline bool SystemBroadcasting::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemBroadcasting::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemBroadcasting::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemBroadcasting::clear_type_t() {
  type_t_ = 518;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SystemBroadcasting::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcasting.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SystemBroadcasting::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcasting.type_t)
}

// optional .Adoter.Asset.SYSTEM_BROADCAST_TYPE broad_cast_type = 2;
inline bool SystemBroadcasting::has_broad_cast_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemBroadcasting::set_has_broad_cast_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemBroadcasting::clear_has_broad_cast_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemBroadcasting::clear_broad_cast_type() {
  broad_cast_type_ = 1;
  clear_has_broad_cast_type();
}
inline ::Adoter::Asset::SYSTEM_BROADCAST_TYPE SystemBroadcasting::broad_cast_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcasting.broad_cast_type)
  return static_cast< ::Adoter::Asset::SYSTEM_BROADCAST_TYPE >(broad_cast_type_);
}
inline void SystemBroadcasting::set_broad_cast_type(::Adoter::Asset::SYSTEM_BROADCAST_TYPE value) {
  assert(::Adoter::Asset::SYSTEM_BROADCAST_TYPE_IsValid(value));
  set_has_broad_cast_type();
  broad_cast_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcasting.broad_cast_type)
}

// optional bytes content = 3;
inline bool SystemBroadcasting::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemBroadcasting::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemBroadcasting::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemBroadcasting::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SystemBroadcasting::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcasting.content)
  return *content_;
}
inline void SystemBroadcasting::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcasting.content)
}
inline void SystemBroadcasting::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SystemBroadcasting.content)
}
inline void SystemBroadcasting::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SystemBroadcasting.content)
}
inline ::std::string* SystemBroadcasting::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SystemBroadcasting.content)
  return content_;
}
inline ::std::string* SystemBroadcasting::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemBroadcasting::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SystemBroadcasting.content)
}

// -------------------------------------------------------------------

// MultiplePai

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool MultiplePai::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplePai::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplePai::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplePai::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE MultiplePai::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MultiplePai.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void MultiplePai::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MultiplePai.card_type)
}

// repeated int32 cards = 2;
inline int MultiplePai::cards_size() const {
  return cards_.size();
}
inline void MultiplePai::clear_cards() {
  cards_.Clear();
}
inline ::google::protobuf::int32 MultiplePai::cards(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MultiplePai.cards)
  return cards_.Get(index);
}
inline void MultiplePai::set_cards(int index, ::google::protobuf::int32 value) {
  cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.MultiplePai.cards)
}
inline void MultiplePai::add_cards(::google::protobuf::int32 value) {
  cards_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.MultiplePai.cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiplePai::cards() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MultiplePai.cards)
  return cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiplePai::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MultiplePai.cards)
  return &cards_;
}

// -------------------------------------------------------------------

// PaiPushDown_PlayerElement

// optional int64 player_id = 1;
inline bool PaiPushDown_PlayerElement::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiPushDown_PlayerElement::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiPushDown_PlayerElement::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiPushDown_PlayerElement::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PaiPushDown_PlayerElement::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiPushDown.PlayerElement.player_id)
  return player_id_;
}
inline void PaiPushDown_PlayerElement::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiPushDown.PlayerElement.player_id)
}

// optional .Adoter.Asset.POSITION_TYPE position = 2;
inline bool PaiPushDown_PlayerElement::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiPushDown_PlayerElement::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiPushDown_PlayerElement::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiPushDown_PlayerElement::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PaiPushDown_PlayerElement::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiPushDown.PlayerElement.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PaiPushDown_PlayerElement::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiPushDown.PlayerElement.position)
}

// repeated .Adoter.Asset.MultiplePai pai_list = 3;
inline int PaiPushDown_PlayerElement::pai_list_size() const {
  return pai_list_.size();
}
inline void PaiPushDown_PlayerElement::clear_pai_list() {
  pai_list_.Clear();
}
inline const ::Adoter::Asset::MultiplePai& PaiPushDown_PlayerElement::pai_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiPushDown.PlayerElement.pai_list)
  return pai_list_.Get(index);
}
inline ::Adoter::Asset::MultiplePai* PaiPushDown_PlayerElement::mutable_pai_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiPushDown.PlayerElement.pai_list)
  return pai_list_.Mutable(index);
}
inline ::Adoter::Asset::MultiplePai* PaiPushDown_PlayerElement::add_pai_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiPushDown.PlayerElement.pai_list)
  return pai_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
PaiPushDown_PlayerElement::pai_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiPushDown.PlayerElement.pai_list)
  return pai_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
PaiPushDown_PlayerElement::mutable_pai_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiPushDown.PlayerElement.pai_list)
  return &pai_list_;
}

// -------------------------------------------------------------------

// PaiPushDown

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_PUSH_DOWN];
inline bool PaiPushDown::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiPushDown::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiPushDown::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiPushDown::clear_type_t() {
  type_t_ = 519;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiPushDown::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiPushDown.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiPushDown::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiPushDown.type_t)
}

// repeated .Adoter.Asset.PaiPushDown.PlayerElement player_list = 2;
inline int PaiPushDown::player_list_size() const {
  return player_list_.size();
}
inline void PaiPushDown::clear_player_list() {
  player_list_.Clear();
}
inline const ::Adoter::Asset::PaiPushDown_PlayerElement& PaiPushDown::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiPushDown.player_list)
  return player_list_.Get(index);
}
inline ::Adoter::Asset::PaiPushDown_PlayerElement* PaiPushDown::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiPushDown.player_list)
  return player_list_.Mutable(index);
}
inline ::Adoter::Asset::PaiPushDown_PlayerElement* PaiPushDown::add_player_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiPushDown.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiPushDown_PlayerElement >&
PaiPushDown::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiPushDown.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiPushDown_PlayerElement >*
PaiPushDown::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiPushDown.player_list)
  return &player_list_;
}

// -------------------------------------------------------------------

// GamesFull

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAMES_FULL];
inline bool GamesFull::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamesFull::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamesFull::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamesFull::clear_type_t() {
  type_t_ = 520;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GamesFull::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GamesFull.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GamesFull::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GamesFull.type_t)
}

// optional int32 rounds = 2;
inline bool GamesFull::has_rounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamesFull::set_has_rounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamesFull::clear_has_rounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamesFull::clear_rounds() {
  rounds_ = 0;
  clear_has_rounds();
}
inline ::google::protobuf::int32 GamesFull::rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GamesFull.rounds)
  return rounds_;
}
inline void GamesFull::set_rounds(::google::protobuf::int32 value) {
  set_has_rounds();
  rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GamesFull.rounds)
}

// -------------------------------------------------------------------

// WeChatInfo

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_WECHAT_INFOMATION];
inline bool WeChatInfo::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeChatInfo::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeChatInfo::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeChatInfo::clear_type_t() {
  type_t_ = 521;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE WeChatInfo::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WeChatInfo.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void WeChatInfo::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.WeChatInfo.type_t)
}

// optional .Adoter.Asset.WechatUnion wechat = 2;
inline bool WeChatInfo::has_wechat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeChatInfo::set_has_wechat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeChatInfo::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeChatInfo::clear_wechat() {
  if (wechat_ != NULL) wechat_->::Adoter::Asset::WechatUnion::Clear();
  clear_has_wechat();
}
inline const ::Adoter::Asset::WechatUnion& WeChatInfo::wechat() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WeChatInfo.wechat)
  return wechat_ != NULL ? *wechat_ : *default_instance_->wechat_;
}
inline ::Adoter::Asset::WechatUnion* WeChatInfo::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == NULL) wechat_ = new ::Adoter::Asset::WechatUnion;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WeChatInfo.wechat)
  return wechat_;
}
inline ::Adoter::Asset::WechatUnion* WeChatInfo::release_wechat() {
  clear_has_wechat();
  ::Adoter::Asset::WechatUnion* temp = wechat_;
  wechat_ = NULL;
  return temp;
}
inline void WeChatInfo::set_allocated_wechat(::Adoter::Asset::WechatUnion* wechat) {
  delete wechat_;
  wechat_ = wechat;
  if (wechat) {
    set_has_wechat();
  } else {
    clear_has_wechat();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WeChatInfo.wechat)
}

// optional .Adoter.Asset.WechatError wechat_error = 3;
inline bool WeChatInfo::has_wechat_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeChatInfo::set_has_wechat_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeChatInfo::clear_has_wechat_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeChatInfo::clear_wechat_error() {
  if (wechat_error_ != NULL) wechat_error_->::Adoter::Asset::WechatError::Clear();
  clear_has_wechat_error();
}
inline const ::Adoter::Asset::WechatError& WeChatInfo::wechat_error() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.WeChatInfo.wechat_error)
  return wechat_error_ != NULL ? *wechat_error_ : *default_instance_->wechat_error_;
}
inline ::Adoter::Asset::WechatError* WeChatInfo::mutable_wechat_error() {
  set_has_wechat_error();
  if (wechat_error_ == NULL) wechat_error_ = new ::Adoter::Asset::WechatError;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.WeChatInfo.wechat_error)
  return wechat_error_;
}
inline ::Adoter::Asset::WechatError* WeChatInfo::release_wechat_error() {
  clear_has_wechat_error();
  ::Adoter::Asset::WechatError* temp = wechat_error_;
  wechat_error_ = NULL;
  return temp;
}
inline void WeChatInfo::set_allocated_wechat_error(::Adoter::Asset::WechatError* wechat_error) {
  delete wechat_error_;
  wechat_error_ = wechat_error;
  if (wechat_error) {
    set_has_wechat_error();
  } else {
    clear_has_wechat_error();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.WeChatInfo.wechat_error)
}

// -------------------------------------------------------------------

// GameStart

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_GAME_START];
inline bool GameStart::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStart::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStart::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStart::clear_type_t() {
  type_t_ = 522;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameStart::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameStart.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameStart::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameStart.type_t)
}

// optional int32 total_rounds = 2;
inline bool GameStart::has_total_rounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStart::set_has_total_rounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStart::clear_has_total_rounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStart::clear_total_rounds() {
  total_rounds_ = 0;
  clear_has_total_rounds();
}
inline ::google::protobuf::int32 GameStart::total_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameStart.total_rounds)
  return total_rounds_;
}
inline void GameStart::set_total_rounds(::google::protobuf::int32 value) {
  set_has_total_rounds();
  total_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameStart.total_rounds)
}

// optional int32 current_rounds = 3;
inline bool GameStart::has_current_rounds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStart::set_has_current_rounds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStart::clear_has_current_rounds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStart::clear_current_rounds() {
  current_rounds_ = 0;
  clear_has_current_rounds();
}
inline ::google::protobuf::int32 GameStart::current_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameStart.current_rounds)
  return current_rounds_;
}
inline void GameStart::set_current_rounds(::google::protobuf::int32 value) {
  set_has_current_rounds();
  current_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameStart.current_rounds)
}

// -------------------------------------------------------------------

// RoomDisMiss_RoomElement

// optional int64 player_id = 1;
inline bool RoomDisMiss_RoomElement::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomDisMiss_RoomElement::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomDisMiss_RoomElement::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomDisMiss_RoomElement::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 RoomDisMiss_RoomElement::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.RoomElement.player_id)
  return player_id_;
}
inline void RoomDisMiss_RoomElement::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomDisMiss.RoomElement.player_id)
}

// optional .Adoter.Asset.POSITION_TYPE position = 2;
inline bool RoomDisMiss_RoomElement::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomDisMiss_RoomElement::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomDisMiss_RoomElement::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomDisMiss_RoomElement::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomDisMiss_RoomElement::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.RoomElement.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void RoomDisMiss_RoomElement::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomDisMiss.RoomElement.position)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
inline bool RoomDisMiss_RoomElement::has_oper_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomDisMiss_RoomElement::set_has_oper_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomDisMiss_RoomElement::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomDisMiss_RoomElement::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE RoomDisMiss_RoomElement::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.RoomElement.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void RoomDisMiss_RoomElement::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomDisMiss.RoomElement.oper_type)
}

// -------------------------------------------------------------------

// RoomDisMiss

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_DISMISS];
inline bool RoomDisMiss::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomDisMiss::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomDisMiss::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomDisMiss::clear_type_t() {
  type_t_ = 524;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomDisMiss::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomDisMiss::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomDisMiss.type_t)
}

// optional int64 room_id = 2;
inline bool RoomDisMiss::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomDisMiss::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomDisMiss::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomDisMiss::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 RoomDisMiss::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.room_id)
  return room_id_;
}
inline void RoomDisMiss::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomDisMiss.room_id)
}

// repeated .Adoter.Asset.RoomDisMiss.RoomElement list = 3;
inline int RoomDisMiss::list_size() const {
  return list_.size();
}
inline void RoomDisMiss::clear_list() {
  list_.Clear();
}
inline const ::Adoter::Asset::RoomDisMiss_RoomElement& RoomDisMiss::list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomDisMiss.list)
  return list_.Get(index);
}
inline ::Adoter::Asset::RoomDisMiss_RoomElement* RoomDisMiss::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomDisMiss.list)
  return list_.Mutable(index);
}
inline ::Adoter::Asset::RoomDisMiss_RoomElement* RoomDisMiss::add_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomDisMiss.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomDisMiss_RoomElement >&
RoomDisMiss::list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomDisMiss.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomDisMiss_RoomElement >*
RoomDisMiss::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomDisMiss.list)
  return &list_;
}

// -------------------------------------------------------------------

// RoomState

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_STATE];
inline bool RoomState::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomState::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomState::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomState::clear_type_t() {
  type_t_ = 525;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomState::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomState.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomState::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomState.type_t)
}

// optional int64 room_id = 2;
inline bool RoomState::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomState::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomState::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomState::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 RoomState::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomState.room_id)
  return room_id_;
}
inline void RoomState::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomState.room_id)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 3;
inline bool RoomState::has_oper_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomState::set_has_oper_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomState::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomState::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE RoomState::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomState.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void RoomState::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomState.oper_type)
}

// -------------------------------------------------------------------

// BattleList

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_HISTORY];
inline bool BattleList::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleList::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleList::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleList::clear_type_t() {
  type_t_ = 526;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE BattleList::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleList.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void BattleList::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BattleList.type_t)
}

// repeated int64 room_list = 2;
inline int BattleList::room_list_size() const {
  return room_list_.size();
}
inline void BattleList::clear_room_list() {
  room_list_.Clear();
}
inline ::google::protobuf::int64 BattleList::room_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BattleList.room_list)
  return room_list_.Get(index);
}
inline void BattleList::set_room_list(int index, ::google::protobuf::int64 value) {
  room_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.BattleList.room_list)
}
inline void BattleList::add_room_list(::google::protobuf::int64 value) {
  room_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.BattleList.room_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
BattleList::room_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.BattleList.room_list)
  return room_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
BattleList::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.BattleList.room_list)
  return &room_list_;
}

// -------------------------------------------------------------------

// RoomAll_Player

// optional int64 player_id = 1;
inline bool RoomAll_Player::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomAll_Player::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomAll_Player::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomAll_Player::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 RoomAll_Player::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.player_id)
  return player_id_;
}
inline void RoomAll_Player::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.player_id)
}

// optional .Adoter.Asset.POSITION_TYPE position = 2;
inline bool RoomAll_Player::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomAll_Player::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomAll_Player::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomAll_Player::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomAll_Player::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void RoomAll_Player::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.position)
}

// optional int32 pai_count_inhand = 3;
inline bool RoomAll_Player::has_pai_count_inhand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomAll_Player::set_has_pai_count_inhand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomAll_Player::clear_has_pai_count_inhand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomAll_Player::clear_pai_count_inhand() {
  pai_count_inhand_ = 0;
  clear_has_pai_count_inhand();
}
inline ::google::protobuf::int32 RoomAll_Player::pai_count_inhand() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.pai_count_inhand)
  return pai_count_inhand_;
}
inline void RoomAll_Player::set_pai_count_inhand(::google::protobuf::int32 value) {
  set_has_pai_count_inhand();
  pai_count_inhand_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.pai_count_inhand)
}

// repeated .Adoter.Asset.MultiplePai pai_inhand = 4;
inline int RoomAll_Player::pai_inhand_size() const {
  return pai_inhand_.size();
}
inline void RoomAll_Player::clear_pai_inhand() {
  pai_inhand_.Clear();
}
inline const ::Adoter::Asset::MultiplePai& RoomAll_Player::pai_inhand(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.pai_inhand)
  return pai_inhand_.Get(index);
}
inline ::Adoter::Asset::MultiplePai* RoomAll_Player::mutable_pai_inhand(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.Player.pai_inhand)
  return pai_inhand_.Mutable(index);
}
inline ::Adoter::Asset::MultiplePai* RoomAll_Player::add_pai_inhand() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.Player.pai_inhand)
  return pai_inhand_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >&
RoomAll_Player::pai_inhand() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.Player.pai_inhand)
  return pai_inhand_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MultiplePai >*
RoomAll_Player::mutable_pai_inhand() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.Player.pai_inhand)
  return &pai_inhand_;
}

// repeated .Adoter.Asset.PaiElement pai_outhand = 5;
inline int RoomAll_Player::pai_outhand_size() const {
  return pai_outhand_.size();
}
inline void RoomAll_Player::clear_pai_outhand() {
  pai_outhand_.Clear();
}
inline const ::Adoter::Asset::PaiElement& RoomAll_Player::pai_outhand(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.pai_outhand)
  return pai_outhand_.Get(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::mutable_pai_outhand(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.Player.pai_outhand)
  return pai_outhand_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::add_pai_outhand() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.Player.pai_outhand)
  return pai_outhand_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
RoomAll_Player::pai_outhand() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.Player.pai_outhand)
  return pai_outhand_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
RoomAll_Player::mutable_pai_outhand() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.Player.pai_outhand)
  return &pai_outhand_;
}

// repeated .Adoter.Asset.PaiElement minggang_list = 6;
inline int RoomAll_Player::minggang_list_size() const {
  return minggang_list_.size();
}
inline void RoomAll_Player::clear_minggang_list() {
  minggang_list_.Clear();
}
inline const ::Adoter::Asset::PaiElement& RoomAll_Player::minggang_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.minggang_list)
  return minggang_list_.Get(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::mutable_minggang_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.Player.minggang_list)
  return minggang_list_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::add_minggang_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.Player.minggang_list)
  return minggang_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
RoomAll_Player::minggang_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.Player.minggang_list)
  return minggang_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
RoomAll_Player::mutable_minggang_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.Player.minggang_list)
  return &minggang_list_;
}

// repeated .Adoter.Asset.PaiElement angang_list = 7;
inline int RoomAll_Player::angang_list_size() const {
  return angang_list_.size();
}
inline void RoomAll_Player::clear_angang_list() {
  angang_list_.Clear();
}
inline const ::Adoter::Asset::PaiElement& RoomAll_Player::angang_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.angang_list)
  return angang_list_.Get(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::mutable_angang_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.Player.angang_list)
  return angang_list_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::add_angang_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.Player.angang_list)
  return angang_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
RoomAll_Player::angang_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.Player.angang_list)
  return angang_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
RoomAll_Player::mutable_angang_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.Player.angang_list)
  return &angang_list_;
}

// optional int32 fenggang_count = 8;
inline bool RoomAll_Player::has_fenggang_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomAll_Player::set_has_fenggang_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomAll_Player::clear_has_fenggang_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomAll_Player::clear_fenggang_count() {
  fenggang_count_ = 0;
  clear_has_fenggang_count();
}
inline ::google::protobuf::int32 RoomAll_Player::fenggang_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.fenggang_count)
  return fenggang_count_;
}
inline void RoomAll_Player::set_fenggang_count(::google::protobuf::int32 value) {
  set_has_fenggang_count();
  fenggang_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.fenggang_count)
}

// optional int32 jiangang_count = 9;
inline bool RoomAll_Player::has_jiangang_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomAll_Player::set_has_jiangang_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomAll_Player::clear_has_jiangang_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomAll_Player::clear_jiangang_count() {
  jiangang_count_ = 0;
  clear_has_jiangang_count();
}
inline ::google::protobuf::int32 RoomAll_Player::jiangang_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.jiangang_count)
  return jiangang_count_;
}
inline void RoomAll_Player::set_jiangang_count(::google::protobuf::int32 value) {
  set_has_jiangang_count();
  jiangang_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.jiangang_count)
}

// repeated .Adoter.Asset.PaiElement pai_pool = 10;
inline int RoomAll_Player::pai_pool_size() const {
  return pai_pool_.size();
}
inline void RoomAll_Player::clear_pai_pool() {
  pai_pool_.Clear();
}
inline const ::Adoter::Asset::PaiElement& RoomAll_Player::pai_pool(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.pai_pool)
  return pai_pool_.Get(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::mutable_pai_pool(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.Player.pai_pool)
  return pai_pool_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* RoomAll_Player::add_pai_pool() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.Player.pai_pool)
  return pai_pool_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
RoomAll_Player::pai_pool() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.Player.pai_pool)
  return pai_pool_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
RoomAll_Player::mutable_pai_pool() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.Player.pai_pool)
  return &pai_pool_;
}

// optional bool tingpai = 11;
inline bool RoomAll_Player::has_tingpai() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomAll_Player::set_has_tingpai() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomAll_Player::clear_has_tingpai() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomAll_Player::clear_tingpai() {
  tingpai_ = false;
  clear_has_tingpai();
}
inline bool RoomAll_Player::tingpai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.Player.tingpai)
  return tingpai_;
}
inline void RoomAll_Player::set_tingpai(bool value) {
  set_has_tingpai();
  tingpai_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.Player.tingpai)
}

// -------------------------------------------------------------------

// RoomAll

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_ALL];
inline bool RoomAll::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomAll::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomAll::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomAll::clear_type_t() {
  type_t_ = 527;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomAll::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomAll::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.type_t)
}

// optional int32 current_rounds = 2;
inline bool RoomAll::has_current_rounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomAll::set_has_current_rounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomAll::clear_has_current_rounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomAll::clear_current_rounds() {
  current_rounds_ = 0;
  clear_has_current_rounds();
}
inline ::google::protobuf::int32 RoomAll::current_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.current_rounds)
  return current_rounds_;
}
inline void RoomAll::set_current_rounds(::google::protobuf::int32 value) {
  set_has_current_rounds();
  current_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.current_rounds)
}

// optional int32 remain_cards_count = 3;
inline bool RoomAll::has_remain_cards_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomAll::set_has_remain_cards_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomAll::clear_has_remain_cards_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomAll::clear_remain_cards_count() {
  remain_cards_count_ = 0;
  clear_has_remain_cards_count();
}
inline ::google::protobuf::int32 RoomAll::remain_cards_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.remain_cards_count)
  return remain_cards_count_;
}
inline void RoomAll::set_remain_cards_count(::google::protobuf::int32 value) {
  set_has_remain_cards_count();
  remain_cards_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.remain_cards_count)
}

// repeated int32 saizi_random_result = 4;
inline int RoomAll::saizi_random_result_size() const {
  return saizi_random_result_.size();
}
inline void RoomAll::clear_saizi_random_result() {
  saizi_random_result_.Clear();
}
inline ::google::protobuf::int32 RoomAll::saizi_random_result(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.saizi_random_result)
  return saizi_random_result_.Get(index);
}
inline void RoomAll::set_saizi_random_result(int index, ::google::protobuf::int32 value) {
  saizi_random_result_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.saizi_random_result)
}
inline void RoomAll::add_saizi_random_result(::google::protobuf::int32 value) {
  saizi_random_result_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.saizi_random_result)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RoomAll::saizi_random_result() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.saizi_random_result)
  return saizi_random_result_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RoomAll::mutable_saizi_random_result() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.saizi_random_result)
  return &saizi_random_result_;
}

// optional .Adoter.Asset.PaiElement baopai = 5;
inline bool RoomAll::has_baopai() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomAll::set_has_baopai() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomAll::clear_has_baopai() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomAll::clear_baopai() {
  if (baopai_ != NULL) baopai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_baopai();
}
inline const ::Adoter::Asset::PaiElement& RoomAll::baopai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.baopai)
  return baopai_ != NULL ? *baopai_ : *default_instance_->baopai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::mutable_baopai() {
  set_has_baopai();
  if (baopai_ == NULL) baopai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.baopai)
  return baopai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::release_baopai() {
  clear_has_baopai();
  ::Adoter::Asset::PaiElement* temp = baopai_;
  baopai_ = NULL;
  return temp;
}
inline void RoomAll::set_allocated_baopai(::Adoter::Asset::PaiElement* baopai) {
  delete baopai_;
  baopai_ = baopai;
  if (baopai) {
    set_has_baopai();
  } else {
    clear_has_baopai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomAll.baopai)
}

// repeated .Adoter.Asset.PlayerBrief player_brief_list = 6;
inline int RoomAll::player_brief_list_size() const {
  return player_brief_list_.size();
}
inline void RoomAll::clear_player_brief_list() {
  player_brief_list_.Clear();
}
inline const ::Adoter::Asset::PlayerBrief& RoomAll::player_brief_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.player_brief_list)
  return player_brief_list_.Get(index);
}
inline ::Adoter::Asset::PlayerBrief* RoomAll::mutable_player_brief_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.player_brief_list)
  return player_brief_list_.Mutable(index);
}
inline ::Adoter::Asset::PlayerBrief* RoomAll::add_player_brief_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.player_brief_list)
  return player_brief_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >&
RoomAll::player_brief_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.player_brief_list)
  return player_brief_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerBrief >*
RoomAll::mutable_player_brief_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.player_brief_list)
  return &player_brief_list_;
}

// repeated .Adoter.Asset.RoomAll.Player player_list = 7;
inline int RoomAll::player_list_size() const {
  return player_list_.size();
}
inline void RoomAll::clear_player_list() {
  player_list_.Clear();
}
inline const ::Adoter::Asset::RoomAll_Player& RoomAll::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.player_list)
  return player_list_.Get(index);
}
inline ::Adoter::Asset::RoomAll_Player* RoomAll::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.player_list)
  return player_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomAll_Player* RoomAll::add_player_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomAll_Player >&
RoomAll::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomAll_Player >*
RoomAll::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.player_list)
  return &player_list_;
}

// optional .Adoter.Asset.POSITION_TYPE zhuang_position = 8;
inline bool RoomAll::has_zhuang_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomAll::set_has_zhuang_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomAll::clear_has_zhuang_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomAll::clear_zhuang_position() {
  zhuang_position_ = 0;
  clear_has_zhuang_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomAll::zhuang_position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.zhuang_position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(zhuang_position_);
}
inline void RoomAll::set_zhuang_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_zhuang_position();
  zhuang_position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.zhuang_position)
}

// optional .Adoter.Asset.POSITION_TYPE curr_operator_position = 9;
inline bool RoomAll::has_curr_operator_position() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomAll::set_has_curr_operator_position() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomAll::clear_has_curr_operator_position() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomAll::clear_curr_operator_position() {
  curr_operator_position_ = 0;
  clear_has_curr_operator_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomAll::curr_operator_position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.curr_operator_position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(curr_operator_position_);
}
inline void RoomAll::set_curr_operator_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_curr_operator_position();
  curr_operator_position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomAll.curr_operator_position)
}

// repeated .Adoter.Asset.GameRecord list = 10;
inline int RoomAll::list_size() const {
  return list_.size();
}
inline void RoomAll::clear_list() {
  list_.Clear();
}
inline const ::Adoter::Asset::GameRecord& RoomAll::list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.list)
  return list_.Get(index);
}
inline ::Adoter::Asset::GameRecord* RoomAll::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.list)
  return list_.Mutable(index);
}
inline ::Adoter::Asset::GameRecord* RoomAll::add_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomAll.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >&
RoomAll::list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomAll.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::GameRecord >*
RoomAll::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomAll.list)
  return &list_;
}

// optional .Adoter.Asset.PaiElement zhuapai = 11;
inline bool RoomAll::has_zhuapai() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomAll::set_has_zhuapai() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomAll::clear_has_zhuapai() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomAll::clear_zhuapai() {
  if (zhuapai_ != NULL) zhuapai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_zhuapai();
}
inline const ::Adoter::Asset::PaiElement& RoomAll::zhuapai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.zhuapai)
  return zhuapai_ != NULL ? *zhuapai_ : *default_instance_->zhuapai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::mutable_zhuapai() {
  set_has_zhuapai();
  if (zhuapai_ == NULL) zhuapai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.zhuapai)
  return zhuapai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::release_zhuapai() {
  clear_has_zhuapai();
  ::Adoter::Asset::PaiElement* temp = zhuapai_;
  zhuapai_ = NULL;
  return temp;
}
inline void RoomAll::set_allocated_zhuapai(::Adoter::Asset::PaiElement* zhuapai) {
  delete zhuapai_;
  zhuapai_ = zhuapai;
  if (zhuapai) {
    set_has_zhuapai();
  } else {
    clear_has_zhuapai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomAll.zhuapai)
}

// optional .Adoter.Asset.PaiElement huipai = 12;
inline bool RoomAll::has_huipai() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomAll::set_has_huipai() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomAll::clear_has_huipai() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomAll::clear_huipai() {
  if (huipai_ != NULL) huipai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_huipai();
}
inline const ::Adoter::Asset::PaiElement& RoomAll::huipai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomAll.huipai)
  return huipai_ != NULL ? *huipai_ : *default_instance_->huipai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::mutable_huipai() {
  set_has_huipai();
  if (huipai_ == NULL) huipai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomAll.huipai)
  return huipai_;
}
inline ::Adoter::Asset::PaiElement* RoomAll::release_huipai() {
  clear_has_huipai();
  ::Adoter::Asset::PaiElement* temp = huipai_;
  huipai_ = NULL;
  return temp;
}
inline void RoomAll::set_allocated_huipai(::Adoter::Asset::PaiElement* huipai) {
  delete huipai_;
  huipai_ = huipai;
  if (huipai) {
    set_has_huipai();
  } else {
    clear_has_huipai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomAll.huipai)
}

// -------------------------------------------------------------------

// RoomBeenIn

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_IN];
inline bool RoomBeenIn::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomBeenIn::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomBeenIn::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomBeenIn::clear_type_t() {
  type_t_ = 528;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomBeenIn::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomBeenIn.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomBeenIn::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomBeenIn.type_t)
}

// optional int64 room_id = 2;
inline bool RoomBeenIn::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomBeenIn::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomBeenIn::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomBeenIn::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 RoomBeenIn::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomBeenIn.room_id)
  return room_id_;
}
inline void RoomBeenIn::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomBeenIn.room_id)
}

// -------------------------------------------------------------------

// RoomQueryResult

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_QUERY];
inline bool RoomQueryResult::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomQueryResult::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomQueryResult::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomQueryResult::clear_type_t() {
  type_t_ = 529;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomQueryResult::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomQueryResult::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomQueryResult.type_t)
}

// optional int64 room_id = 2;
inline bool RoomQueryResult::has_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomQueryResult::set_has_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomQueryResult::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomQueryResult::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 RoomQueryResult::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.room_id)
  return room_id_;
}
inline void RoomQueryResult::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomQueryResult.room_id)
}

// optional int32 create_time = 3;
inline bool RoomQueryResult::has_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomQueryResult::set_has_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomQueryResult::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomQueryResult::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 RoomQueryResult::create_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.create_time)
  return create_time_;
}
inline void RoomQueryResult::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomQueryResult.create_time)
}

// optional .Adoter.Asset.RoomOptions options = 4;
inline bool RoomQueryResult::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomQueryResult::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomQueryResult::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomQueryResult::clear_options() {
  if (options_ != NULL) options_->::Adoter::Asset::RoomOptions::Clear();
  clear_has_options();
}
inline const ::Adoter::Asset::RoomOptions& RoomQueryResult::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::Adoter::Asset::RoomOptions* RoomQueryResult::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::Adoter::Asset::RoomOptions;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomQueryResult.options)
  return options_;
}
inline ::Adoter::Asset::RoomOptions* RoomQueryResult::release_options() {
  clear_has_options();
  ::Adoter::Asset::RoomOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void RoomQueryResult::set_allocated_options(::Adoter::Asset::RoomOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomQueryResult.options)
}

// optional .Adoter.Asset.RoomInformation information = 5;
inline bool RoomQueryResult::has_information() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomQueryResult::set_has_information() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomQueryResult::clear_has_information() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomQueryResult::clear_information() {
  if (information_ != NULL) information_->::Adoter::Asset::RoomInformation::Clear();
  clear_has_information();
}
inline const ::Adoter::Asset::RoomInformation& RoomQueryResult::information() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.information)
  return information_ != NULL ? *information_ : *default_instance_->information_;
}
inline ::Adoter::Asset::RoomInformation* RoomQueryResult::mutable_information() {
  set_has_information();
  if (information_ == NULL) information_ = new ::Adoter::Asset::RoomInformation;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomQueryResult.information)
  return information_;
}
inline ::Adoter::Asset::RoomInformation* RoomQueryResult::release_information() {
  clear_has_information();
  ::Adoter::Asset::RoomInformation* temp = information_;
  information_ = NULL;
  return temp;
}
inline void RoomQueryResult::set_allocated_information(::Adoter::Asset::RoomInformation* information) {
  delete information_;
  information_ = information;
  if (information) {
    set_has_information();
  } else {
    clear_has_information();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomQueryResult.information)
}

// optional int64 clan_id = 6;
inline bool RoomQueryResult::has_clan_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomQueryResult::set_has_clan_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomQueryResult::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomQueryResult::clear_clan_id() {
  clan_id_ = GOOGLE_LONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::int64 RoomQueryResult::clan_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomQueryResult.clan_id)
  return clan_id_;
}
inline void RoomQueryResult::set_clan_id(::google::protobuf::int64 value) {
  set_has_clan_id();
  clan_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomQueryResult.clan_id)
}

// -------------------------------------------------------------------

// RegisterServer

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_REGISTER];
inline bool RegisterServer::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterServer::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterServer::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterServer::clear_type_t() {
  type_t_ = 1001;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RegisterServer::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RegisterServer.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RegisterServer::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RegisterServer.type_t)
}

// optional .Adoter.Asset.ROLE_TYPE role_type = 2;
inline bool RegisterServer::has_role_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterServer::set_has_role_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterServer::clear_has_role_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterServer::clear_role_type() {
  role_type_ = 0;
  clear_has_role_type();
}
inline ::Adoter::Asset::ROLE_TYPE RegisterServer::role_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RegisterServer.role_type)
  return static_cast< ::Adoter::Asset::ROLE_TYPE >(role_type_);
}
inline void RegisterServer::set_role_type(::Adoter::Asset::ROLE_TYPE value) {
  assert(::Adoter::Asset::ROLE_TYPE_IsValid(value));
  set_has_role_type();
  role_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RegisterServer.role_type)
}

// optional int64 global_id = 3;
inline bool RegisterServer::has_global_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterServer::set_has_global_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterServer::clear_has_global_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterServer::clear_global_id() {
  global_id_ = GOOGLE_LONGLONG(0);
  clear_has_global_id();
}
inline ::google::protobuf::int64 RegisterServer::global_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RegisterServer.global_id)
  return global_id_;
}
inline void RegisterServer::set_global_id(::google::protobuf::int64 value) {
  set_has_global_id();
  global_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RegisterServer.global_id)
}

// -------------------------------------------------------------------

// KickOutPlayer

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_KICKOUT_PLAYER];
inline bool KickOutPlayer::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickOutPlayer::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickOutPlayer::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickOutPlayer::clear_type_t() {
  type_t_ = 1002;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE KickOutPlayer::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOutPlayer.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void KickOutPlayer::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOutPlayer.type_t)
}

// optional .Adoter.Asset.KICK_OUT_REASON reason = 2;
inline bool KickOutPlayer::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickOutPlayer::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickOutPlayer::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickOutPlayer::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::Adoter::Asset::KICK_OUT_REASON KickOutPlayer::reason() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOutPlayer.reason)
  return static_cast< ::Adoter::Asset::KICK_OUT_REASON >(reason_);
}
inline void KickOutPlayer::set_reason(::Adoter::Asset::KICK_OUT_REASON value) {
  assert(::Adoter::Asset::KICK_OUT_REASON_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOutPlayer.reason)
}

// optional int64 player_id = 3;
inline bool KickOutPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickOutPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickOutPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickOutPlayer::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 KickOutPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.KickOutPlayer.player_id)
  return player_id_;
}
inline void KickOutPlayer::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.KickOutPlayer.player_id)
}

// -------------------------------------------------------------------

// GmtInnerMeta

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_GMT_INNER_META];
inline bool GmtInnerMeta::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GmtInnerMeta::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GmtInnerMeta::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GmtInnerMeta::clear_type_t() {
  type_t_ = 1003;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GmtInnerMeta::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GmtInnerMeta.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GmtInnerMeta::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GmtInnerMeta.type_t)
}

// optional bytes inner_meta = 2;
inline bool GmtInnerMeta::has_inner_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GmtInnerMeta::set_has_inner_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GmtInnerMeta::clear_has_inner_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GmtInnerMeta::clear_inner_meta() {
  if (inner_meta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_meta_->clear();
  }
  clear_has_inner_meta();
}
inline const ::std::string& GmtInnerMeta::inner_meta() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GmtInnerMeta.inner_meta)
  return *inner_meta_;
}
inline void GmtInnerMeta::set_inner_meta(const ::std::string& value) {
  set_has_inner_meta();
  if (inner_meta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_meta_ = new ::std::string;
  }
  inner_meta_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.GmtInnerMeta.inner_meta)
}
inline void GmtInnerMeta::set_inner_meta(const char* value) {
  set_has_inner_meta();
  if (inner_meta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_meta_ = new ::std::string;
  }
  inner_meta_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.GmtInnerMeta.inner_meta)
}
inline void GmtInnerMeta::set_inner_meta(const void* value, size_t size) {
  set_has_inner_meta();
  if (inner_meta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_meta_ = new ::std::string;
  }
  inner_meta_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.GmtInnerMeta.inner_meta)
}
inline ::std::string* GmtInnerMeta::mutable_inner_meta() {
  set_has_inner_meta();
  if (inner_meta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_meta_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.GmtInnerMeta.inner_meta)
  return inner_meta_;
}
inline ::std::string* GmtInnerMeta::release_inner_meta() {
  clear_has_inner_meta();
  if (inner_meta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inner_meta_;
    inner_meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GmtInnerMeta::set_allocated_inner_meta(::std::string* inner_meta) {
  if (inner_meta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_meta_;
  }
  if (inner_meta) {
    set_has_inner_meta();
    inner_meta_ = inner_meta;
  } else {
    clear_has_inner_meta();
    inner_meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.GmtInnerMeta.inner_meta)
}

// -------------------------------------------------------------------

// PlayerState

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_PLAYER_STATE];
inline bool PlayerState::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerState::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerState::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerState::clear_type_t() {
  type_t_ = 1004;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerState::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerState.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerState::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerState.type_t)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
inline bool PlayerState::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerState::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerState::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerState::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE PlayerState::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerState.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void PlayerState::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerState.oper_type)
}

// -------------------------------------------------------------------

// ClanRoomStatusChanged

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_CLAN_ROOM_START_OR_OVER];
inline bool ClanRoomStatusChanged::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRoomStatusChanged::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRoomStatusChanged::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRoomStatusChanged::clear_type_t() {
  type_t_ = 1005;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE ClanRoomStatusChanged::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanRoomStatusChanged.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void ClanRoomStatusChanged::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanRoomStatusChanged.type_t)
}

// optional .Adoter.Asset.CLAN_ROOM_STATUS_TYPE status = 2;
inline bool ClanRoomStatusChanged::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRoomStatusChanged::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRoomStatusChanged::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRoomStatusChanged::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE ClanRoomStatusChanged::status() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanRoomStatusChanged.status)
  return static_cast< ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE >(status_);
}
inline void ClanRoomStatusChanged::set_status(::Adoter::Asset::CLAN_ROOM_STATUS_TYPE value) {
  assert(::Adoter::Asset::CLAN_ROOM_STATUS_TYPE_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanRoomStatusChanged.status)
}

// optional .Adoter.Asset.Room room = 3;
inline bool ClanRoomStatusChanged::has_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanRoomStatusChanged::set_has_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanRoomStatusChanged::clear_has_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanRoomStatusChanged::clear_room() {
  if (room_ != NULL) room_->::Adoter::Asset::Room::Clear();
  clear_has_room();
}
inline const ::Adoter::Asset::Room& ClanRoomStatusChanged::room() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanRoomStatusChanged.room)
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::Adoter::Asset::Room* ClanRoomStatusChanged::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::Adoter::Asset::Room;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanRoomStatusChanged.room)
  return room_;
}
inline ::Adoter::Asset::Room* ClanRoomStatusChanged::release_room() {
  clear_has_room();
  ::Adoter::Asset::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline void ClanRoomStatusChanged::set_allocated_room(::Adoter::Asset::Room* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClanRoomStatusChanged.room)
}

// -------------------------------------------------------------------

// ClanRoomSync

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2S_CLAN_ROOM_SYNC];
inline bool ClanRoomSync::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRoomSync::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRoomSync::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRoomSync::clear_type_t() {
  type_t_ = 1006;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE ClanRoomSync::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanRoomSync.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void ClanRoomSync::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanRoomSync.type_t)
}

// optional bytes room_status = 2;
inline bool ClanRoomSync::has_room_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRoomSync::set_has_room_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRoomSync::clear_has_room_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRoomSync::clear_room_status() {
  if (room_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_status_->clear();
  }
  clear_has_room_status();
}
inline const ::std::string& ClanRoomSync::room_status() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ClanRoomSync.room_status)
  return *room_status_;
}
inline void ClanRoomSync::set_room_status(const ::std::string& value) {
  set_has_room_status();
  if (room_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_status_ = new ::std::string;
  }
  room_status_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ClanRoomSync.room_status)
}
inline void ClanRoomSync::set_room_status(const char* value) {
  set_has_room_status();
  if (room_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_status_ = new ::std::string;
  }
  room_status_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ClanRoomSync.room_status)
}
inline void ClanRoomSync::set_room_status(const void* value, size_t size) {
  set_has_room_status();
  if (room_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_status_ = new ::std::string;
  }
  room_status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ClanRoomSync.room_status)
}
inline ::std::string* ClanRoomSync::mutable_room_status() {
  set_has_room_status();
  if (room_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ClanRoomSync.room_status)
  return room_status_;
}
inline ::std::string* ClanRoomSync::release_room_status() {
  clear_has_room_status();
  if (room_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = room_status_;
    room_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClanRoomSync::set_allocated_room_status(::std::string* room_status) {
  if (room_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete room_status_;
  }
  if (room_status) {
    set_has_room_status();
    room_status_ = room_status;
  } else {
    clear_has_room_status();
    room_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ClanRoomSync.room_status)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::EnterRoom_ENTER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::EnterRoom_ENTER_TYPE>() {
  return ::Adoter::Asset::EnterRoom_ENTER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::RandomSaizi_REASON_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::RandomSaizi_REASON_TYPE>() {
  return ::Adoter::Asset::RandomSaizi_REASON_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::GetReward_GET_REWARD_REASON> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::GetReward_GET_REWARD_REASON>() {
  return ::Adoter::Asset::GetReward_GET_REWARD_REASON_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE>() {
  return ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE>() {
  return ::Adoter::Asset::SyncCommonProperty_SYNC_REASON_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERR_USE_ITEM_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERR_USE_ITEM_TYPE>() {
  return ::Adoter::Asset::ERR_USE_ITEM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ITEM_CHANGED_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ITEM_CHANGED_TYPE>() {
  return ::Adoter::Asset::ITEM_CHANGED_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::DIAMOND_CHANGED_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::DIAMOND_CHANGED_TYPE>() {
  return ::Adoter::Asset::DIAMOND_CHANGED_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::HUANLEDOU_CHANGED_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::HUANLEDOU_CHANGED_TYPE>() {
  return ::Adoter::Asset::HUANLEDOU_CHANGED_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROOM_CARD_CHANGED_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROOM_CARD_CHANGED_TYPE>() {
  return ::Adoter::Asset::ROOM_CARD_CHANGED_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::SYSTEM_COOLDOWN_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::SYSTEM_COOLDOWN_TYPE>() {
  return ::Adoter::Asset::SYSTEM_COOLDOWN_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::POSITION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::POSITION_TYPE>() {
  return ::Adoter::Asset::POSITION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::LOAD_SCENE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::LOAD_SCENE_TYPE>() {
  return ::Adoter::Asset::LOAD_SCENE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CLAN_MEM_STATUS_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CLAN_MEM_STATUS_TYPE>() {
  return ::Adoter::Asset::CLAN_MEM_STATUS_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_TYPE>() {
  return ::Adoter::Asset::ERROR_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_SHOW_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_SHOW_TYPE>() {
  return ::Adoter::Asset::ERROR_SHOW_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_CODE>() {
  return ::Adoter::Asset::ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::META_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::META_TYPE>() {
  return ::Adoter::Asset::META_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ACCOUNT_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ACCOUNT_TYPE>() {
  return ::Adoter::Asset::ACCOUNT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::RECHARGE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::RECHARGE_TYPE>() {
  return ::Adoter::Asset::RECHARGE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CHAT_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CHAT_TYPE>() {
  return ::Adoter::Asset::CHAT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ZHUOBU_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ZHUOBU_TYPE>() {
  return ::Adoter::Asset::ZHUOBU_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CARD_COLOR_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CARD_COLOR_TYPE>() {
  return ::Adoter::Asset::CARD_COLOR_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PAI_OPER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PAI_OPER_TYPE>() {
  return ::Adoter::Asset::PAI_OPER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::GAME_OPER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::GAME_OPER_TYPE>() {
  return ::Adoter::Asset::GAME_OPER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CLAN_OPER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CLAN_OPER_TYPE>() {
  return ::Adoter::Asset::CLAN_OPER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROOM_SYNC_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROOM_SYNC_TYPE>() {
  return ::Adoter::Asset::ROOM_SYNC_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CALCULATE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CALCULATE_TYPE>() {
  return ::Adoter::Asset::CALCULATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::KICK_OUT_REASON> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::KICK_OUT_REASON>() {
  return ::Adoter::Asset::KICK_OUT_REASON_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::SYSTEM_BROADCAST_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::SYSTEM_BROADCAST_TYPE>() {
  return ::Adoter::Asset::SYSTEM_BROADCAST_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROLE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROLE_TYPE>() {
  return ::Adoter::Asset::ROLE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE>() {
  return ::Adoter::Asset::CLAN_ROOM_STATUS_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fProtocol_2eproto__INCLUDED
