// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Command.proto

#ifndef PROTOBUF_P_5fCommand_2eproto__INCLUDED
#define PROTOBUF_P_5fCommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fCommand_2eproto();
void protobuf_AssignDesc_P_5fCommand_2eproto();
void protobuf_ShutdownFile_P_5fCommand_2eproto();

class InnerMeta;
class Register;
class Command;
class OpenRoom;
class SendMail;
class SystemBroadcast;
class ActivityControl;
class QueryPlayer;

enum INNER_TYPE {
  INNER_TYPE_BEGIN = 0,
  INNER_TYPE_REGISTER = 1,
  INNER_TYPE_COMMAND = 2,
  INNER_TYPE_OPEN_ROOM = 3,
  INNER_TYPE_SEND_MAIL = 4,
  INNER_TYPE_SYSTEM_BROADCAST = 5,
  INNER_TYPE_ACTIVITY_CONTROL = 6,
  INNER_TYPE_QUERY_PLAYER = 7
};
bool INNER_TYPE_IsValid(int value);
const INNER_TYPE INNER_TYPE_MIN = INNER_TYPE_BEGIN;
const INNER_TYPE INNER_TYPE_MAX = INNER_TYPE_QUERY_PLAYER;
const int INNER_TYPE_ARRAYSIZE = INNER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* INNER_TYPE_descriptor();
inline const ::std::string& INNER_TYPE_Name(INNER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    INNER_TYPE_descriptor(), value);
}
inline bool INNER_TYPE_Parse(
    const ::std::string& name, INNER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<INNER_TYPE>(
    INNER_TYPE_descriptor(), name, value);
}
enum COMMAND_TYPE {
  COMMAND_TYPE_BEGIN = 0,
  COMMAND_TYPE_RECHARGE = 1,
  COMMAND_TYPE_ROOM_CARD = 2,
  COMMAND_TYPE_HUANLEDOU = 3
};
bool COMMAND_TYPE_IsValid(int value);
const COMMAND_TYPE COMMAND_TYPE_MIN = COMMAND_TYPE_BEGIN;
const COMMAND_TYPE COMMAND_TYPE_MAX = COMMAND_TYPE_HUANLEDOU;
const int COMMAND_TYPE_ARRAYSIZE = COMMAND_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* COMMAND_TYPE_descriptor();
inline const ::std::string& COMMAND_TYPE_Name(COMMAND_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    COMMAND_TYPE_descriptor(), value);
}
inline bool COMMAND_TYPE_Parse(
    const ::std::string& name, COMMAND_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COMMAND_TYPE>(
    COMMAND_TYPE_descriptor(), name, value);
}
enum COMMAND_ERROR_CODE {
  COMMAND_ERROR_CODE_SUCCESS = 0,
  COMMAND_ERROR_CODE_NO_PERMISSION = 1,
  COMMAND_ERROR_CODE_PARA = 2,
  COMMAND_ERROR_CODE_NO_ACCOUNT = 3,
  COMMAND_ERROR_CODE_NO_PLAYER = 4,
  COMMAND_ERROR_CODE_PLAYER_ONLINE = 5,
  COMMAND_ERROR_CODE_PLAYER_OFFLINE = 6,
  COMMAND_ERROR_CODE_ITEM_NOT_FOUND = 7,
  COMMAND_ERROR_CODE_SERVER_NOT_FOUND = 8,
  COMMAND_ERROR_CODE_ASSET_NOT_FOUND = 9
};
bool COMMAND_ERROR_CODE_IsValid(int value);
const COMMAND_ERROR_CODE COMMAND_ERROR_CODE_MIN = COMMAND_ERROR_CODE_SUCCESS;
const COMMAND_ERROR_CODE COMMAND_ERROR_CODE_MAX = COMMAND_ERROR_CODE_ASSET_NOT_FOUND;
const int COMMAND_ERROR_CODE_ARRAYSIZE = COMMAND_ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* COMMAND_ERROR_CODE_descriptor();
inline const ::std::string& COMMAND_ERROR_CODE_Name(COMMAND_ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    COMMAND_ERROR_CODE_descriptor(), value);
}
inline bool COMMAND_ERROR_CODE_Parse(
    const ::std::string& name, COMMAND_ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COMMAND_ERROR_CODE>(
    COMMAND_ERROR_CODE_descriptor(), name, value);
}
enum SERVER_TYPE {
  SERVER_TYPE_BEGIN = 0,
  SERVER_TYPE_GMT = 1,
  SERVER_TYPE_CENTER = 2,
  SERVER_TYPE_GAME = 3
};
bool SERVER_TYPE_IsValid(int value);
const SERVER_TYPE SERVER_TYPE_MIN = SERVER_TYPE_BEGIN;
const SERVER_TYPE SERVER_TYPE_MAX = SERVER_TYPE_GAME;
const int SERVER_TYPE_ARRAYSIZE = SERVER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SERVER_TYPE_descriptor();
inline const ::std::string& SERVER_TYPE_Name(SERVER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SERVER_TYPE_descriptor(), value);
}
inline bool SERVER_TYPE_Parse(
    const ::std::string& name, SERVER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SERVER_TYPE>(
    SERVER_TYPE_descriptor(), name, value);
}
// ===================================================================

class InnerMeta : public ::google::protobuf::Message {
 public:
  InnerMeta();
  virtual ~InnerMeta();

  InnerMeta(const InnerMeta& from);

  inline InnerMeta& operator=(const InnerMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerMeta& default_instance();

  void Swap(InnerMeta* other);

  // implements Message ----------------------------------------------

  InnerMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerMeta& from);
  void MergeFrom(const InnerMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1;
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional int64 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::int64 session_id() const;
  inline void set_session_id(::google::protobuf::int64 value);

  // optional bytes stuff = 3;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 3;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.InnerMeta)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_stuff();
  inline void clear_has_stuff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 session_id_;
  ::std::string* stuff_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static InnerMeta* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_REGISTER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.SERVER_TYPE server_type = 2;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 2;
  inline ::Adoter::Asset::SERVER_TYPE server_type() const;
  inline void set_server_type(::Adoter::Asset::SERVER_TYPE value);

  // optional int64 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::int64 server_id() const;
  inline void set_server_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Register)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int server_type_;
  ::google::protobuf::int64 server_id_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_COMMAND];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_TYPE command_type = 2;
  inline bool has_command_type() const;
  inline void clear_command_type();
  static const int kCommandTypeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_TYPE command_type() const;
  inline void set_command_type(::Adoter::Asset::COMMAND_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional bytes account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int64 player_id = 5;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int64 item_id = 6;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 6;
  inline ::google::protobuf::int64 item_id() const;
  inline void set_item_id(::google::protobuf::int64 value);

  // optional int32 count = 7;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 7;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Command)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_command_type();
  inline void clear_has_command_type();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int command_type_;
  ::std::string* account_;
  ::google::protobuf::int64 player_id_;
  int error_code_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int64 item_id_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class OpenRoom : public ::google::protobuf::Message {
 public:
  OpenRoom();
  virtual ~OpenRoom();

  OpenRoom(const OpenRoom& from);

  inline OpenRoom& operator=(const OpenRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenRoom& default_instance();

  void Swap(OpenRoom* other);

  // implements Message ----------------------------------------------

  OpenRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenRoom& from);
  void MergeFrom(const OpenRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_OPEN_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional int64 server_id = 3 [default = 1];
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::int64 server_id() const;
  inline void set_server_id(::google::protobuf::int64 value);

  // optional int64 room_id = 4;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional bytes options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const void* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.OpenRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_code_;
  ::google::protobuf::int64 server_id_;
  ::google::protobuf::int64 room_id_;
  ::std::string* options_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static OpenRoom* default_instance_;
};
// -------------------------------------------------------------------

class SendMail : public ::google::protobuf::Message {
 public:
  SendMail();
  virtual ~SendMail();

  SendMail(const SendMail& from);

  inline SendMail& operator=(const SendMail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMail& default_instance();

  void Swap(SendMail* other);

  // implements Message ----------------------------------------------

  SendMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMail& from);
  void MergeFrom(const SendMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_SEND_MAIL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int64 mail_id = 4;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 4;
  inline ::google::protobuf::int64 mail_id() const;
  inline void set_mail_id(::google::protobuf::int64 value);

  // optional bytes title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const void* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional bytes content = 6;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 6;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional int32 diamond_count = 7;
  inline bool has_diamond_count() const;
  inline void clear_diamond_count();
  static const int kDiamondCountFieldNumber = 7;
  inline ::google::protobuf::int32 diamond_count() const;
  inline void set_diamond_count(::google::protobuf::int32 value);

  // optional int32 huanledou_count = 8;
  inline bool has_huanledou_count() const;
  inline void clear_huanledou_count();
  static const int kHuanledouCountFieldNumber = 8;
  inline ::google::protobuf::int32 huanledou_count() const;
  inline void set_huanledou_count(::google::protobuf::int32 value);

  // optional int32 room_card_count = 9;
  inline bool has_room_card_count() const;
  inline void clear_room_card_count();
  static const int kRoomCardCountFieldNumber = 9;
  inline ::google::protobuf::int32 room_card_count() const;
  inline void set_room_card_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SendMail)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_mail_id();
  inline void clear_has_mail_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_diamond_count();
  inline void clear_has_diamond_count();
  inline void set_has_huanledou_count();
  inline void clear_has_huanledou_count();
  inline void set_has_room_card_count();
  inline void clear_has_room_card_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_code_;
  ::google::protobuf::int64 player_id_;
  ::google::protobuf::int64 mail_id_;
  ::std::string* title_;
  ::std::string* content_;
  ::google::protobuf::int32 diamond_count_;
  ::google::protobuf::int32 huanledou_count_;
  ::google::protobuf::int32 room_card_count_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static SendMail* default_instance_;
};
// -------------------------------------------------------------------

class SystemBroadcast : public ::google::protobuf::Message {
 public:
  SystemBroadcast();
  virtual ~SystemBroadcast();

  SystemBroadcast(const SystemBroadcast& from);

  inline SystemBroadcast& operator=(const SystemBroadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemBroadcast& default_instance();

  void Swap(SystemBroadcast* other);

  // implements Message ----------------------------------------------

  SystemBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemBroadcast& from);
  void MergeFrom(const SystemBroadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_SYSTEM_BROADCAST];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SystemBroadcast)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_code_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static SystemBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class ActivityControl : public ::google::protobuf::Message {
 public:
  ActivityControl();
  virtual ~ActivityControl();

  ActivityControl(const ActivityControl& from);

  inline ActivityControl& operator=(const ActivityControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityControl& default_instance();

  void Swap(ActivityControl* other);

  // implements Message ----------------------------------------------

  ActivityControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityControl& from);
  void MergeFrom(const ActivityControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_ACTIVITY_CONTROL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional int64 activity_id = 3;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 3;
  inline ::google::protobuf::int64 activity_id() const;
  inline void set_activity_id(::google::protobuf::int64 value);

  // optional bytes start_time = 4;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const void* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // optional bytes stop_time = 5;
  inline bool has_stop_time() const;
  inline void clear_stop_time();
  static const int kStopTimeFieldNumber = 5;
  inline const ::std::string& stop_time() const;
  inline void set_stop_time(const ::std::string& value);
  inline void set_stop_time(const char* value);
  inline void set_stop_time(const void* value, size_t size);
  inline ::std::string* mutable_stop_time();
  inline ::std::string* release_stop_time();
  inline void set_allocated_stop_time(::std::string* stop_time);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ActivityControl)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_stop_time();
  inline void clear_has_stop_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_code_;
  ::google::protobuf::int64 activity_id_;
  ::std::string* start_time_;
  ::std::string* stop_time_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static ActivityControl* default_instance_;
};
// -------------------------------------------------------------------

class QueryPlayer : public ::google::protobuf::Message {
 public:
  QueryPlayer();
  virtual ~QueryPlayer();

  QueryPlayer(const QueryPlayer& from);

  inline QueryPlayer& operator=(const QueryPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPlayer& default_instance();

  void Swap(QueryPlayer* other);

  // implements Message ----------------------------------------------

  QueryPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPlayer& from);
  void MergeFrom(const QueryPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_QUERY_PLAYER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::INNER_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::INNER_TYPE value);

  // optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::Adoter::Asset::COMMAND_ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional bytes common_prop = 4;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 4;
  inline const ::std::string& common_prop() const;
  inline void set_common_prop(const ::std::string& value);
  inline void set_common_prop(const char* value);
  inline void set_common_prop(const void* value, size_t size);
  inline ::std::string* mutable_common_prop();
  inline ::std::string* release_common_prop();
  inline void set_allocated_common_prop(::std::string* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.QueryPlayer)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_code_;
  ::google::protobuf::int64 player_id_;
  ::std::string* common_prop_;
  friend void  protobuf_AddDesc_P_5fCommand_2eproto();
  friend void protobuf_AssignDesc_P_5fCommand_2eproto();
  friend void protobuf_ShutdownFile_P_5fCommand_2eproto();

  void InitAsDefaultInstance();
  static QueryPlayer* default_instance_;
};
// ===================================================================


// ===================================================================

// InnerMeta

// optional .Adoter.Asset.INNER_TYPE type_t = 1;
inline bool InnerMeta::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerMeta::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerMeta::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerMeta::clear_type_t() {
  type_t_ = 0;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE InnerMeta::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.InnerMeta.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void InnerMeta::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.InnerMeta.type_t)
}

// optional int64 session_id = 2;
inline bool InnerMeta::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerMeta::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerMeta::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerMeta::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::int64 InnerMeta::session_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.InnerMeta.session_id)
  return session_id_;
}
inline void InnerMeta::set_session_id(::google::protobuf::int64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.InnerMeta.session_id)
}

// optional bytes stuff = 3;
inline bool InnerMeta::has_stuff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerMeta::set_has_stuff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerMeta::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerMeta::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& InnerMeta::stuff() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.InnerMeta.stuff)
  return *stuff_;
}
inline void InnerMeta::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.InnerMeta.stuff)
}
inline void InnerMeta::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.InnerMeta.stuff)
}
inline void InnerMeta::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.InnerMeta.stuff)
}
inline ::std::string* InnerMeta::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.InnerMeta.stuff)
  return stuff_;
}
inline ::std::string* InnerMeta::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerMeta::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.InnerMeta.stuff)
}

// -------------------------------------------------------------------

// Register

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_REGISTER];
inline bool Register::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_type_t() {
  type_t_ = 1;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE Register::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Register.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void Register::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Register.type_t)
}

// optional .Adoter.Asset.SERVER_TYPE server_type = 2;
inline bool Register::has_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_server_type() {
  server_type_ = 0;
  clear_has_server_type();
}
inline ::Adoter::Asset::SERVER_TYPE Register::server_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Register.server_type)
  return static_cast< ::Adoter::Asset::SERVER_TYPE >(server_type_);
}
inline void Register::set_server_type(::Adoter::Asset::SERVER_TYPE value) {
  assert(::Adoter::Asset::SERVER_TYPE_IsValid(value));
  set_has_server_type();
  server_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Register.server_type)
}

// optional int64 server_id = 3;
inline bool Register::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_server_id() {
  server_id_ = GOOGLE_LONGLONG(0);
  clear_has_server_id();
}
inline ::google::protobuf::int64 Register::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Register.server_id)
  return server_id_;
}
inline void Register::set_server_id(::google::protobuf::int64 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Register.server_id)
}

// -------------------------------------------------------------------

// Command

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_COMMAND];
inline bool Command::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE Command::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void Command::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.type_t)
}

// optional .Adoter.Asset.COMMAND_TYPE command_type = 2;
inline bool Command::has_command_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_command_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_command_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_command_type() {
  command_type_ = 0;
  clear_has_command_type();
}
inline ::Adoter::Asset::COMMAND_TYPE Command::command_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.command_type)
  return static_cast< ::Adoter::Asset::COMMAND_TYPE >(command_type_);
}
inline void Command::set_command_type(::Adoter::Asset::COMMAND_TYPE value) {
  assert(::Adoter::Asset::COMMAND_TYPE_IsValid(value));
  set_has_command_type();
  command_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.command_type)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 3;
inline bool Command::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE Command::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void Command::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.error_code)
}

// optional bytes account = 4;
inline bool Command::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& Command::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.account)
  return *account_;
}
inline void Command::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.account)
}
inline void Command::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Command.account)
}
inline void Command::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Command.account)
}
inline ::std::string* Command::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Command.account)
  return account_;
}
inline ::std::string* Command::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Command.account)
}

// optional int64 player_id = 5;
inline bool Command::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 Command::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.player_id)
  return player_id_;
}
inline void Command::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.player_id)
}

// optional int64 item_id = 6;
inline bool Command::has_item_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_item_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_item_id() {
  item_id_ = GOOGLE_LONGLONG(0);
  clear_has_item_id();
}
inline ::google::protobuf::int64 Command::item_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.item_id)
  return item_id_;
}
inline void Command::set_item_id(::google::protobuf::int64 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.item_id)
}

// optional int32 count = 7;
inline bool Command::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Command::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Command.count)
  return count_;
}
inline void Command::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Command.count)
}

// -------------------------------------------------------------------

// OpenRoom

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_OPEN_ROOM];
inline bool OpenRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenRoom::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE OpenRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.OpenRoom.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void OpenRoom::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.OpenRoom.type_t)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
inline bool OpenRoom::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenRoom::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenRoom::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenRoom::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE OpenRoom::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.OpenRoom.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void OpenRoom::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.OpenRoom.error_code)
}

// optional int64 server_id = 3 [default = 1];
inline bool OpenRoom::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenRoom::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenRoom::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenRoom::clear_server_id() {
  server_id_ = GOOGLE_LONGLONG(1);
  clear_has_server_id();
}
inline ::google::protobuf::int64 OpenRoom::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.OpenRoom.server_id)
  return server_id_;
}
inline void OpenRoom::set_server_id(::google::protobuf::int64 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.OpenRoom.server_id)
}

// optional int64 room_id = 4;
inline bool OpenRoom::has_room_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenRoom::set_has_room_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenRoom::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenRoom::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 OpenRoom::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.OpenRoom.room_id)
  return room_id_;
}
inline void OpenRoom::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.OpenRoom.room_id)
}

// optional bytes options = 5;
inline bool OpenRoom::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenRoom::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenRoom::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenRoom::clear_options() {
  if (options_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_->clear();
  }
  clear_has_options();
}
inline const ::std::string& OpenRoom::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.OpenRoom.options)
  return *options_;
}
inline void OpenRoom::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.OpenRoom.options)
}
inline void OpenRoom::set_options(const char* value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.OpenRoom.options)
}
inline void OpenRoom::set_options(const void* value, size_t size) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.OpenRoom.options)
}
inline ::std::string* OpenRoom::mutable_options() {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.OpenRoom.options)
  return options_;
}
inline ::std::string* OpenRoom::release_options() {
  clear_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenRoom::set_allocated_options(::std::string* options) {
  if (options_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.OpenRoom.options)
}

// -------------------------------------------------------------------

// SendMail

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_SEND_MAIL];
inline bool SendMail::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMail::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMail::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMail::clear_type_t() {
  type_t_ = 4;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE SendMail::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void SendMail::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.type_t)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
inline bool SendMail::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendMail::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendMail::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendMail::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE SendMail::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void SendMail::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.error_code)
}

// optional int64 player_id = 3;
inline bool SendMail::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendMail::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendMail::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendMail::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 SendMail::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.player_id)
  return player_id_;
}
inline void SendMail::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.player_id)
}

// optional int64 mail_id = 4;
inline bool SendMail::has_mail_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendMail::set_has_mail_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendMail::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendMail::clear_mail_id() {
  mail_id_ = GOOGLE_LONGLONG(0);
  clear_has_mail_id();
}
inline ::google::protobuf::int64 SendMail::mail_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.mail_id)
  return mail_id_;
}
inline void SendMail::set_mail_id(::google::protobuf::int64 value) {
  set_has_mail_id();
  mail_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.mail_id)
}

// optional bytes title = 5;
inline bool SendMail::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendMail::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendMail::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendMail::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SendMail::title() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.title)
  return *title_;
}
inline void SendMail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.title)
}
inline void SendMail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SendMail.title)
}
inline void SendMail::set_title(const void* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SendMail.title)
}
inline ::std::string* SendMail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SendMail.title)
  return title_;
}
inline ::std::string* SendMail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendMail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SendMail.title)
}

// optional bytes content = 6;
inline bool SendMail::has_content() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendMail::set_has_content() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendMail::clear_has_content() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendMail::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SendMail::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.content)
  return *content_;
}
inline void SendMail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.content)
}
inline void SendMail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SendMail.content)
}
inline void SendMail::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SendMail.content)
}
inline ::std::string* SendMail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SendMail.content)
  return content_;
}
inline ::std::string* SendMail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendMail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SendMail.content)
}

// optional int32 diamond_count = 7;
inline bool SendMail::has_diamond_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendMail::set_has_diamond_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendMail::clear_has_diamond_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendMail::clear_diamond_count() {
  diamond_count_ = 0;
  clear_has_diamond_count();
}
inline ::google::protobuf::int32 SendMail::diamond_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.diamond_count)
  return diamond_count_;
}
inline void SendMail::set_diamond_count(::google::protobuf::int32 value) {
  set_has_diamond_count();
  diamond_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.diamond_count)
}

// optional int32 huanledou_count = 8;
inline bool SendMail::has_huanledou_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendMail::set_has_huanledou_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendMail::clear_has_huanledou_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendMail::clear_huanledou_count() {
  huanledou_count_ = 0;
  clear_has_huanledou_count();
}
inline ::google::protobuf::int32 SendMail::huanledou_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.huanledou_count)
  return huanledou_count_;
}
inline void SendMail::set_huanledou_count(::google::protobuf::int32 value) {
  set_has_huanledou_count();
  huanledou_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.huanledou_count)
}

// optional int32 room_card_count = 9;
inline bool SendMail::has_room_card_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SendMail::set_has_room_card_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SendMail::clear_has_room_card_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SendMail::clear_room_card_count() {
  room_card_count_ = 0;
  clear_has_room_card_count();
}
inline ::google::protobuf::int32 SendMail::room_card_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SendMail.room_card_count)
  return room_card_count_;
}
inline void SendMail::set_room_card_count(::google::protobuf::int32 value) {
  set_has_room_card_count();
  room_card_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SendMail.room_card_count)
}

// -------------------------------------------------------------------

// SystemBroadcast

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_SYSTEM_BROADCAST];
inline bool SystemBroadcast::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemBroadcast::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemBroadcast::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemBroadcast::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE SystemBroadcast::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcast.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void SystemBroadcast::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcast.type_t)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
inline bool SystemBroadcast::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemBroadcast::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemBroadcast::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemBroadcast::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE SystemBroadcast::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcast.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void SystemBroadcast::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcast.error_code)
}

// optional bytes content = 3;
inline bool SystemBroadcast::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemBroadcast::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemBroadcast::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemBroadcast::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SystemBroadcast::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SystemBroadcast.content)
  return *content_;
}
inline void SystemBroadcast::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.SystemBroadcast.content)
}
inline void SystemBroadcast::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.SystemBroadcast.content)
}
inline void SystemBroadcast::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.SystemBroadcast.content)
}
inline ::std::string* SystemBroadcast::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SystemBroadcast.content)
  return content_;
}
inline ::std::string* SystemBroadcast::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemBroadcast::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SystemBroadcast.content)
}

// -------------------------------------------------------------------

// ActivityControl

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_ACTIVITY_CONTROL];
inline bool ActivityControl::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityControl::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityControl::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityControl::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE ActivityControl::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ActivityControl.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void ActivityControl::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ActivityControl.type_t)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
inline bool ActivityControl::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityControl::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityControl::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityControl::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE ActivityControl::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ActivityControl.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void ActivityControl::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ActivityControl.error_code)
}

// optional int64 activity_id = 3;
inline bool ActivityControl::has_activity_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityControl::set_has_activity_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityControl::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityControl::clear_activity_id() {
  activity_id_ = GOOGLE_LONGLONG(0);
  clear_has_activity_id();
}
inline ::google::protobuf::int64 ActivityControl::activity_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ActivityControl.activity_id)
  return activity_id_;
}
inline void ActivityControl::set_activity_id(::google::protobuf::int64 value) {
  set_has_activity_id();
  activity_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ActivityControl.activity_id)
}

// optional bytes start_time = 4;
inline bool ActivityControl::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActivityControl::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActivityControl::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActivityControl::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& ActivityControl::start_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ActivityControl.start_time)
  return *start_time_;
}
inline void ActivityControl::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ActivityControl.start_time)
}
inline void ActivityControl::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ActivityControl.start_time)
}
inline void ActivityControl::set_start_time(const void* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ActivityControl.start_time)
}
inline ::std::string* ActivityControl::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ActivityControl.start_time)
  return start_time_;
}
inline ::std::string* ActivityControl::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActivityControl::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ActivityControl.start_time)
}

// optional bytes stop_time = 5;
inline bool ActivityControl::has_stop_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActivityControl::set_has_stop_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActivityControl::clear_has_stop_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActivityControl::clear_stop_time() {
  if (stop_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_->clear();
  }
  clear_has_stop_time();
}
inline const ::std::string& ActivityControl::stop_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ActivityControl.stop_time)
  return *stop_time_;
}
inline void ActivityControl::set_stop_time(const ::std::string& value) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.ActivityControl.stop_time)
}
inline void ActivityControl::set_stop_time(const char* value) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.ActivityControl.stop_time)
}
inline void ActivityControl::set_stop_time(const void* value, size_t size) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.ActivityControl.stop_time)
}
inline ::std::string* ActivityControl::mutable_stop_time() {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.ActivityControl.stop_time)
  return stop_time_;
}
inline ::std::string* ActivityControl::release_stop_time() {
  clear_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stop_time_;
    stop_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActivityControl::set_allocated_stop_time(::std::string* stop_time) {
  if (stop_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stop_time_;
  }
  if (stop_time) {
    set_has_stop_time();
    stop_time_ = stop_time;
  } else {
    clear_has_stop_time();
    stop_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.ActivityControl.stop_time)
}

// -------------------------------------------------------------------

// QueryPlayer

// optional .Adoter.Asset.INNER_TYPE type_t = 1 [default = INNER_TYPE_QUERY_PLAYER];
inline bool QueryPlayer::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPlayer::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPlayer::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPlayer::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::Adoter::Asset::INNER_TYPE QueryPlayer::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.QueryPlayer.type_t)
  return static_cast< ::Adoter::Asset::INNER_TYPE >(type_t_);
}
inline void QueryPlayer::set_type_t(::Adoter::Asset::INNER_TYPE value) {
  assert(::Adoter::Asset::INNER_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.QueryPlayer.type_t)
}

// optional .Adoter.Asset.COMMAND_ERROR_CODE error_code = 2;
inline bool QueryPlayer::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryPlayer::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryPlayer::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryPlayer::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::COMMAND_ERROR_CODE QueryPlayer::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.QueryPlayer.error_code)
  return static_cast< ::Adoter::Asset::COMMAND_ERROR_CODE >(error_code_);
}
inline void QueryPlayer::set_error_code(::Adoter::Asset::COMMAND_ERROR_CODE value) {
  assert(::Adoter::Asset::COMMAND_ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.QueryPlayer.error_code)
}

// optional int64 player_id = 3;
inline bool QueryPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryPlayer::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 QueryPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.QueryPlayer.player_id)
  return player_id_;
}
inline void QueryPlayer::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.QueryPlayer.player_id)
}

// optional bytes common_prop = 4;
inline bool QueryPlayer::has_common_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryPlayer::set_has_common_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryPlayer::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryPlayer::clear_common_prop() {
  if (common_prop_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_prop_->clear();
  }
  clear_has_common_prop();
}
inline const ::std::string& QueryPlayer::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.QueryPlayer.common_prop)
  return *common_prop_;
}
inline void QueryPlayer::set_common_prop(const ::std::string& value) {
  set_has_common_prop();
  if (common_prop_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_prop_ = new ::std::string;
  }
  common_prop_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.QueryPlayer.common_prop)
}
inline void QueryPlayer::set_common_prop(const char* value) {
  set_has_common_prop();
  if (common_prop_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_prop_ = new ::std::string;
  }
  common_prop_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.QueryPlayer.common_prop)
}
inline void QueryPlayer::set_common_prop(const void* value, size_t size) {
  set_has_common_prop();
  if (common_prop_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_prop_ = new ::std::string;
  }
  common_prop_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.QueryPlayer.common_prop)
}
inline ::std::string* QueryPlayer::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_prop_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.QueryPlayer.common_prop)
  return common_prop_;
}
inline ::std::string* QueryPlayer::release_common_prop() {
  clear_has_common_prop();
  if (common_prop_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = common_prop_;
    common_prop_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QueryPlayer::set_allocated_common_prop(::std::string* common_prop) {
  if (common_prop_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete common_prop_;
  }
  if (common_prop) {
    set_has_common_prop();
    common_prop_ = common_prop;
  } else {
    clear_has_common_prop();
    common_prop_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.QueryPlayer.common_prop)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::INNER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::INNER_TYPE>() {
  return ::Adoter::Asset::INNER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::COMMAND_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::COMMAND_TYPE>() {
  return ::Adoter::Asset::COMMAND_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::COMMAND_ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::COMMAND_ERROR_CODE>() {
  return ::Adoter::Asset::COMMAND_ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::SERVER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::SERVER_TYPE>() {
  return ::Adoter::Asset::SERVER_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fCommand_2eproto__INCLUDED
